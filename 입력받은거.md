# <a name="top">목록</a>
- [목록](#목록)
  - [기본 양식](#기본-양식)
  - [9월 11일](#9월-11일)
  - [9월 12일](#9월-12일)
  - [9월 13일](#9월-13일)
  - [9월 14일](#9월-14일)
  - [9월 15일](#9월-15일)
  - [9월 18일](#9월-18일)
  - [9월 19일](#9월-19일)
  - [9월 20일](#9월-20일)
  - [9월 21일](#9월-21일)
  - [9월 22일](#9월-22일)
  - [9월 25일](#9월-25일)
  - [9월 26일](#9월-26일)
  - [9월 27일](#9월-27일)
  - [10월 4일](#10월-4일)
  - [10월 5일](#10월-5일)
  - [10월 6일](#10월-6일)
  - [10월 11일](#10월-11일)
  - [10월 12일](#10월-12일)
  - [10월 13일](#10월-13일)
  - [10월 15일](#10월-15일)
  - [10월 16일](#10월-16일)
  - [10월 17일](#10월-17일)
  - [10월 18일](#10월-18일)
  - [10월 19일](#10월-19일)

## [기본 양식](#top)
<details>
<summary>일단 무지성하게 기록하다가 주말에 에쁘게 정리하기</summary>
<p></p>
</details>

---취소선<br>
**두껍게**<br>
*기울임*<br>
~~취소선~~<br>

## [9월 11일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>html(Hyper Text Markup Language) => 왜 Hyper일까? - text를 누르면 다른페이지로 가벌임;; 그래서 초월이란 의미의 Hyper, 
왜 Markup일까? - <>태그 안에 집어넣는걸 markup이라고 함</p>
<p>https://www.w3schools.com/html/html_colors.asp 여기서 HTML,CSS등 참고</p>
<p>질문을 zoom으로 하면 놓칠 수 있으니까 slack으로 질문하기</p>
<p>dm에 거부감 없이 질문하기, 교수님한테는 공부질문, ft한테는 설정질문?</p>
<p>대부분의 수업이 원론을 벗어나 실무에 쓰이는 기술 사용(ex, 데이터베이스-스키마설계)</p>
<p>카페에도 과목별로 정리된 형태로 볼 수 있음</p>
<p>윈도우에 리눅수가 들어가있는데 비활성화된 상태임</p>
<p>기술스택들 한번 검색해보기</p>
<p>내가 집중해야할 거 서버와 데이터베이스 + 프론트엔드 10%</p>
<p>프론트 쪽에서도 3,4일차의 js, jquery를 잘 알아두면 좋다.</p>
<p>이제부터 백엔드로서 나에겐 책은 사전이다.</p>
<p>이번주 내가 이해해야 할 목표</p>
<p>한 3개월차부터는 정보처리기능사를 준비해도됨. 배우는 내용이 유사함</p>
<p>정적웹과 동적웹이 동시에 보여지는 네이버 사이트를 설명해주심</p>
<p>고정된 데이터는 html, 스타일은 css, 기능과 외부 데이터를 끌어오는거는 js</p>
<p>클라이언트측 / 웹서버측(웹서비스 주는 서버 컴퓨터 + WAS), DB측</p>
<p>네이버로 예를 들면, 클라이언트가 네이버 첫 페이지 보여달라고 요쳥<br>
=> 서버에 요청하거나 받을 때, http(Hyper Text Transfer Protocol)라는 방법을 쓰기로 합의함<br>
=> 단순한 요청은(html), 네이버 웹서버가 클라이언트에 보여주고, 브라우저가 html대로 보여줌<br>
=> 복잡한건(java, 동적 웹 등) WAS를 통해 DB까지 찾아가서 데이터 보내줌<br>
=> WAS(Web Application Server)라는건 java로 DB처리를 가능하게 해주는 프로그램<br>
=> WAS는 DB에 줄 때 SQL, 받을 때 Resulset라는 방법을 통해 데이터를 주고받음</p>
<p>현재 html 5 버전 사용, w3c에서 http 사용 합의와 html5, css3 버전 사용 등을 합의함</p>
<p>IT 기초 용어집 훑어보기</p>
<p>단축키를 보통 snippet이라고 부르는 듯, 한국어론 코드 조각 모음</p>
<p>html쳤을 때 html:5 snippet을 사용하면 html의 기본 뼈대를 다 만들어줌</p>
<p>백엔드 개발자는 웹에서 개발자 도구를 많이 써서 오류를 잡음</p>
<p>html이 열리면, head제목과 속성을 따와서, body의 모양대로 배치하고, html이 닫힌다.</p>
<p>live server는 저장을 일일이 안눌러도 열린 브라우저에 파일 내용이 반영되는 프로그램</p>
<p><>속 태그는 소문자 대문자 구분 안하지만, 태그 속성은 소문자로 작성해야 한다.</p>
<p>테이블 실습 한번만 더 해보기</p>
</details>
<details>
<summary>HTML</summary>
<p>HTML은 Hyper Text Markup Language라는 의미로,<br>
Hyper - 초월하는 (다른페이지로 감)<br>
Text - 문자<br>
Markup - <>안에 집어넣는 문법<br>
Language - 등의 방법을 사용하는 언어다.<br>
웹페이지를 구성하는 언어로 선택되어있는데, 태그와 문자로 화면을 구성하고 화면에 표시된 문자로 다른 웹사이트와 연결된다.</p>
</details>
<details>
<summary>CSS</summary>
<p>CSS는 Cascading Style Sheet를 의미한다.<br>
계단식으로 적용되는 스타일 시트로, HTML, 즉 마크업 언어가 웹페이지에 어떤 특성을 가지고 어떤 모양으로 표시될 지 결정한다.</p>
</details>
<details>
<summary>JavaScript</summary>
<p>프로그래밍 언어로, JAVA와 흡사한 부분이 많은 언어이다.<br>
HTML은 웹페이지의 뼈대를 갖추고, CSS가 웹페이지의 모양을 만든다면, JS는 웹페이지가 동작하는 법을 담당한다.<br>
HTML의 각종 움직임이나 서버를 통한 데이터 전달 등의 역할을 JS가 맡는다.<br>
내가 알기론 프로그래밍 언어 중 JS만 브라우저가 인식할 수 있는 언어라 쓰일 수 있는 것으로 알고 있다.<br>
상당히 예외가 많고 허술한 불안정한 부분이 있는 언어지만, jquery등과 es6등의 문법으로 많이 발전하는 중이다.<br>
게다가 이상하게 크롬 브라우저에서 가장 빠른 언어에다가 브라우저에서 가장 오래 쓰인 언어라 점유율도 높다.<br>
물론 JS가 쓰이는 한계는 웹브라우저와 웹서버까지의 단계기 때문에 백엔드 개발자가 되어야하는 내 입장에선 조금은 알아둘 필요가 있다.</p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>

## [9월 12일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>HTML,CSS,JS 전부 필수지만 JS만 심화, 나머지 둘은 기본만 하기</p>
<p>JQUERY = JS랑 똑같은데 훨씬 짧게 만들 수 있음, 근데 그렇다고 JS를 안쓰는 건 아님.</p>
<p>오늘은 기필코 TDD방법론 알아보기</p>
<p>클라이언트측 브라우저는 프론트엔드 3총사만 해석할 수 있음. 그래서 그거 씀</p>
<p>HTTP의 특칭 - 무연결성 / 무상태성
무연결성 - 한번 요청, 한번 응답, 노 유지
무상태성 - 이전 연결이 다시 왔을 때 클라이언트마다 ID 부여해서 작업 수행</p>
<p>form, input, select, option, button</p>
<p>사이트 1개 = 프로젝트 1개 (ex: web01)</p>
<p><!DOCTYPE html> = 이 문서는 html임 하고 알려주는 거임</p>
<p>input 시리즈 다 한번 넣어보기</p>
<p>코드에 항상 주석을 쓰는 버릇을 들이기, 내가 써도 모를 수도 있고, 협업에 도움 됨</p>
<p>CSS 3 부터는 애니메이션도 적용가능, 우린 안쓰지만 ㅋ</p>
<p>ling + css로 head 안쪽 마지막에 집어넣어서 스타일 적용하기</p>
<p>언어마다 주석 모양이 다르다.</p>
<p>CSS기본 선택자, 가상 선택자, 속성 선택자, CSS사용법, DOM Tree란 무엇인가</p>
<p>기본 선택자 - 태그, 클래스, id</p>
<p>마지막 CSS정리문제 풀기</p>
<p>DOM Tree라는건?</p>
</details>

## [9월 13일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>객체지향 언어 = 부품 조립식 언어</p>
<p>띠요오오옹??? JS는 프론트엔드 개발자가 쓰는게 아니었따?? 백엔드였따???</p>
<p>JS 새삼 중요한 이유는 서버의 부담을 줄여줄 수 있는 방법이기 때문이다.
서버가 과부하 되면 결국 느려지기 마련인데 브라우저의 JS를 효과적으로 이용하면 서버의 부담을 줄여줄 수 있다.
그럼 백엔드 개발자는 어떻게 해야한다? JS를 효과적으로 이용해서 서버의 부담을 줄여줄 수 있는 능력을 갖춰야 좋은 개발자라고 말할 수 있겠지?</p>
<p>padding, border, margin => content를 안쪽에서부터 감싸는 테두리 설정</p>
<p>div의 위치 조정은 static, absoulute, fixed등으로 조정</p>
<p>padding 안쪽 여백, maring 바깥쪽 여백</p>
<p>float left, right 스타일 왼쪽 붙이기, 오른쪽 붙이기</p>
<p>이미지 대신 CSS를 쓰는 이유 => 마찬가지로 서버의 부담을 줄이기 위해</p>
<p>부트스트랩? 사이트를 만들어줄 수 있게 도와주는 프로그램.</p>
<p>w3y에서 부트스트랩 이용해서 css만 갖다 쓰거나 할 수 있음, 부트스트랩 링크를 긁어와서 head안에 붙이면 됨.</p>
<p>button 태그를 예로 들면 태그 안에 class="btn ~~"으로 클래스 지정만 해주면 버튼 css를 적용할 수 있음
어떤 클래스가 어떤css를 가지는지는 w3y 속 bootstrap5 tutorial tap을 보면 다 나와있음</p>
<p>부트스트랩이라는 이름의 가장 유명한 HTML,CSS,JS 라이브러리인 것</p>
<p>부트스트랩은 CDN(Content Delivery Network)라는 웹 컨텐츠를 온라인 상에서 전달하는 방식을 사용하는 라이브러리</p>
<p>부트스트랩 여러개 보면서 예쁜 사이트 만들어보기</p>
<p>코드를 전송할 때 엔터가 많이 있으면 서버에 부담이 커짐. 그래서 전송용 코드에서 엔터를 없애주는 프로그램이 있음</p>
<p>span, div</p>
<p>최종 포폴에 부트스트랩을 써보라는 말 난 말이야 말말말말말말말말말말말</p>
<p>자바스크립트 => jQuery(자바스크립트 쉽게 쓰기), Ajax(jQuery에서 외부사이트 통신)</p>
<p>Ajax를 이용해서 화면을 바꾸지 않고도(=비동기 통신) ID가 서버에 존재하는지 검사가능, 사용자의 위치에 따라 날씨 정보 출력 가능</p>
<p>입력값 유효성 검증 - 비밀번호나 id등이 규격에 맞는지 등 검사 => 서버의 최적화를 위한 브라우저 단계에서의 JS가동</p>
<p>JS는 CSS처럼 외부 파일의 id나 class를 이용해서 html에 접근한다.</p>
<p>JS의 실행은 브라우저에서 실시된다, 그래서 오류는 브라우저에서 확인해야한다 (개발자도구 - 콘솔)</p>
<p>JS를 html에서 연결하는 방법은 태그만 다를 뿐 CSS의 적용방법과 같다.(external, internal, inline)</p>
<p>internal 방식 = head에 <scirpt>작성</script></p>
<p>external 방식 = head에 '</script></p>
<p>inline 방식 = 태그 안에 on뭐시기="자바스크립트 명령어"</p>
<p>나중에 서버등 담고 실행하고 하려면 c드라이브가 최소 60기가 정도는 남아있어야 원활하게 학습을 이어나갈 수 있다.</p>
<p>새삼 변수는 어떤 저장공간에 저장하는지 생각을 안했네;; RAM에 저장됨</p>
<p>보통 함수고 왔다갔다고 계산이고 전부 cpu가 처리함, RAM, C,D드라이브 등은 cpu가 이용하는 도구일 뿐</p>
<p>내가 cpu와 RAM을 얼마나 짧게, 조금 쓰는지 보는게 코딩테스트, 작게 쓰면 부하를 적게 주는 코드니까 좋은 코드겠쬬?</p>
<p>좋은 알고리즘 - cpu를 적게씀 = 시간복잡도가 낮음 / 좋은 자료구조 - Ram을 적게씀 = 공간복잡도가 낮음</p>
<p>컴퓨터의 기본 데이터 - 숫자(정수+실수), 문자, 논리 => 그럼 기본 데이터 가지고는 인터넷 접속도 안되고 동영상도 못보겠네? - YES</p>
<p>가르쳐주시기로는 변수 생략가능하다고 함(?)</p>
<p>클래스만 대문자, 변수는 보통 소문자</p>
<p>var 냥 = "" => 문자열 변수 선언</p>
<p>냥 = "고양이" => 냥 변수에 문자열 "고양이" 할당</p>
<p>냥 => 쓰레기 값(선언 X, 초기화 X)</p>
<p>와우 코드 끝에;가 들어가는 이유가 엔터를 빼고 전송하기 위한 밑밥이었음;;; //ㄴㄴ 자바는 그런거 상관없어 그냥 달아야해 ㅠㅠ</p>
<p>shift + del = 한 줄 지우기</p>
</details>

## [9월 14일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>자바 스크립트 프론트엔드 아님? 왜 우리 백엔드가 함? - 웹 브라우저에서만 있으면 상관없지만 결국 웹서버에서 브라우저로 HTML,CSS,JS를 전달하는 입장에서 백엔드 개발자는 JS를 알고있어야 한다.</p>
<p>jQuery, Ajax까지 끝나면 UI등을 설정하는 프로그램으로 미니 프로젝트</p>
<p>HTML, CSS는 설정 중싱 언어 / 자바 스크립트, 자바 등은 처리 중심 언어</p>
<p>자바가 굉장히 체계적이라 일단 자바를 잘 배워놓으면 다른 언어도 잘 쓸 수 있을 가능성이 높음</p>
<p>데이터(기본 데이터) --> 연산자(기호) --> 순차적인처리, 조건처리, 반복처리(코테 같은 것의 데이터)
많은 양의 데이터(배열)<br>
기본 데이터 이외의 데이터(객체-window,location,history, 틀-클래스)<br>
=> 자바를 포함한 대부분 언어의 매커니즘</p>
<p>자바 스크립트 - 브라우저에서 실행, 자바 - 서버에서 실행</p>
<p>자바 vs 자바 스크립트 다른 점 면접에서 꽤 물어보나봐 외워야징</p>
<p>system.in = 컴퓨터에.키보드로 입력</p>
<p>systme.out = 컴퓨터에서.모니터등으로 출력</p>
<p>웹 개발에선 연산자 중엔 비교 연산자가 가장 많이 쓰임 (조건문이 존나게 많음)</p>
<p>자바, 자바 스크립트는 cameCase(권장), 파이썬에선 snake_case</p>
<p>정적 타이핑 - c++, java / 동적 타이핑 - javascript, python</p>
<p>플러스 연산자 사용 시 하나라도 문자면 결합 연산자가 된다</p>
<p>입력으로 받은 데이터는 무조건 문자형, 왜? => 문자인지 숫자인지 결정할 능력x, 이건 프로그래머가 결정해야함</p>
<p>parseInt() 등 상당히 많은 자바 스크립트 명령어가 자바 명령어랑 비슷한 면이 있다. 외우기 쉽겠다 키킥</p>
<p>변수에다가 prompt()를 할당하는게 가능함</p>
<p>객체지향 코딩이 뭔지 알아바렸다.. 일단은 자바 스크립트가 가진 객체인 window, locaion, document, history를 잘 써보자</p>
<p>작성 쓰끼리 => 코드작성 - 실행 - 주석처리 - 작성 - 실행 - 오류발생 => 주석처리를 섞으면 오류 쉽게 발견 가능</p>
<p>하나하나 말해주면서 하면 다 이해되는데 나중에 '이런 사이트를 만들어라' 하고 띡 주면 꼭, '\n' 이런거 하나씩 놓침 ㅠㅠ</p>
<p>html문서로 js작업을 하다 보니까 console.log가 아니라 document.write를 더 자주 쓰게 되는 구만</p>
<p>현대로 오면서 confirm, prompt, alert등의 명령어가 안쓰임, 이유? => 클릭 자꾸 시킴, 귀찮음.</p>
<p>이런 설명 들으면서 새삼 깨닫는 비동기식 처리를 쓰는 이유?</p>
<p>js11-버튼처리 파일 이론상으로는 알고 있는데 한번도 안써봤으니까 다시 써보기</p>
<p>버튼 기능 하나 - 함수 하나 등 => 딱 그것만 실행시켜서 부하를 줄이기 위함</p>
</details>

## [9월 15일](#top)
<details>
<summary>오늘 배운 거</summary>
</p>javascript도 CSS에서 태그를 하나 지정하고 싶을 때처럼 id를 지정해서 가져올 수 있다. 그리고 당연히 id는 중복되면 안됨</p>
</p>html에서 tag의 정식 명칭은 사실 element임</p>
<p>쥰내 웃긴점 - html input 태그 type number로 입력받았을 때 이거 숫자형 데이터로 입력받는 줄 알았는데 그런거 상관 없고 입력값은 무조건 문자형 데이터로 받는다는걸 알게됨 ㅋㅋ</p>
<p>변수 선언시 타입 안쓰면 무조건 var로 선언됨</p>
<p>html문서 만들 떄 html말고 ! + enter쓰기 이게 더 빠름</p>
<p>코드를 짤 때는 세 단계로 나눠서 짜는게 좋다. 입력 - 처리 - 출력 으로 코드를 나눠놓으면 코드 유지보수에도 좋다. 같은 맥락으로 무조건 짧은 코드가 좋은게 아닐 수도 있다. 내가 코드를 쓰는 상황에 따라 알맞은 형태의 코드를 짜는 능력을 가져야한다.</p>
<p>1 버튼 = 1 함수 = 1기능</p>
<p>브라우저가 주소를 요청하는 방법 4가지 = a태그, 주소넣고 엔터, location.href = '주소' 입력</p>
<p>나는 병신이다 제에에에발 자동완성 좀 잘 쓰자</p>
<p>오늘은 카카오 개발자 사이트를 견학해따. 가서 맵 API 들어가서 무료로 샘플도 보고 갖다 써 보았따. 참 재미있었따.</p>
<p>구글 맵에서 위도 경도 알아내기 = 원하는 위치 검색 - 주소창 !3d경도!4d위도!에서 경도 위도만 추출, 카카오 api 맵 샘플에서 위치 찍어보기</p>
<p>결국에 구글맵 보고 로드뷰 보고 그런 것도 브라우저에 표시되는거라 자바 스크립트로 동작되는 거였다.</p>
<p>구글 차트 - 구글에서 자바스크립트로 예쁜 표를 제공해줌, CDN으로 자바 스크립트를 제공하고 스크립트를 하나 더 열어서 표 같은걸 작성해놨기 때문에 긁어올 때 두번째 스크립트부터 긁어왔음</p>
<p>함수 = 기능 처리를 하는 단위</p>
<p>javascript는 구글차트나 카카오api가보면 여전히 오래된 문법을 쓰고 있지만, 실무에선 자바 스크립트와 jQuery 둘 다 쓰게 될 것이다.</p>
<p>국립공원 관련 사이트 같은걸 쓰려면 당연히 공공DB에서 데이터를 받아와야하는데 이때 공공DB는 oracle로 서버를 관리하고 있고 나는 jQuery를 이용해서 **이** 데이터를 받아오게 된다.</p>
<p>jQuery란 자주 쓰이는 자바 스크립트 코드를 완전 짧은 단축키로 바꿔놓은 것</p>
<p>ex, document.getElementBYid('result") === $('result')</p>
<p>$(function(){}) = jQuery할 땐 넣어줘야한다네요 왠지는 모름 ㅋ</p>
<p>jQuery 쓰기 전에는 입력값에 id부여하고 버튼에 함수 부여하고 왔다갔다 난리쳐야했는데 이젠 안그래도 됨.</p>
<p>jQuery, $('body') => 모든 body 태그에 접근 / $('.body') 클래스 body에 접근 / $('#body') id body에 접근</p>
<p>나는 spring framework로 해야징, boot로 하면 시간 오래 들여야한다고 해용</p>
<p>와 진짜 이런거까지 고민해서 포폴을 만들었구나 라는 인상을 주는게 중요하다</p>
<p>전부 내 기준으로 질문하고 설명해달라고 하기</p>
<p>강사님 잘 만난 듯</p>
<p>jQuery.com 에 들어가면 jQuery 다운도 받을 수 있고 링크도 받을 수 있따</p>
<p>내가 다룰 수도 있긴 하지만 엄밀히 말하면 jQuery도 web front측 기술이라고 말할 수 있겠다.</p>
<p>jQuery는 자바스크립트를 편하게 쓸 수 있도록 도와주는 오픈소스 기반 자바스크립트 라이브러리</p>
<p>쉣 자바는 ''아니라 ""써야되나 봄 조땜</p>
<p>수업내용 슬랙에서 찾기 힘드니까 카페에서 찾기</p>
<p>카카오 Oven - HTML5 기반의 무료 웹/앱 프로토타이핑 툴 => 사이트 만들기 전에 미리 한번 만들어보는 툴</p>
<p></p>
</details>
<details>
<summary>.innerHTML을 쓰는 방법</summary>
<p></p>
</details>

## [9월 18일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>JRE = Java Run Environment, 얘가 있어야 자바로 만든 프로그램을 다른 환경에서 실행할 수 있음</p>
<p>기존의 C++ 언어는 환경이 달라지면 코드를 새로 짜야 했는데 JAVA는 JRE라는 인공환경만 세팅해주면 다른 환경에서도 코드를 새로 수정하지 않고도 자바 프로그램 실행 가능</p>
<p>왜 jdk만 환경변수를 따로 설정해주었을까? - eclipse등 프로그램은 JRE를 자동을 알아서 깜</p>
<p>IDE =Integrated Development Environment, 통합 개발환경</p>
<p>VSCODE(범용), eclipse(자바), inteliJ(자바) = IDE</p>
<p>pycharm = pyton</p>
<p>visual studio = c, c++, c#</p>
<p>PHP는 최근 들어서 안 씀, 객체 지향식인데 존나 느림</p>
<p>JDK에는 JAVA개발에 필요한 함수나 객체나 메소드 4500여개가 있다. 부족한 부분은 이클립스에서 플러그인 방식을 통해 실행할예정</p>
<p>static = 망치, class = 틀, interface = 필요한 기능 정의 => static이라는 망치를 하나 만들어서 필요할 때마다 꺼내 쓰고, class라는 주조 틀을 사용해서 부품 양산</p>
<p>수식을 계산하고, IDE를 통해 결과를 도출하는 것 모두 CPU가 해야할 일이고, static, class등의 도구는 전부 RAM에 있어야 CPU가 가져다 쓸 수 있다.</p>
<p>SUN Microsystems inc에서 만든 JDK, 이후 oracle에 인수됨</p>
<p>JDK SE, SE = standard edition (4500개)</p>
<p>JDK EE, SE + enterprise(기업용 버전) = EE, eclipse도 EE버전이 있다. 내가 깐 것도 EE버전</p>
<p>JDK는 여러 객체를 가진 라이브러리, 여러 분류를 가짐, SE, EE 등</p>
<p>JDK 11이후 oracle JDK가 유료로 버뀌면서 소송전쟁, openJDK라는 오픈소스 제공됨, 근데 oracle openJDK가 존재함 ㅋㅋ 물론 기능 제한되어있음</p>
<p>자바 파일 - 컴파일 - bytecode(컴퓨터가 이해할 수 있는 코드)를 담은 자바 class파일 생성 - JVM(Java Virtual Machine) + 각종 api을 포함하는 JRE가 깔려 있는 환경에서 자바 파일 실행</p>
<p>JDK는 </p>
<p>자바는 C++에서 파생, 현재는 pyton이 굉장히 거대해졌지만 복잡한 프로그램이나 웹 서버 등을 다루려면 JAVA로 다루는 것이 더 합리적이다. 그래서 현재 서버를 다루지 않는 pyton이외의 프로그래밍 언어 사용자는 파이썬으로 넘어갈지, JAVA를 배울지 고민 중이라고 함</p>
<p>자바 툴로는 eclipse, netbeans, inteliJ 등이 있는데 netbeans는 오류가 많이 발생</p>
<p>자바 툴 환경 설정 등 ppt따라서 진행해보기</p>
<p>workspace - refeusing 뭐시기,u utf-8 인코딩 방식 설정 등</p>
<p>java - compfiler 수준 1.8로 맞추기</p>
<p>appearance - dark로 하면 어둠의 다크 테마로 바꾸기 가능</p>
<p>general appearance = colors and fonts 에서 클자 폰트 바꾸기 가능</p>
<p>help - eclipse marketplace에서 vscode와 같이 플러그인 찾기 가능</p>
<p>플러그인 중에 Darkest이거는 시력 보호에 좋다 꼭 받자</p>
<p>ctrl + n = (프로젝트(패키지(클래스))) 요거 세개 다 만들기</p>
<p>갓 만든 자바 프로젝트 JRE system libary의 jar 파일 = java archive</p>
<p>src에서 ctrl + n 으로 패키지 폴더 만들기, 패키지 폴더에서 ctrl + n으로 cls 만들기, 이쯤이면 ctrl + n은 기억해야겠지?</p>
<p>이클립스 자바 프로젝트에서 폴더 지울 때 체크박스 체크 안하면 지울 폴더를 프로젝트에서만 지우기 가능. 왠지 폴더는 남겨놔야 할 것 같을 때 사용 가능</p>
<p>클래스는 무조건 대문자로 작성, 그래야 실무 등에서 구분 가능함</p>
<p>public static void main => 독립적으로 실행 가능</p>
<p>
`package test;  // 이건 package test에 있는거야

public class Hi {

	public static void main(String[] args) {
		// class는 main이라는 함수가 있어야
		// 독립적으로 실행되는 부품이 된다.
        // JOptionPane.showInputDialog;("당신의 이름을 입력해 주세요.");
        // 망치.망치질

	} // 이건 class Hi에 해당하는 부분이야 

}`
</p>
<p>main + ctrl + space bar, syso + ctrl + space bar = 자동완성 기능</p>
<p>ctrl + d = 한 줄 삭제</p>
<p>ctrl + f11 = 실행</p>
<p>자바는 변수 선언을 할 때도 숫자형을 저장할지, 문자형을 저장할지 지정하고 선언해야 함. int 변수 = 0 으로 선언된 변수는 무조건 정수만 들어갈 수 있다.</p>
<p>논리형은 boolean, 문자형은 string 등 타입이 안변하니까 정적 타이핑</p>
<p>char = 문자 한 개, double = 소수점, boolean = true,false</p>
<p>char는 문자 1개만 ''로 선언, S(대문자)tring 은 문자 여러개를 ""로 선언</p>
<p>원래 기본형은 int(정수) dobuble(실수) char(문자) boolean(논리) 인데, String(문자열)은 하도 많이 써서 기본형처럼 쓸 수 있게 만들어놓음</p>
<p>String이 기본형이 아닌 이유 = 다른 기본형 데이터는 한번에 하나의 저장소만 사용하는데 Stringdms 홍길동 => char ='홍' + cahr '길' + char '동' 으로 저장소 3개를 사용하는 모습을 보여주기 때문</p>
<p>반드시 ; 붙여주고 무조건 데이터 형태를 지정하고 변수를 선언해야 하는 등 쥰내게 까다로운 친구지만 그만큼 복잡한 프로그램이나 웹 등에서 강한 면모를 보이는 친구이다</p>
<p>그렇기 때문에 코딩을 쉽게하고 싶으면 pyton을 사용하고, 복잡한 프로그램을 만들거나 디버깅을 용이하게 하고 싶으면 JAVA를 사용하는 것이 좋다.</p>
<p>C++이 오래 쌓이고 객체지향언어라 좋기는 한데 존나 어려움. C++의 장점을 가져오면서 조금 더 쉽게 만든 것이 JAVA. 아직까지는 JAVA만큼 좋은 언어가 나오지는 않은 것 같다는 평기</p>
<p>JAVA가 이렇게나 좋은 언어고 안정성도 높은데 왜 브라우저에서는 JavaScript를 사용하는가? => 지금 쓰는 브라우저가 자바 스크립트밖에 해석 못함.</p>
<p>그럼 왜 하필 크롬에서 주로 개발하는가? => 브라우저 엔진 중 유독 크롬 엔진이 자바 스크립트를 구동시키는 속도가 빠름. 왜 빠른지는 모름</p>
<p>대충 치다가 ctrl + shift + f = 자동으로 들여쓰기 해줌</p>
<p>jop.showin = 이름 입력하는 프롬프트 띄우기</p>
<p>jop + .showme = (null, 입력값) 입력값 띄우기, null은 아직 뭔지 모름</p>
<p>입력값이 문자열인건 JAVA에서도 변하지 않음</p>
<p>아 null이 쓰레기값이 아니었구나, 변수 = null은 쓰레기값 조차 정리해주는 인위적인 아무것도 없음 값을 지정해주는 거였어 ㄷㄷ</p>
<p>Integer.parseInt(냥) = 냥을 정수값으로 바꾸기</p>
<p>Double.parseDouble(냥) = 냥을 실수값으로 바꾸기</p>
<p>System.out.printf("%.2f", 냥); = 냥값 2번째 소수점까지만 자르기</p>
<p>모든 클래스도 대문자로 시작</p>
</details>
<details>
<summary>오늘의 문뎨</summary>
<details>
<summary>기본 데이터형 4가지의 각각 사용하는 키워드</summary>
<p>정수(int)</p>
<p>실수(double) - 어 실수형은 double도 있는데? - 사실 둘다 맞는데, float은 작은 실수형, double은 float의 두배에 달하는 실수를 포함 가능</p>
<p>문자(char)</p>
<p>논리(boolean)</p>
</details>
<details>
<summary>기본 데이터형의 키워드는 아니지만 일부 기능을 기본형처럼 사용할 수 있는 문자열을 나타내는 타임</summary>
<p>String</p>
</details>
<details>
<summary>자동완성하는 단축키는?</summary>
<p>ctrl + space bar</p>
</details>
<details>
<summary>프로젝트, 패키지, 클래스의 대소관계를 나타내시오</summary>
<p>프로젝트 > 패키지 > 클래스(파일명.JAVA)</p>
</details>
<details>
<summary>System.out.println("나야 나")에서 System은? out은?</summary>
<p>System = 컴퓨터, out = 모니터</p>
</details>
<details>
<summary>모든 입력하는 데이터의 타입은 무엇인가?</summary>
<p>문자열</p>
</details>
<details>
<summary>문자열을 정수로 변경하고자 한다. 어떤 클래스의 어떤 명령어를 사용해야 하는가?</summary>
<p>Integer.parseInt()</p>
</details>
<details>
<summary>문자열을 실수로 변경하고자 한다. 어떤 클래스의 어떤 명령여를 사용해야 하는가?</summary>
<p>Double.parseDouble()</p>
</details>
<details>
<summary>서버가 실행될 때 필요한 프로그램인 JVM와 필요한 부품들의 모음인 라이브러리를 합해 부르는 말은?</summary>
<p>Java Run Envrionment</p>
</details>
</details>

## [9월 19일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>`import javax.swing.JOptionPane;` 이게 뭐징</p>
<p>혼자 실행하려면 main안에 들어있어야 한다. 아직은 main 안에만 작성하기. 클래스 지정 없이 실행한다는 얘기인가?</p>
<p>x++ = 단항 연산자, a = 1 + 1 등 = 이항 연산자, 응애 ? 냥 : 멍 = 삼항연산자</p>
<p>논리 연산자 쓸 때 논리 값이 나오도록 써야함. 보통 >< 쓸 때 이상 이하 제대로 구분 안하면 조땜</p>
<p>int a = 10 동작순서 int a => a = 10 순서로 발동, 뭔가 당연한 것 같지만, 코딩이 복잡해지면 헷갈릴 수 있음.</p>
<p>그럼 문자열이 연산에 포함되면, 왼쪽부터 연산 시작하기 떄문에 문자가 중간에 끼어있는지 잘 판단하고 연산시켜야 함</p>
<p>결합의 경우 알아서 연산이 되지만 빼기 연산자인 경우 문자 - 숫자가 되버리기 때문에 오류가 남</p>
<p>위 이유들 때문에 연산할 때 먼저 해야할 연산이 있으면 괄호를 쳐서 먼저 연산할 수 있도록 하는 것이 권장된다.</p>
<p>자바 프로젝트 파일을 이클립스에서 쓰려면 이클립스 워크 스페이스에서 연 다음, package explore 우클릭 - import - general - exsisting projects into workspace에서 내 eclipse workspace 지정 후 java basic 폴더 가져오기</p>
<p>프로젝트를 만들면 바로 그 안에 압축된 4500개의 객체가 들어가 있는 JRE system library가 나타남</p>
<p>운영체제는 폴더, 언어에서는 패키지 그래서 언어에서 `패키지.패키지속` 이렇게 작성하면 운영체제로 봤을 때 패키지 안에 패키지속 폴더가 생겨있다.</p>
<p>이클립스 파일에 alt + enter 열면 폴더 위치 열기 가능</p>
<p>연산자로 무언가 연산할 때, ram에서 복사해 온 후 cpu에서 계산, 그다음 값 할당</p>
<p>자바도 항상 입력 - 처리 - 출력을 생각하기 나눠서도 생각하고 그래보기</p>
<p>자바 연산 시 정수와 정수의 연산은 무조건 정수로 출력한다.</p>
<p>자바 연산 시 하나라도 실수이면 무조건 실수 - 실수를 살리고 싶으면 이 특성을 사용하여 살려야 한다.</p>
<p>`double avg2 = sum / 2.0;` - 요런 식으로</p>
<p>만약 2.0 이 아니라 2로 표기하면 정수 / 정수로 계산해서 소수점 다 떼버리고 난 후인 4를 소수점인 4.0으로 표기해버림</p>
<p>(double)sum 이렇게 소괄호로 변수를 감싸는 문법 = 강제 타입변환 = 강제 형변환 = casting 캐스팅, 이런 캐스팅은 기본 데이터 타입만 해당됨.</p>
<p>ctrl + d = 한 줄 삭제</p>
<p>ctrl + 방향키 : 커서를 토큰(단어) 단위로 이동<br>
shift + 방향키 : 커서를 이동하면서 선택<br>
ctrl + shift + 방향키 : 커서를 토큰(단어) 단위로 이동하면서 선택<br>
(복붙, 잘라내기, 삭제할 때 등등 편합니다)<br>
F2 : 파일 이름 변경<br>
Ctrl + N : 새 파일/프로젝트 생성<br>
Ctrl + D : 한 줄 삭제<br>
Ctrl + Shift + F : 소스 정렬<br>
해당 프로젝트에서 Alt + Enter : Project 속성<br>
Ctrl + Space : 자동완성<br>
Ctrl + Alt + up/down : 한줄 복사<br>
Ctrl + F11 : 실행<br>
Alt + Shift + R : 변수 이름 변경<br>
Ctrl + / : 한줄 또는 선택영역 주석처리 / 제거<br>
Ctrl + Shift + / : 선택 영역 Block Comment 설정<br>
Ctrl + Shift + \ : 선택 영역 Block Comment 제거</p>
<p>기본형 데이터가 변수로 RAM에 공간을 만들면 기본형의 데이터가 저장되지만, 기본형이 아닌 데이터가 변수로 RAM에 공간을 만들면 주소를 저장한다.</p>
<p>그렇기 때문에 char을 여러개 써서 합쳐 놓는 String 데이터형은 기본형이 아닌 데이터이기 때문에 값이 아닌 주소를 저장한다.</p>
<p>기존값.equals("비교값") => 기본형이 아닌 데이터를 비교할 때</p>
<p>변수.charAt(0) => 변수 0번 자리의 문자값을 가져옴</p>
<p>char는 2byte 만 쓰는 반면, String은 최소 6byte르 씀</p>
<p>RAM에 저장된 변수는 class가 끝나면 사라짐</p>
<p>intelij가 이쁘고 더 쉬운데 왜 아직까지는 eclipse를 쓰나요?</p>
<p>intelij가 유료고 나중에 나왔기 때문에 아직 범용적으로 쓰려면 eclipse 쓰는게 좋음, 대학계정이 있으면 intelij 유료 버전을 사용ㅎㄹ 수 있다.</p>
<p>eclipse는 코드가 오픈되어있다. 심지어 우리나라 정부 버전 eclipse인 eGovFrame이라고 있다.</p>
<p>자바 새 파일 생성 창에서 각종 버튼에 알파벳에 하나씩 들어가 있는 밑줄 쳐진 알파벳 alt + 알파벳 하면 그 버튼 눌림</p>
<p>import javax.swing.JOptionPane; 이게 자동으로 생기는 이유 - 원래 JRE library에서 JOptionPane라는 부품은 javax 폴더 안의 swing안에 있었던 것임. JOptionPane라는 부품을 쓰려면 정석으로는 javax.swing.JOptionPane 이거를 다 입력해야 쓸 수 있는 거였는데 파일에서 class를 열기 전 import + javax.swing.JOptionPane를 입력해두면 이후 더 이상 JOptionPane를 쓸 때마다 경로를 지정하지 않아도 사용할 수 있게 해둠.</p>
<p>javax.swing.* 경로를 이렇게 지정하면 swing 폴더 밑의 모든 클래스를 지정하는 것</p>
<p>javax 까지만 지정하면 JOptionPane를 쓸 때마다 swing.JOptionPane를 써줘야 함</p>
<p>클래스나 프로젝트나 패키지는 java, javax로 이름지으면 안됨. JRE libarary에 이미 그 이름이 있음.</p>
<p>변수 선언 할 때 앞에 final만 붙여주면 상수로 선언할 수 있음, 상수는 무조건 대문자로 선언해야겠죠?</p>
<p>Stirng.format("%2.f", 변수)도 System.out.printf("%2.f", 변수)로 똑같이 이용할 수 있다.</p>
<p>클래스를 사용하는 방법<br>
1. 망치 - 자주 써서 RAM에서 언제든지 꺼내 쓸 수 있도록 하는 부품, RAM에 준비되어 있어야 함.<br>
2. 망치.기능이름() ===> 클래스.이름.함수()<br>
3. 벽돌 - 일반적인 부품 사용법, 필요할 때마다 만들어서 사용하는 부품. 벽돌 틀에 망치로 재료 집어넣음</p>
<p>new + ctrl + space bar 화살표 누르고 엔터 + JF + ctrl + space bar 화살표 누르고 엔터 해서  JFrame이라는 부품 만들기. 꼭 자동완성으로 만들어줘야 import가 생김.</p>
<p>	//JFrame f - 이거하고 f.쓰면 어떤거 쓸 수 있는지 단축키 보임, f.setSize - 요거는 띄우는 창 가로세로 크기 설정, f.setVisivle - 요거는 띄우는 창 보이게 하기(기존에 안보임), 이 명령어가 마지막이어야함. 중간에 넣으면 중간까지만 보임<br>
		//JButton b - b.setText => 버튼에 글자 넣어주는 기능<br>
		//JTextField t1<br>
		//JTextField t2<br>
		//JTextField t3<br>
    순서를 물 흐르듯이 배치하려면 new - flowlayout 해주고 f.setLayout에 변수 설정하면 설정 됨. 이렇게 얹는 것 조차도 부품이다.</p>
<p>ctrl + shift + o => import가 안되어 있을 때 모조리 import 해주는 단축키</p>
<p>JLabel = 글자 집어넣는 부품, 이 부품에 따로 setText로 글자도 써줘야 글자 집어넣을 수 있음</p>
<p>트러블 슈팅 = 오류 잡기? 이게 디버깅이랑 같은 말인가?</8p>
<p>저장공간을 어떻게 쓰느냐 - int double등으로는 쪼그만 프로젝트만 쓰는 걸 권장 싸이즈가 커지면 싸이즈가 큰 벽돌 틀을 써야함</p>
<p></p>
</details>

## [9월 20일](#top)
<details>
<summary >오늘배운 것</summary>
<p>우재남... 신입 직원 연수를 맡는다고 한다.</p>
<p>원래 깃허브 교재로 진행해야되는데 없어서 우리만 보여주는 자료로 진행한다고 함, 그 자료를 우리만 보는건 상관없는데 당연히 인터넷에 올리면 안되게쬬?</p>
<p>한 19년 이후~ '아 저 개발잔데 깃허브 안써요 ㅎㅎ' - 병신</p>
<p>깃허브에 뭐 할 줄 아는지 올려놓고 포폴하는 너낌</p>
<p>깃은 요리사에게 있어서 냉장고 사용법을 익히는 것과 같다.</p>
<p>우재남 강사가 생각하는 IT전문가의 역량 - 도메인 지식, 프로그래밍 실력, 4차산업기술(데이터,AI,클라우드)</p>
<p>빵 파는 가게가 웹 프로그래머를 뽑을 때, 1번 지원자 - 빵 모름, 프로그래밍 기가 막히게 잘함 / 2번 지원자 빵 전문가, 프로그래밍 조금 약함 - 이럴 때 빵 가게는 2번 지원자를 뽑음. 존나 관련 없는 전공을 가지고 있었지만 그걸 이용해서 취업을 하게 되는 경우</p>
<p>코딩 진입장벽이 높음 - 압정구조 - 초급은 많은데 중급 고급은 없음 - 제대로 존버만 한다면 2~5년 이내에 좋은 대우를 받을 수 있다.</p>
<p>깃 - 소스 코드를 컴퓨터에 보관하기 / 깃허브 - 소스 코드를 인터넷에 보관하기</p>
<p>https://cafe.naver.com/githubstudy</p>
<p>깃 - 버전 관리 도구, 텍스트 기반 원격 저장소 호스팅 서비스, 개발자들의 SNS, 자랑 통로</p>
<p>소스 트리 - 텍스트 기반인 깃은 GUI 기반으로 사용할 수 있도록 하는 프로그램</p>
<p>리누스 토르발즈 - 1991년 리눅스 커널(엔진) 제작, 2005년 깃 오픈 소스 제공=> 프로그래머의 성인, github가 아직까지도 무료인 이유는 경쟁자가 있기 때문</p>
<p>깃을 쓰는 이유 - 변경 내역 확인, 작업 되돌리기, 협력</p>
<p>코딩을 하다 보면 나도 모르게 변경 사항이 많음 그래서 깃이 필요함.</p>
<p>유의미한 코드 변화 - 버전 변화 / 응애코드변화 - 버전변화라고 안부름</p>
<p>프로그램 개발 - 버전을 쌓아나가는 것</p>
<p>깃에 무료로 올린 오픈 소스를 돈 받고 팔아도 됨 ㅋㅋㅋ, 이래도 안잡혀간다고 하네용, 물론 도의적으로 욕은 먹겠죠</p>
<p>오픈소스의 최대 적 = Microsoft, 근데 2018년에 MS가 github를 인수함</p>
<p>MS는 현재 azure라는 클라우드 회사로 먹고 살음. 운영체제같은건 부가 사업, 착해져가지고 아직까지는 github를 무료로 운영중이긴 함. 심지어 기존 프로젝트 비공개하기는 유료였는데 그것도 무료로 바꿈.</p>
<p>코드 공개를 꺼리는 기업을 위해 Github Enterprise 패키지 제공</p>
<p>인텔의 32bit cpu가 기존에  86xxx 86xxxx 86xxxx 등으로 불려서 그거에 해당하는 폴더를 x86이라고 만들었는데 나중에 64bit가 나오게 된 이후 해당하는 폴더를 만들려고 보니까 32bit를 왜 86이라고 지었는지 일관성이 없게 됨. 그래서 32bit cpu를  x86라는 폴더를 쓰게 하고 64bit는 그냥 x64라는 폴더를 쓰게 됨. 그래서 일관성 없게 x86, x64 폴더를 쓰는 거임</p>
<p>깃 폴더 보고 쥰내 설치하기</p>
<p>폴더 안의 .git 폴더가 있다 - 깃이 관리하는 폴더라는 의미, .git건드리지 않기</p>
<p>깃 저장공간 3가지 - 작업 디렉토리, 스테이지, 저장소</p>
<p>작업 디렉토리 - 코딩한 파일이 들어가는 폴더, 자바의 경우는 프로젝트를 집어넣어놓아야겠지?</p>
<p>스테이지 = 임시 무대</p>
<p>저장소 - 버전이 확정되고 관리되는 공간</p>
<p>add - 작업 디렉토리의 내용을 스테이지에 올리는 것</p>
<p>commit - 스테이지의 내용을 저장소에 올리는 것</p>
<p>하나의 버전이 만들어지는 과정<br>
1. 자바 프로젝트 제작<br>
2. add<br>
3. commit<br>
4. 버전 완성 !!</p>
<p>퇴근 할 때 이거까지 하고 퇴근을 해야겠지?</p>
<p>소스 코드 마지막에는 빈 줄이 하나 있는 걸 권장함</p>
<p>커밋 해시 = 커밋한 버전의 고유한 ID, 절대 중복 안됨 존나 긴 16진수, 앞 7글자만 끊어 읽었을 때 적어도 내 컴퓨터 안에서는 중복 안됨</p>
<p>마우스는 표시된 버전을 클릭하면 되는데 리눅스 같은 명령어 모드에서는 이 id가 있어야 해당 버전을 찾아갈 수 있다.</p>
<p>커밋 태그 = 특정 커밋에 꼬리표를 달음, 보통 중요한 커밋에 달고 버전 이름을 붙임(ex, v0.0.1 등)</p>
<p>파이썬이 데이터와 인공지능으로 가장 적합한 언어다.</p>
<p>오픈소스(OpenSource) = 앱 무료 + 소스코드까지 공개 - 그냥 완전 무료</p>
<p>프리웨어(Freeware) = 앱 무료, 소스코드는 안 줌</p>
<p>쉐어웨어(Shareware) = 일정 기간동안 무료(보통 7~30일)</p>
<p>pyton에서 idle에서 new fiel 로 .py파일 만들고 그걸로 run moduel하면 idle에 결과 표출됨</p>
<p>깃은 우리가 어떤 짓을 하든 관심 없고 단지 파일 내의 변경사항만 관심이 있다.</p>
<p>취업할 때 깃허브를 제출하는 만큼 깃허브에 1일 1커밋 이상 하면 좋다. 당연히 강의 들으면서도 커밋 하면 좋겠지? 물론 취업 이후에 하는 커밋은 보통 기능하나를 완성할 때 커밋해야한다.</p>
<p>깃 커밋 이후 깃 저장소에서 ctrl 클릭으로 다중 지정을 하면 그 영역 내의 변경 사항을 다 알려줌</p>
<p>만들어진 방법을 되돌리는 두가지 방법 - revert, reset</p>
<p>revert = 1000 버전을 999버전으로 되돌리면 1001버전이 됨, 즉 1000버전을 살리고 과거의 999버전을 복사해서 1001버전으로 만드는 것</p>
<p>reset = 1000버전을 완전히 999버전으로 되돌리고 1000버전을 날려버리는 것</p>
<p>reset이 좀 불안하지? reset - soft, mixed, hard</p>
<p>soft reset - 해당 버전 커밋까지만 날리기</p>
<p>mixed reset - 스테이지까지만 날리기</p>
<p>hard reset - 코드까지 다 날리기</p>
<p>버전 여러개를 건너뛰면서 리셋 시키면 표적 버전 이후 버전은 싹 날아감. revert reset 때에 맞게 쓰기</p>
<p>듣기만 했을 때 나는 soft reset을 하고 싶었는데 soft reset을 하면 스테이지에 파일이 올라간 상태가 됨, 그래서 만약 버전 되돌리기를 한다면 기존 파일을 복사해 놓은 다음, 버전을 아예 하드 리셋을 해버리는 편이 리셋해놓고 작업하기는 편함</p>
<p>revert는 해당 커밋에 우클릭 + 커밋 되돌리기 => 초간단!</p>
<p>reset은 해당 커밋에 우클릭 + 이 커밋까지 초기화 = soft, mixed, hard 선택</p>
<p>이거 이렇게 바꾸면 내 파일 상태도 그에 맞춰서 바뀌니까 백업해둬야 할 파일을 백업해야겟다.</p>
<p>미니 특강에 리눅스 기초 명령어가 있음. 리눅수 만든 사람이 깃도 만듬. 많은 연관성이 있음.</p>
<p>취업에 도움될 자격증 - 권장 : 정보처리기사(운전면허증 너낌 법적으로 필요함, 나 컴맹 아니거든요 느낌 + 컴공과 4년의 요약), 전자계산기조직운용(전공자)</p>
<p>ADSP, SQLD, 빅데이터, OJCP, 리눅스 마스터, 인공지능 => 전부 다 좋은 자격증은 맞음, 근데 나한테 필요한 자격증인가? 자격증은 취업에 도움되기 위해 따는 것이기 때문에 취업 사이트 공고를 보고 들어가고 싶은 회사에 필요한 자격증을 고르는 것이 좋다.</p>
<p>리눅수 명령 기초 wsl</p>
<p>자격증 같은거 필기, 실기로 나뉘어진 경우 필기만 합격했더라도 필기 합격을 적어놓는 것이 좋다.</p>
<p>합격률 높은 자격증은 따지 않기, 프로그램의 배포 과정을 알아보기</p>
<p>Alpha, Canary(카나리아 - 경보기 역할 새) 알파 버전 = 프로그램 개발을 완료하고, 처음으로 release한 버전, 치명적인 버그 발생 가능</p>
<p>Beta베타 버전 = 본격 배포 전 알파 버전에서 개발자가 큰 버그를 잡아두고, 자잘한 버그가 발생 가능. 보통 게임이든 뭐든 베타 테스터를 이용해서 버그를 제보받고 수정하는 일을 함. 원래 베타 테스트같은거 돈 받고 해야되는데 게임같은거는 너무 하고 싶은 나머지 알아서 참여함 ㅋㅋ</p>
<p>Release Candidate(RC) 버전 = 버그를 거의 다 잡은 버전, 출시 직전</p>
<p>Preview 버전 = 그냥 출시 직전 거의 동일한 버전</p>
<p>정식 (RTM, GA, 1.0) = 정식 버전, 보통 이 버전으로 판매가 이루어짐</p>
<p>Community 버전 = 정식인데 무료인 버전</p>
<p>Patch 버전 = 정식 버전 이후 미처 발견하지 못한 버그 등을 수정하는 버전</p>
<p>Update 버전 = Patch의 묶음</p>
<p>Service Pack = Update의 묶음</p>
<p>위 단계는 유료 프로그램 배포 과정을 전부 나눠놓은거기는 한데, rc버전 없거나 하는 등 배포하는 회사의 성격마다 단계가 다름</p>
<p>오픈소스 버전 = 보통 0.0.2 => 0.8 => 1.0 순으로 개발, 욕은 1.0부터 먹음</p>
<p>stash = 현재 코딩 중인 버전을 싹 정리해서 이름 붙이고 임시 보관소에 보관, 상사가 변덕을 부릴 때 용이</p>
<p>stash를 다시 가져와서 적용하려면 stash되었던 그 상태 그대로 돌아가야함. 아니면 충돌 일어남.</p>
<p>그래서 stash를 쓰고 아무 작업도 안 하고 있을 수는 없으니까 필요한 파일을 stash로 따로 빼놓고 필요한 것만 빼서 쓰는 걸 권장함</p>
</details>

## [9월 21일](#top)
<details>
<summary >오늘 배운 것</summary>
<p>브랜치를 쓰는 이유 - 협업 때문에</p>
<p>쇼핑몰 코드<br>
1. 장바구니 브랜치<br>
2. 주문 목록 브랜치<br>
3. 두개 각각 따로 쓰고 합치기</p>
<p>소스 트리 보면 main브랜치라는 최초의 브랜치가 설정되어있음</p>
<p>브랜치 기능도 커밋 처럼 뭐 하는 건지 표시하면서 브랜치를 나누어야함</p>
<p>Head = 현재 작업 중인 커밋</p>
<p>Checkout = Head를 옮기는 것</p>
<p>보통은 Head 브랜치 중 마지막 커밋을 가리침</p>
<p>체크아웃 하면 해당 커밋의 파일만 보임</p>
<p>a에다 b 브랜치를 병합해도 b 브랜치는 따로 삭제하지 않는 한 계속 남아있음</p>
<p>그냥 병합은 일반병합<br>
a에서 b 브랜치를 생성하고 a브랜치에 아무 작업도 하지 않았다면, b브랜치를 다시 병합 시킬 때 fast-fowrad merge라는 것을 한다.</p>
<p>만약 같은 파일을 수정했다면, 브랜치 합치기 할 때 충돌이 발생한다. 충돌이 발생했을 때 해결법 - 충들을 해결한다(존나 어려움) - 다시 커밋한다</p>
<p>브랜치 병합 후 충돌 발생 시, 스테이지에 올라간 파일관 안올라간 파일이 있는데, 이 때 안올라간 파일에 우클릭 후 '내것으로 해결', '저장소 것으로 해결' 이 있는데 '내것으로 해결'을 고르면 head의 파일로 병합할 브랜치의 파일을 덮어씀, 이후 커밋란에 '마스터의 파일로 충돌 해결함' 등으로 표기해 주는게 좋음</p>
<p>그러니까 브랜치를 나눠도 같은 파일을 여럿이 코딩하지 말아야겠지?, 그런데 한 파일에 있는 코드에 여러 명이 붙어야 할 일이 있을 때는, JAVA에서는 물리적으로 파일을 분리한 다음, import명령어를 추가해서 파일 내용을 불러와야 한다.</p>
<p>위 이유들 때문에 회사에서 각자 일은 분배해주는 프로젝트 매니저의 역할이 굉장히 중요하다.</p>
<p>리눅스 연습하려면 git bash 열고 연습하면 됨</p>
<p>리눅스 설치법 = 1. pc에 직접 설치(윈도우 날려야함), 2. 가상머신 이용(시간 오래 걸림), 3. WSL(Window Subsystem Linux, 윈도우에 리눅스 터미널 추가)</p>
<p>git bash로 리눅스에서 쓰는 명령어 실시 가능, 윈도우 업데이트를 최신으로 유지해야 WSL을 이용할 수 있음. </p>
<p>깃허브 커밋은 조작이 불가능하니까 매일매일 해보기</p>
<p>깃허브 계정을 알려줄 때 /레포지토리 로 레포지토리까지 알려줄 수도 있음. 프로젝트 제출할 때 쓰면 좋겠지.</p>
<p>깃허브 - 레포지토리 - 이슈 - 에서 코드의 문제점 같은걸 제보하거나 제보받을수도 있음.</p>
<p>깃허브랑 소스트리를 연결할거라 깃허브에서 커밋을하는 과정이 소스트리와 상당히 비슷하다. 다만 스테이지가 없다는 차이점이 있다.</p>
<p>깃 허브 연동 방법 - HTTPS(계정과 암호), SSH(접속할 PC에서 인증키, 즉 PC인증방식)</p>
<p>OAuth 새로고침 후 비밀번호 입력 인증 후 연동</p>
<p>아 깃에서 클론하면 레포지토리를 그대로 가져오는 거라 새로 생성이 안된다는 그런거구만 그래서 소스트리에서 빈 폴더에 리포지토릐를 생성하는 것처럼 깃도 이미 만든 레포지토리라면 빈 폴더에 클론해야 오류 없이 레포지토리 연동이 완료되는 것이었던 것이었던 것임</p>
<p>원격 저장소와의 4가지 상호작용 - 클론, 푸시, 패치(fetch), 풀</p>
<p>클론 = 레포지토리 복사해오기</p>
<p>푸시 = 로컬 저장소에서 커밋 이후 원격 저장소로 커밋 내용을 보내서 연동하기(권장 - 커밋하면 바로 푸쉬하기)</p>
<p>풀 = 공동 작업 중 원격 저장소에서 커밋 내용을 가져와서 연동하기</p>
<p>패치(잘 안씀) = 검증되지 않은 코드를 풀 직전까지 가져오는 것. 보통 프로젝트 매니저가 코드 검증하려고 씀, 당연히 못 믿는 코드니까 패치는 잘 안씀</p>
<p>브랜치명 main, oring/main은 완전히 같은 브랜치, 여기서 origin이 github를 뜻하는 것임</p>
<p>컴퓨터 로컬 저장소에서 커밋을 하면 main브랜치 혼자 한개 올라가면서 커밋을 나타냄. 이 때 push까지 해줘야 main/origin 브랜치가 따라 올라가면서 깃허브도 연동 됨</p>
<p>남의 저장소는 레포지토리 code를 clone해와서 소스트리에서 받기</p>
<p>남의 레포지토리를 수정해서 푸시를 누르면 남의 레포지토리로 가게 됨. 물론 남의 코드를 마구 수정할 수 없어서 권한 없음으로 오류가 뜨게 됨. 그렇기 때문에 남의 코드를 가져올 때는 레포지토리도 좋지만 일부 좋은 코드만 떼와서 내 레포지토리에 넣고 수정하든지 그렇게 해서 관리해야 할 듯</p>
<p>남의 코드를 가져와서 공부하는 것도 방법이 좋겠다.</p>
<p>만약 취업 후 첫 pc를 배정받고 새 프로젝트를 시작한다. 깃/깃허브를 모두 세팅하고 시작하자.<br>
새 PC 배정 후 1회<br>
1. 개발 환경 세팅 : Java, Eclipse<br>
2. 깃 설치, 소스트리 설치, 깃 허브 가입(회사계정의 경우)<br>
3. 깃과 소소트리의 연결<br>
프로젝트 마다 1회<br>
1. 깃허브에 저장소 생성 + 더미 파일 생성<br>
2. 깃허브 레포지토리와 소트트리를 클론<br>
3. 연동 확인하기<br>
매일 작업학(반복)<br>
1. 코딩하기 (변경 사항 생성)<br>
2. 퇴근 전에 커밋하기<br>
3. PC의 커밋을 깃허브에 푸시하기<br></p>
<p>개발자로서의 스스로를 제한하지 말자. 현재 자바와 네트워크를 통해 웹 개발자로서 시작할 수 있겠지만, 언젠가 자바가 아닌 다른 언어를 이용할 수도 있고, 웹 개발자가 아닌 다른 개발자로서 커리어를 쌓아나갈 수도 있다.</p>
<p>중요 2, 기존에 깃으로 진행하던 프로젝트가 이미 있다. 지금부터 깃허브에 백업하기<br>
깃허브 백업 결정하고 1회<br>
1. 깃허브 가입<br>
2. 깃허브와 소스트리의 연동<br>
프로젝트마드 1회<br>
1. 깃허브에 빈 저장소 생성 + 더미파일 안만들기 ==> 이 저장소 https 경로를 복사 ==> 이거를 해야 깃허브에 생긴 빈 저장소를 프로젝트 레포지토리와 연동시킬 수 있음.<br>
2. 소스트리에서 기존 자바 프로젝트에 깃허브 경로를 추가(깃 클론하면 안된당 큰일난당 덮어씌워진당)<br>
3. 클론은 빈 폴더에 깃 레포지토리를 복사할 때만 쓰는거야<br>
4. 소스트리에서 연동시키고픈 프로젝트를 열고 복사한 http경로를 설정 속 원격에 경로지정, 원격 이름은 origin, 깃허브가 원격 저장소일때는 무조건 origin.</p>
<p>지금 깃을 인터넷이랑 소스트리로 다루고 있는데  깃 특강 강사가 기업체에 가면 깃 명령어 모드 조작을 가르친다고 함 즉 이 명령어를 알아야 리눅스 환경에서 개발할 때 깃허브를 다룰 수 있다고 말하는 것 같다. pdf 파일에 있으니까 반복 숙달하자.</p>
<p>깃허브 레포지토리랑 깃로컬 레포지토리는 그냥 분리되어있는거임. 단지 연결시켜 놓았을 뿐. push나 pull을 하지 않는 한 로컬 레포지토리르 삭제한다고 깃허브 레포지토리에 영향이 가는것은 아니고 그 반대의 경우도 마찬가지이다.</p>
<p>리눅스 명령어</p>
<p>cd - change directory</p>
<p>vi 파일명 = 명령 모드 => i입력(insert) 후 작성 가능 => esq => 쉬프트 + 콜론 + w + q = :wq 입력후 엔터로 명령 모드로 작성한 내용 저장</p>
<p>소스트리가 이런 명령어를 던지고 다시 긁어와서 편하게 보여주는거</p>
<p>명령어로 다룰 수 있기는 한데 이거 권장하지는 않는다고 함 소스트리를 추천하시네용</p>
<p>Dgony 레포지토리는 스페셜 레포지토리로 나를 소개하는 readme.md 파일이 맨 앞에 나타난다. 그거 수정해서 나만의 SNS 꾸미기, 확장자 이용해서 이쁘게 꾸밀 수 있음, 일단 처음은 강의 받은 카페에서 태그 가져와서 꾸미기</p>
<p>결국 내 깃허브를 보게 되는 사람이 개발 쪽에 지식이 있는 일반인인 인사담당자이기 때문에 각각의 레포지토리에 README.md 파일을 배치해서 어떤 레포지토리인지 설명하는게 중요함, 주요 프로젝트를 소개하는 권장 (개인 + 팀) 둘다 소개하는 걸 권장함</p>
<p>README.md 파일에 이미지 추가하라면 해당 레포지토리에 이미지 폴더를 만들어두고(이 때 빈폴더가 안만들어져서 그냥 dummy파일 하나 집어넣기) html의 img src 문법을 이용해서 집어넣어야함</p>
<p>5288893@hanafos.com git 특강 강사 이메일</p>
</details>

## [9월 22일](#top)
<details>
<summary >오늘 배운 것또</summary>
<p>반드시 외웓두어야 하는 것 - 기본형 데이터 형태 기억하기</p>
<p>9:20
==> String name = “홍길동“; 이거이 String 형태의 간이 표기형<br>
==> String s = new String(“홍길동“); 이거이 String 데이터형의 정석 표기</p>
<p>램에 변수로 자리를 할당할 때 boolean의 true false값을 제외하면 기본형데이터라도 단 한자리만 차지하지는 않는다.</p>
<p>이렇게 boolean 값이 차지하는 한자리를 bit라고 부르고, 보통 기본형 데이에 할당하는 공간을 8bit = 1byte 로 할당한다. 이때 숫자형이 1byte의 공간을 할당받으면 -127 ~ 127 까지 사용할 수 있게 된다.</p>
<p>이 때 boolean은 한자리밖에 차지하지 않지만 다른 데이터형와 같이 1byte에 해당하는 공간을 할당받는다.</p>
<p>즉 기본형 데이터는 기본 1byte의 공간을 할당받는데, 숫자형 데이터의 경우 21억까지의 수를 표현하기위해 8byte까지 할당받을 수도 있다.</p>
<p>이런 기본형 데이터 타입도 크기에 따라 다르게 변수 선언을 해야 된다. 그 이유로는<br>
1. 큰 대이터에 작은 변수공간을 선언하면 당연히 들어가지 않는다.<br>
2. 작은 데이터에 큰 변수공간을 선언하면 줄일 수 있는 메모리를 굳이 크게 할당하게 된다. 그래서 적절한 변수형을 선언하는 것이 중요하다.</p>
<p>뭐 하나 만들겠다 - 프로젝트</p>
<p>폴더를 구분하겠다 - . 단위로 폴더구분, 패키지</p>
<p>기능을 실현하겠다 - class</p>
<p>정수<br>
byte = +-127, 1byte<br>
short = +-3만, 2byte<br>
int = +-21억, 4byte<br>
long = 21억 이상 + L(안쓰면 오류남), 8byte, 숫자형은 기본적으로 int 이하까지 이해하고 있어서 long의 경우 숫자 마지막에 L을 붙여줘야 long으로 해석할 수 있다.</p>
<p>실수<br>
double = 8byte, 0.00000000... 까지 계속 감<br>
float = 4byte, 0.0000 + F 만 붙여주면 그 자리에서 끊음, 작은걸 쓰려면 float</p>
<p>코딩테스트 같은 걸 볼 때 잘 작동하는 쉽고 좋은 코드라고 해도 램을 많이 차지한다면 오히려 탈락할 수도 있다.</p>
<p>만약 작은 타입에 들어갈 수 있는 값이 큰 타입에 들어가 있다면, 강제 형변환(casting)을 통해 작은 변수선언을 붙여서 작은 타입에 들어갈 수 있다.</p>
<p>형번환 할 때 위의 경우는 실수나 정수끼리 같은 기본형의 형변환이라 가능했던거고, String은 결국 참조형이라 기본형과 참조형은 형변환을 할 수 없다.</p>
<p>String이 한글자라 형변환으로 char로 만드려 했는데 안됐음 ㅋㅋ, 대신 charAt(0)으로 가져와서 char변수에 집어넣는 것은 가능하다.</p>
<p>캐스팅을 쓰는 건 아마 계산하면서 값이 줄어드는 경우에 사용할 수 있겠지? 이런 캐스팅 같은 것을 하나씩 가져다가 나만의 프로그래밍 원칙을 하나씩 세워봐야겠다.</p>
<p>JOprionPane 은 alert창을 하나씩 띄우는데 여러번 띄우는게 불편하나면? 일단 지금은 콘솔창으로 입력하는 입력값을 가져오는 코드 작성 가능. 근데 실무는 콘솔이 아니라 고객이 쓰는걸 가정하기 때문에 지금 우리가 콘솔로 입력하는거는 연습할때만 ^오^</p>
<p>new로 scanner 객체를 가져와서 sc변수에 할당, Scanner(System.in)으로 콘솔에서 값 가져오기, 코딩테스트 용에서만 쓰고 실무에서 안쓰는거 꼭 기억하기</p>
<p>sc.next(); => String으로 입력한 값을 가쟈온다.</p>
<p>sc.nextInt(); => String을 int로 변경해주는 것</p>
<p>sc.nextDouble(); => String을 실수로 변경해주는 것</p>
<p>항상 빨간 밑줄이 생기면 거기에 마우스로 클릭 후 해결 방법이 나오니까 그거 꼭 해보기</p>
<p>까먹은 사실 System.out.println 에서 ln은 그냥 줄바꿈이라 빼도 결과 출력되는 거였음. 당연한건데 내가 생각을 못하고 있었음.</p>
<p>sc.nextline = 엔터를 인식함, 그래서 입력하려면 sc.nextline();을 하나 더 미리 만들어놔서 입력값을 공중분해 시켜놓아야함 대신 그냥 sc.next 쓰는데 교재에서 난리치길래 강사님이 가르쳐준다고 하심</p>
<p>if (name == "자바") => 이게 틀린 이유, 기본형 데이터가 아니라 String임. name.equals("자바")로 비교해야 비교할 수 있음.</p>
<p>if문은 break가 있고, switch문은 break가 없다. 상황에 맞게 나눠 쓰기</p>
<p>switch문의 경우, case비교 => 조건이 맞음 => 결과출력 => 이후 case 비교 없이 결과만 출력 => 그래서 case가 일치한 후 break가 없으면 이후 결과가 전부 출력됨.</p>
<p>switch<br>
long안됨, 정수만 가능(실수 불가능)<br>
char, String 사용 가능<br>
case "": case"": case"": 로 여러 조건을 붙일 수 있다. => 이렇게 써야하는 경우는 if문보다 switch문에 더 효과적이다.</p>
<p>date도 가져와야 하는 객체, date.geHours();, date.getSeconds();. 의 매소드 형식으로 시간 정보를 가져올 수 있다.</p>
<p>date.getYear(); 의 경우 밀레니엄 버그 문제 때문에 항상 + 1900을 해줘야 정상 년도를 나타내준다.</p>
<p>date.getDate(); => 요일 불러오기, 결과 0~6, 0이 일요일. 개발자의 날짜는 일월화수목금토일</p>
<p>메소드 여러가지를 사용하던 중 가로줄 그어진 메소드를 보면 deprecated라고 써 있는데 더 좋은 버전이 나와서 안쓴다는 이야기. 곧 사라질 가능성이 높음</p>
<p>자바 기능을 만들어보고 싶으면 그냥 구글에 '자바 타이머', '자바 사운드' 등 검색해보면 만드는 방법 알 수 있으니까 해보기</p>
<p>와 if나 switch문에 true 집어넣고 무한반복문 만든 다음 date.getMinutes() 등의 메소드로 일정 시간이 될 때까지 계속 반복시키는 방법을 할 수도 있음.</p>
<p>이런 무한루프는 서버를 유지하거나 게임 등을 할 때 사용함</p>
<p>if문은 break를 이미 가지고 있기 때문에 break를 if문 안에 써도 밖의 while문을 찾아가게 됨. 근데 반복을 끝낸다는 의미인지 괄호를 찾아서 밖으로 나간다는 의미인지 모르겠음. => 아 이거 그냥 break가 자체 break를 보유한 if문은 건너뛰고 break 문을 포함하고 있는 괄호를 찾아간다고 생각하면 이해할 수 있다.</p>
<p>break; => 괄호 탈출 후 프로그램 진행</p>
<p>System.exit(0); => 조건문 or 반목문 안에서 프로그램 완전 종료</p>
<p>블럭 지정 + alt shift z = 특정 조건문으로 둘러싸기</p>
<p>
숫자 맞추기 미니게임 한번 읽어보고 무한루프와 System.exit(0);을 어떻게 사용하는지 기억하기<br>
			while (true) {<br>
			String data = JOptionPane.showInputDialog("숫자를 입력해주세요.");<br>
			// 데이터 타입이 동일해야 비교 가능하다.<br>
			int data2 = Integer.parseInt(data);<br>
			if (target == data2) {<br>
				System.out.println("정답입니다!");<br>
				System.out.println("게임을 종료합니다.");<br>
				System.exit(0);<br>
			} else {<br>
				System.out.println("정답이 아닙니다!");<br>
			} <br>
		}
</p>
<p>r.nextInt(); => new로 random 가져오고, +- 21억 무작위 숫자를 가져오는 메소드</p>
<p>Random r = new Random(10); => 가져온 random에서 10이 들어간 위치를 시드값이라고 하는데, 서로 다른 클라이언트가 구동하는 프로그램의 시드값이 같으면 같은 형태의 랜덤값이 나오게 된다.</p>
<p>이 때 ()에서 0부터 지정한 숫자보다 하나 적게 설정 가능. 100을 입력하면 0~99까지 랜덤출력</p>
<p>r.nextInt() + x; 의 형태로 최소값을 지정할 수 있다. 물론 100 + 1하면 1부터 100까지 출력되므로 99까지 출력되게 바꾸려면 99 + 1 로 입력해야 한다.</p>
<p>아직 응애 프로그래머니까 괗호가 닫힐 때마다 //if //else 등으로 어떤 녀석의 닫음 괄호인지 표시해두면 좋다.</p>
<p>// 입력값는 데이터 값을 동일하게 만들어주기 위한 작업<br>
			int data2 = Integer.parseInt(data); => 이새기 이거 존나 헷갈리게 생김. 캐스팅이랑 어떻게 다른지 다시 기억해야겠다.</p>
<p>	public static void main(String[] args) {<br>
		Scanner sc = new Scanner(System.in);<br><br>
		int pre = 0;<br>
		int post = 0;<br>
		<br>
		while (true) {<br>
			System.out.print("1번 숫자를 입력해주세요. >> ");<br>
			int n1 = sc.nextInt();<br>
			System.out.print("2번 숫자를 입력해주세요. >> ");<br>
			int n2 = sc.nextInt();<br>
			if (n1 > n2) {<br>
				System.out.println("앞 숫자가 더 큽니다.");<br>
				pre++;<br>
			} else if (n2 > n1) {<br>
				System.out.println("뒷 숫자가 더 큽니다.");<br>
				post++;<br>
			} else {<br>
				System.out.println("두 숫자가 동일합니다.");<br>
			}<br>
			System.out.print("더 하시겠습니까? 종료(x), 계속(o) >>> ");<br>
			String exit = sc.next().toLowerCase();<br>
			if (exit.equals("x")) {<br>
				System.out.println("게임을 종료합니다. \n앞이 큰 경우는 " + pre + "회, \n뒤가 큰 경우는 " + post + "회입니다. ");<br>
				System.out.println("게임을 종료합니다.");<br>
				System.out.println("앞이 큰 경우는 " + pre + "회, ");<br>
				System.out.println("뒤가 큰 경우는 " + post + "회입니다. ");<br>
				System.exit(0);<br>
			}<br>
		}<br>
		<br>
	}
</p>
</details>

## [9월 25일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>and 연산자와 or연산자의 결과 출력 방식을 생각해서 만약 if 문을 쓴다면 or연산자에서는 true일 확률이 높은 조건을 왼쪽에 배치하는 것이 CPU의 부담을 덜어주는 일이다. 이런 것까지 항상 생각해서 프로그래밍을 하고 서버의 부담을 덜어줄 수 있는 방법을 생각하기.</p>
<p>CPU가 계산할 때 한번에 한 연산자만 쓸 수 있다. 그러니까 연산자가 범벅이 된 코드는 쓰지 않는게 좋겠지?</p>
<p>참조형 = 값이 들어 있는 주소를 변수에 저장, 값을 가져오는 방식을 주소를 가져옴으로써 값을 가져옴</p>
<p>기본형 = 램의 변수에 값을 그대로 저장,값을 그대로 가져오는 방식</p>
<p>결국 둘 다 값을 가져오는 것은 맞는데 값을 가져오는 방식의 차이</p>
<p>배열, 컬렉션 = 많은 양의 데이터를 한꺼번에 저장하는 방법</p>
<p>배열의 값을 알 때, 배열을 선언할 때는 `변수타입[]대괄호 변수이름 = {1,2,3,4}중괄호` 의 형태로 배열을 만들 수 있다. </p>
<p>배열의 값을 모르는 경우, int[] addr2 = new int[1000]; 이 형태로 만들면 int[]값에 해당하는 길이와 int형 변수를 가진 배열을 만들어낸다.</p>
<p>이 때 int로 선언했기 때문에 각 배열의 값은 0으로 자동 초기화가 된다.</p>
<p>배열은 선언할 때 자동으로 초기화가 되기 때문에 따로 초기화를 해줄 필요가 없다.</p>
<p>배열을 syso로 그냥 출력하면 배열의 주소값이 출력됨.</p>
<p>배열에 .length로 길이 출력하는건 자바나 자바스크립트나 똑같다.</p>
<p>배열의 끝에는 항상 그 배열에 대한 length의 값이 저장되어 있다.</p>
<p>참조형의 데이터가 4byte라고 가정할 때, 배열의 길이가 5이면 `참조형(4) x 배열길이(5) + length값(4) = 24byte의 공간을 차지한다.</p>
<p>배열 한번 길이가 정해지면 그 계산이 끝날 때까지 배열의 길이는 변하지 않는다.</p>
<p>이때 컬렉션은 그 길이가 달라질 수 있기 때문에 경우에 따라서는 컬렉션을 사용하는 것이 좋다.</p>
<p>인덱스 = 자릿값, s[0] 일 때 배열은 s, 인덱스 값은 0</p>
<p>보통 배열의 길이를 표현할 때 갯수라는 말 보단 배열의 길이나 사이즈라고 표현함</p>
<p>C타입 for문 = C언어에서 사용하던 for문 형태, 내가 익히 알고 있는 for문</p>
<p>for each문 = (임의의 새 변수 선언 : 배열) 으로 설정하면 배열의 0부터 배열.length까지의 값을 하나씩 임의의 새 변수에 계속 새로 할당. for each문 안에 syso로 출력하는 문장을 넣으면 임의의 새 변수에 할당되는 배열[0]출력, 그 다음 배열 [1]출력하면서 계속 새로운 값을 할당하면서 지나감</p>
<p>특정 값 까지 반복하는게 아니라 전체 반복이면 for each문을 쓰는게 더 쉽겠지?</p>
<p>배열을 사용하는 경우 = 많은 데이터 양, 같은 데이터 타입, 고정된 크기</p>
<p>int, char, String, JButton, double, boolean같은 데이터 타입의 배열 전부 생성 가능</p>
<p>JOptionpane => 무조건 String이라 숫자를 쓰고 싶으면 다른 변수에 넣어서 숫자로 바꿔줘야함</p>
<p>Scanner => 이것도 무조건 String인데, 대신 얘는 scanner 객체 자체에 숫자로 변환시켜주는 int메소드가 들어있음. 그거 써서 숫자로 바꾸면 됨</p>
<p>Integer.parseInt(n); => 아 이거 또 까먹음 기억하기</p>
<p>한번 선언된 변수의 데이터형은 바뀌지 않음 => 유일한 예외 강제 형변환</p>
<p>System.out.println(Arrays.toString(num));; => 코딩 테스트 등에서 배열 내용을 확인하기 위해 쓰는 출력용 문장, 중요중요</p>
<p>System.out.println((double)sum / num.length); => 압력받아 평균, 캐스팅을 잊지 말기 기본형 데이터만 가능하다는 것도 잊지 말기.</p>
<p>잊지말자 보수공사 할 때도 손이 덜 가는 코드가 좋은 코드다.</p>
<p>Font font = new Font("굴림", 1, 15); => (글자체, 진함, 글자크기) 정하는 font 객체 import 해 오기</p>
<p>아 개빡세당 java 첫번째 ppt 208페이지 따라서 계산기 만드는 중인데 전부 한번 썼던 거라 써보니까 기억나는데 그냥 생 문제를 던져주면서 풀어! 하니까 못풀겠엉 아직 연습 많이 필요한듯.</p>
<p>지금 이렇게 화면 띄우고 갖다 붙이고 하는게 자바의 JRE 라이브러리를 이용한 Swing이라는 방식인데, 지금은 안씀. 그런데 왜 이걸로 연습하느냐, 이걸 통해 자연스럽게 자바 프레임 워크로 넘어가면서 자바의 고급 문법을 배울 수 있음.</p>
<p>아 결국 내가 꼭 import해야 된다고 생각했던거는 꼭 new문을 통해서 해야되는게 아니라 어떤 객체든 자동완성으로 가져오기만 하면 자동으로 import가 되는 거였음. new문은 결국 참조형인 객체들은 변수 선언해서 같은 객체를 여러개 쓸 수 있게 하기 위한 방법에 지나지 않음. 객체 명을 그대로 끌어다 써도 import는 자동으로 되기 때문에 알림창을 한번만 띄워도 된다면 joptionpane 같은건 new로 참조형 변수 선언 없이 그냥 가져다 쓸 수도 있는거임. 이 과정도 최적화를 위해서 생각해보기.</p>
<p>참조형 배열 1개가 차지하는 크기는 기본 4byte, 필요에 따라 8byte까지 늘어날 수도 있음.</p>
<p>기본형 데이터 선언으로 만든 배열(?)은 int는 기본 4byte, short는 2byte, long은 8byte를 차지한다.</p>
</details>

## [9월 26일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>RAM의 무더기 영역(heap 영역) = 많은 데이터를 왕창 무더기로 집어넣는 RAM의 공간, 자세한건 class 배우면서 배울 예정</p>
<p>베열, 객체등을 주로 new로 변수선언하면서 불러오는데, 이때 배열, 객체 등이 import되면서 저장되는 공간이 RAM의 heap영역이다.</p>
<p>double[] d === double d[] ==> 이 두가지 배열 선언 방법은 똑같은 결과를 만들어낸다.</p>
<p>null에 대해 == 일부러 만든 없는 값도 맞는데, 변수 선언 시 혹시 존재할지도 모르는 쓰레기값에 의한 오류를 방지하기 위해 쓰레기값을 제거한 없는 값 상태</p>
<p>r.setSeed(100); => 괄호 안의 시드 값만 같으면 동일한 형태의 무작위 숫자 출력, 내가 해보니까 첫 2개 마지막 2개 값이 같았음. 근데 마인크래프트 같은 게임도 월드 생성 시드 있는거 보면 시드로 동일한 데이터를 표현할 수 있다고 생각하는게 맞는 것 같다.</p>
<p>Arrays.sort(); ==> 배열을 오름차순 정렬해주는 객체 자주 쓸 예정</p>
<p>여태껏 parseInt처럼 변수의 값을 복사만해와서 새 변수에 할당하는 경우를 배웠고, Arrays.sort 같은 경우는 배열의 주소에 접근해서 오름차순을 정렬해주기 때문에 변수 할당이 필요없다. 이렇게 값만 복사해와서 쓰는 경우를 비파괴형 함수 / 주소에 접근해서 RAM에 들어있는 값 그 자체를 바꾸는 경우를 파괴형 함수라고 부른다.</p>
<p>Arrays.toString = 애는 비파괴형 함수, 주소를 가져오지만 파괴형인 경우, 비파괴형인 경우가 있어용</p>
<p>애초에 파괴형 함수는 25%정도 차지하지만 일부 파괴형 함수를 자주 쓸거기 때문에 파괴. 비파괴 여부는 알아두는 것이 좋다.</p>
<p>int q = 0, w = 0, e = 0, r = 0, t = 0 ===> 이런 식으로 선언하면 int를 한번 쓰면서 여러 변수를 선언 할 수 있다.</p>
<p>지금 내 컴이 빨라서 for문을 아무리 집어넣어도 빨리 돌기는 하는데, for문도 많이 반복시키면 CPU에 부담이 많이 가기 때문에 줄일 수 있으면 줄이는게 좋다.</p>
<p>"\n" = 줄 바꿈</p>
<p>"\t" = 줄 정렬</p>
<p>equals로 같은지 같지 않은지 판단할 수 있고, !변수.equals로 틀린지도 비교할 수 있다.</p>
<p>.addActionListener() 특정 액션을 기다리는 객체</p>
<p>버튼.addac 자동완성 => null 값에 new ac 자동완성 ==> 밑에 있는거 자동으로 만들어짐, 버튼을 누르는 액션을 했을 때 나타나는 결과<br>
plus.addActionListener(new ActionListener() {<br>
			<br>
			@Override<br>
			public void actionPerformed(ActionEvent e) {<br>
				// 여기에 버튼을 클릭했을 때 처리할 내용을 써주면 됨.<br>
				<br>
			}<br>
		});</p>
<p>JOptionPane.showMessageDialog(null, "더한 값은" + sum); ==> null값은 이 메세지 다이얼로그가 표시되는 위치를 지정함. jframe을 f로 변수 지정 했을 때 null 자리에 f를 넣으면 jframe 위에 다이얼로그 창을 표시함</p>
<p>plus 라는 JButton에 대해 addActionlistener 내용을 입력하면 이련 형태<br>
		plus.addActionListener(new ActionListener() {<br>
<br>
			@Override<br>
			public void actionPerformed(ActionEvent e) {<br>
				// 여기에다가 버튼을 클릭했을 때 처리할 내용을 써주면 됨.<br>
				System.out.println("플러스 버튼을 눌렀군.");<br>
				String s1 = t1.getText();<br>
				String s2 = t2.getText();<br>
				<br>
				// 숫자로 변경해서 그 결과값을 모니터에 출력해보세요.!<br>
				// 마찬가지로 결과값을 다얼로그로도 출력해보세요.<br>
				<br>
				int<br>
				n1 = Integer.parseInt(s1),<br>
				n2 = Integer.parseInt(s2),<br>
				sum = n1 + n2;<br>
				<br>
				System.out.println("더한 값은 " + sum);<br>
				JOptionPane.showMessageDialog(f, "더한 값은" + sum);<br>
			}<br>
		});</p>
<p>코드 리팩토링</p>
<p>각종 기능을 추가할 때, 모두가 기능을 제대로 사용하면 좋겠지만 입력값을 넣지 않는 등의 기능 사용법을 보여줄 수가 있다. 이런 걸 방지하기 위해 if문 등을 활용하여 error메시지를 줄일 수 있다. 줄이면 결과적으로 서버에 도움이 된다.</p>
<p>데이터를 입력했는지 확인하는 방법 2가지<br>
1. s1.equals("")<br>
2. s1.length()</p>
<p>static int total = 0; 이런 변수선언은 main 밖에서 하면 main 클레스 어느 곳에서나 접근 가능</p>
<p>객체지향 코드(좋아보이는거 갖다 쓰기) vs 절차지향 코드(처음부터 다 내손으로 만들기)<p>
<p>스키마설계</p>
</details>

## [9월 27일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>내가 배우는 코드를 책에서 찾으려 하면 조금 다른 형태일 수 있다. 현재 배우는건 실무에서 쓰이는 형태이기 때문</p>
<p>지금 자바 기초를 배우고, 데이터베이스에 대해 배울 예정인데 그 때 자바를 잠깐 내려놓고 커다란 데이터를 어떻게 다룰지 배우게 될 예정이다.</p>
<p>데이터베이스라는 프로그램에 거대한 데이터를 어떻게 설계해서 집어넣을 것인가, 내가 데이터를 제대로 설계한 것인가 배울 예정.</p>
<p>지빙 배열 ppt 130쪽 String의 여러 가지 처리 방법, concat(), charAt(), sunString(), toUpperCase, repalce, contains, endswitch 등, 이런게 대표적인 String의 처리방법이긴 하지만 더 많이 방법이 있기 때문에 시간 날 때 알아두면 좋다.</p>
<p>금융서비스나 다른 사이트 등의 로그인의 경우 로그인 버튼을 클릭할 시 입력 글자와 상관없이 모두 대문자가 되거나 소문자가 되는 경우가 있다. 이럴 때 toLowerCase 등의 함수를 쓰는데, 데이터베이스에는 아아디를 대문자 혹은 소문자의 정보로 저장하는 경우가 많기 때문이다.</p>
<p>[] = s.split(",") ==> s문자열이 "냥,냥,냥,냥" 처럼 ,쉼표로 나뉜 문자열인 경우 쉽표를 기준으로 왼쪽 배열에 집어넣는 함수. 쉼표가 아닌 다른 문자를 기준으로 나눠서 집어넣을 수도 있다.</p>
<p>.trim = String 공백을 제거해주는 함수, 코드 만들기 전에 공백 제거하기</p>
<p>char[] = s.toCharArray() ==> 문자열을 모조리 분해해서 char형태로 집어넣기</p>
<p>기본형이 변수값을 가져와서 다른 변수에 할당할 때 기본적으로 값이 복사되는 형태.</p>
<p>참조형이 복잡한데, 주소를 복사하는 경우와 주소에 들어있는 갑을 복사하는 경우가 있다.</p>
<p>변수에 들어가는 데이터의 유형<br>
1. 기본형 복사 - 데이터, 정수/실수/문자1개/논리<br>
2. 참조형 복사 - 주소가 들어가는 경우로 나머지 모두, 배열, 클래스, 컬렉션 등</p>
<p>참조형 복사를 기본형 복사처럼 하면 자바 스크립트와 마찬가지로 복사까지는 기본형이나 참조형이나 같지만, 복사 이후 사본의 값에 관여할 때 기본형 복사의 경우 사본의 수정이 원본의 데이터에 영향을 주지 않는 반면, 원본과 사본의 주소가 같은 참조형 복사의 경우 사본을 수정하면 원본도 같이 수정되는 모습을 볼 수 있다.</p>
<p>그래서 참조형 복사를 주소가 아닌 값만 가져오려면 n1.clone();처럼 .clone으로 무더기영역(heap)만 복사해와야 한다.</p>
<p>이처럼 무더기영역으로 가는 길(주소)를 복사해 오는것을 ==> 얕은 복사<br>
clone으로 무더기영역의 값만 복사해오는 것을 ==> 깊은 복사</p>
<p>변수의 구분 - 변수를 사용할 수 있는 영역<br>
1. 클래스를 만들고 바로 아래에서 static int 변수 = 0; 처럼 선언한 변수 ==> 전역변수(global 변수)<br>
2. 클래스 바로 아래가 아닌 공간에서 선언된 변수는 해당 지역에서만 사용 가능 ==> 지역변수(local 변수)</p>
<p>이렇게 나뉜건 결국 또 최적화를 위함, for문 안의 변수는 for문 안에서만 이용하고 for문이 끝나면 바로 RAM에서 사라짐. 즉 class 바로 밑에 선언한 변수는 class가 끝나야(해당 기능이 종료되어야) RAM에서 사라짐. 그럼 당연히 전역변수가 많으면 많을수록 메모리에 부담이 가겠죠?</p>
<p>면접에서 변수에 대해 질문할 때가 많은데 기준을 잡아주지 않고 변수가 뭐냐고 질문하면 변수 선언 지역에 따른 질문인지, 선언한 변수의 데이터형에 대한 질문인지 물어보거나 변수의 종류를 정의하면서 대답하는 것이 좋다.</p>
<p>며용 기본형이 아니어도 `==` 을 쓸 수 있는 경우 ==> 주소를 비교하는 경우는 `==`을 쓸 수 있다. </p>
<p>여태껏 쓴 배열이 1차원 배열, 2차원 배열은 0번에 배열이 1차원 배열이 와다다 달린거, 아마 {0{0}}의 형태로 쓰겠지?</p>
<p>OOP(Object Oriented Programming) = 객체 지향 프로그래밍 ( <==> PP(Procedural Programming) = 절차지향형 프로그래밍)</p>
<p>객체지향 프로그래밍은 조립식 컴퓨터처럼 조립하는 방식에서 유래되었다. 1차 세계대전부터 시작된 하드웨어와 소프트웨어의 발전을 살펴봤을 때 하드웨어가 소프트웨어에 비해 비약적으로 많이 발전했다. 하드웨어의 빠른 발전 속도의 원인을 조립식에서 찾았다. 마우스가 망가지면 교체하고, 그래픽이 떨어지면 더 좋은 그래픽카드로 바꿨다. 그 당시 C언어로 이루어지는 소프트웨어의 경우 절차 지향 프로그래밍을 했었기 때문에 고치거나 뺴고 싶은 코드가 너무 앞쪽에 있으면 고치기 어려웠다. 결국 발전과 유지보수등의 이유로 기능마다 하나씩 class를 만들어두는 객체 지향 프로그래밍이 발전했다.</p>
<p>mysql 다운 받아서 자바 프로젝트에서 alt + enter로 라이브러리 - add external jars 에서 mysql.jar 파일열어서 지정하면 JRE처럼 자바 라이브러리 하나가 더 생김</p>
<p>mysql 이것도 mvnrepository(maven repository)에서 받음, 마찬가지로 jsuop라는 것도 받을 수 있는데, 이거는 오래된 핸드폰 같은 곳에서 쓰인 라이브러리로 그에 맞는 프로그램을 개발할 필요가 있을 때 사용하게 될 예정.</p>
<p>JDK에 있는 4500개로 부족할 때, mvnrepository에서 필요에 맞는 자바 라이브러리 가져오는거양</p>
<p>하나의 클래스는 변수와 메소드로 구성되어있다.</p>
<p>멤버변수, 멤버메소드?</p>
<p>지금까지는 main을 만들어왔는데, 이제 대부분의 부품에는 main이 없다.</p>
<p>처음 만들 때 옆에 꺼 이름 바꾸기 = tab</p>
<p>추상화?</p>
<p>멤버변수, 멤버메서드 ==> 전화기로 얘를 들었을 때 이제 클래스에서 import해오면 전화기에 되고 자동초기화된  멤버 변수인 price와 company등을 불러온 내 방에서  지정해줄 수 있고, public void 뭐시기로 만든 메서드는 main에서 import하면 그 메소드에 담긴 기능을 사용할 수 있다.</p>
<p>f.setTitle("나의 버튼들"); ==> jframe으로 띄우는 창 이름 정하기</p>
<p>b1.setBounds(400, 250, 100, 100); ==> 버튼 가로위치, 세로위치, 가로크기, 세로크기</p>
<p>와 jbutton이란 메서드라는 참조형조차 변수로  만들 수 있었던 거임. jbutton[]로 만드는거</p>
<p>기본형의 배열의 경우 0, 0.0, ""등 기본 상태지만 참조형의 배열인 경우 모든 배열칸이 null인 상태로 들어가있다.</p>
<p>수많은 랜덤버튼 만들기 다시 해보기</p>
<p>f.getContentPane().setBackground(Color.green); ==> 이렇게 점점점식으로 이어가는걸 체인식 코드라고 부름.</p>
<p>앗 전역변수는 자동초기화라서 선언만 했던 것처럼 보였던 것이다.</p>
<p>누적시키고 싶을 떄 배열은 적절하지 못하지, 미리 배열의 크기를 정할 수 없기 떄문이다. String에 넣거나 해서 다시 집어넣거나 하는 등의 방법을 사용해야 한다.</p>
</details>

## [10월 4일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>JAVA의 정석은 사전 + 자바 연습 문제집 정도로 이용하면 좋다.</p>
<p>static ==> RAM의 무더기 영역에 고정된 상태로 놓아둘 부품을 설정할 때 씀?</p>
<p>벽돌을 찍어내는 틀 ==> class</p>
<p>class로 만들어낸 물건, 대상 ==> object, 이 때 램에 주소를 가지고 저장되어있음.</p>
<p>실제로 조립해야 할 대상 ==> instance(=='실제'라는 의미)</p>
<p>---class의 instance는 object이다.---</p>
<p>class를 만들 때 특정 종류의 특징만 따온 틀일 뿐이므로 실제로 instance를 만들 때는 내가 값을 집어넣어서 슈붕이든 팥붕이든 만들어서 집어넣는다.</p>
<p>프로그래밍을 object 중심으로 프로그래밍한다. ==> Object Oriented Programming(OOP), 객체지향 프로그래밍</p>
<p>보통 객체지향 프로그래밍에서 말하는 instance라는건 'class로 만들어낸 instance'를 줄여서 말하는 것이기 때문에 곧 object를 뜻하는 말이다.</p>
<p>instance는 실제라는 의미이기 때문에 DB나 클라우드 쪽으로 넘어가면 여러 데이터 중 암호화되지않은(?) 실제 데이터를 instance라고 부른다.</p>
<p>Class = 부류/그룹/종류/틀 ==> 객체지향에서는 특정한 종류가 공통적인 특징으로 만들어진 틀</p>
<p>특정 종류(탈 것 ==> 자동차, 버스, 택시)의 공통적인 특징 ==> 바퀴, 출발한다, 엔진, 브레이크 라는 클래스를 보유</p>
<p>객체 지향 프로그래밍의 중요 개념<br>
1. Abstraction(추상화) ==> 구체적인 부품들을 클래스라는 것으로 추상적으로 표현, ex.두번돌아 높이뛰어 공중제비돌기 = q2 등의 이름으로 표현 가능<br>
2. Encapsulation(캡슐화) ==> 부품의 세부 동작 방식인 은닉되어 있음.<br>
3. Inheritance(상속) ==> 부품을 재사용하여 새로운 부품을 만드는 것.<br>
4. Polymorphism(다형성) ==> 하나의 이름으로 다양한 형태를 사용할 수 있는 것. 다른 메서드를 똑같은 이름으로 만들어 쓸 수 있음.(입력형태 차이 등)</p>
<p>부품 얻는 방법 ==> JDK 4500개 중에 찾는다 - mvnreposiory에서 찾아온다 - 그래도 없으면 프로그래머가 직접 만든다.(20%이하)</p>
<p>instance를 하나 만들 때 class를 불러올 때 new라는 키워드를 통해 변수 선언을 하면서 class에 접근한다, 이 때 class가 가진 변수의 공간 새로 선언하는 변수 선언의 주소에 할당한다. 즉 불러올 class의 변수가 3개의 공간을 가지고 있으면 새 변수(1개) 주소에 class의 변수 공간(3개)를 할당하게 되면서 class를 이용해서 새로 선언하는 변수는 4개의 공간을 차지하게 된다.</p>
<p>즉 new는 객체 생성 키워드, 이 때 무더기 영역에는 class의 변수공간만 저장하고, 주소는 다른 위치에 따로 저장한다.</p>
<p>class로 만든 instance가 성질, 특성 등을 나타내면 멤버 변수</p>
<p>class로 만든 instance가 동작, 기능을 수행하는 메서드(함수)이면 멤버메서드</p>
<p>당연한 얘기지만 물건을 고를 때는 특정 물건을 제외하고는 기본적인 외형을 갖췄다면 기능을 먼저 신경쓴다. 메서드도 마찬가지.</p>
<p>부품을 만들 때는 main을 넣지 않는다. main을 넣으면 혼자 동작할 수 있게 됨. JDK의 4500개의 부품도 main이 없음.</p>
<p>멤버가 자꾸 붙는 이유 ==> 선택되었다는 의미</p>
<p>import를 안해오면 class는 기본적으로 같은 package에서 찾는다.</p>
<p>public = package가 달라도 쓸 수 있게 해줌. 얘가 변수든 메서드는 안붙어있으면 같은 package에서만 쓸 수 있음.</p>
<p>public을 붙임 = ctrl + space했을 때 보임, 안붙임 = 안보임 ==> '가시성이 있다' 라고 표현함</p>
<p>instance 변수 = class로 변수를 생성할 때 원본 값은 그대로 두고 heap영역에 동적으로 생기는 실제 값이 들어가는 변수</p>
<p>변수의 주소값만 출력해봤을 때 다른 사람들과 주소가 똑같은데, 사실 JVM이 다루는 주소 저장 방식(테이블) 때문에 같은 결과가 나오는거고, 실제로 저장되는 위치는 저장하는 컴퓨터마다 다르다. 다른사람과 똑같이 출력되는 이 주소는 쓸일이 사실 없다.</p>
<p>주소를 출력할 때 나오는 문구 마저도 메서드, 이렇게 기본적으로 상속받는 메서드가 8가지가 있음. 주소값 같은 경우 내가 고쳐쓰고 싶다면 이클립스 탭에 Source - generate toString에서 내 맘대로 고쳐 쓸 수 있음.</p>
<p>이 toString은 도대체 언제 호출되나? ==> class에서 참조형 변수가 프린트될 때 자동으로 호출된다.</p>
<p>원본 class, 주소, heap영역 전부 다른 공간에 존재한다.</p>
<p>멤버변수, 멤버메서드는 원본 class위치에 저장, class에서 멤버변수를 가져올 때 멤버 변수의 공간을 heap영역에 복사해서 새로운 instance 변수를 만들어내는 것</p>
<p>클래스와 객체와의 관계 - 클래스는 객체를 만들 수 있는 틀, 어떤 모양인지는 정해져있지만 어떤 내용인지는 프로그래머가 정해줌</p>
<p>클래스의 인스턴스를 무엇이라고 부르는가?<br>
==> object</p>
<p>클래스의 구성요소 2가지<br>
멤버변수와 멤버메서드</p>
<p>필요한 부품을 얻는 방법 3가지<br>
1. JDK에 있는 4500개 중 하나를 가져다 쓴다.<br>
2. mvn repository에서 가져다 쓴다.<br>
3. 직접 만들어쓴다.</p>
<p>전역변수와 지역변수 중 자동초기화가 되는 것은 무엇인가?<br>
==> 전역변수</p>
<p>int와 String이 자동초기화가 되는 경우 무엇으로 자동 초기화가 되는가?<br>
==> int눈 0으로 자동초기화, String은 null로 자동초기화가 된다.</p>
<p>멤버변수와 멤버메서드의 구분<br>
멤버변수는 클래스에서 선언된 변수로, 특정 종류의 모양이나 성질을 담당하고, 멤버메서드는 기능이나 동작 등을 담당한다.</p>
<p>Car c1 = new Car(); c1.size = 10; c1.price = 1000 인 경우, 멤버변수의 갯수, 전체 생성된 변수의 갯수와 크기<br>
==> 멤버변수 - 2개 / 전체 생성된 변수 - 3개, 12byte </p>
<p>참조형 변수를 프린트 시 자동호출(사용) 되는 메서드 이름은?<br>
toString() ==> 패키지명.클래스명@메모리관리테이블키</p>
<p>참조형 변수를 프린트 시 내가 원하는 대로 출력하고 싶은 경우 사용하는 메서드 이름은?<br>
toString()</p>
<p>객체생성시 사용되는 키워드는? ==> new</p>
<p>main이 메소드를 부르면, 메소드가 실행될 수 있도록 main이 공간을 내어줌(쌓임), 1번 메소드 속에 메소드가 있으면, 추가로 공간을 내어줌(쌓임), 메소드가 한번 끝나면 그대로 사라지고, 사라지고 반복하다 전부 반복되면 main도 완료하고 사라짐. 이렇게 쌓으면서 실행하는 영역이라고 해서 스택영역이라고 부름. 스택 영역의 생성되는 순서는 절차형 프로그래밍과 같다. 영역에서 소멸하는 순서도 생성된 순서의 역순이다. 이것을 First Input Last Output, FILO, 선입후출 구조라고 부름</p>
<p>메서드 원본 영역(위) / 스택 영역(왼쪽) / heap 영역(오른쪽) ==> T자형 메모리 구조라고 부름.</p>
<p>void = 반응이 없음(일방통행인) 메소드나 함수를 입력할 때 쓰는 것, 돌려주는게 없으면 void다 라고 표현하기도 함.</p>
<p>드디어 gettext와 settext를 깨달았다. settext는 text를 입력해두는거라 그걸로 변수할당 없이 그냥 void이고, gettext는 void가 아니라서 입력값을 받아서 변수에 할당할 수 있다.</p>
<p>void가 아니면 return값이 있다. <<<=== 중요</p>
<p>File file = new File("test.txt"); // 폴더와 파일을 다루는 메서드, 그냥 존재만 확인 ===> 이상하게 프로젝트 밑에 두면 괜찮은데 패키지 안까지 가져오면 인식을 못함, 패키지가 더 가까우니까 더 잘 인식해야되는거 아닌가 싶기도 함.</p>
<p>FileWriter file = new FileWriter("test2.txt");<br>
어떤 파일을 생성하고, 그 파일에 텍스트를 보낼 수 있는 통로까지 만드는 메서드<br>
이때 이 통로를 Stream, 스트림 이라고 부르는데, 이 스트림을 만들 때 프로그램이 꺼지는 등 오류가 발생할 확률이 높다.<br>
이 스트림이 만들어지는 대표적인 상황은<br>
1. 파일에 읽고 쓸 때<br>
2. 네트워크를 연결 할 때<br>
3. cpu를 연결할 때<br>
</p>
<p>스트림 한번 쓰면 꼭 명령어로 닫아줘야함</p>
<p>try - catch문 ==> try에 명령어, 실패하면 catch문 실행</p>
<p>public void open / public void main, main만 혼자 실행 가능, open은 명령어 opne을 통해 따로 열어줘야 가능.</p>
</details>

## [10월 5일](#top)
<details>
<summary>오늘의 배움</summary>
<p>객체가 만들어질 때 마다 인스턴스 변수가 만들어진다. ==> 이런 인스턴스 변수는 동적으로 생기는 친구, 정적인거는 static</p>
<p>ppt에도 그림이 많고 하니까 어떤 개념을 공부할 때 ~~~하면 일어나는 일 하면서 한번에 나열하는 연습도 해 보기</p>
<p>T자형 메모리 영역에 대해서 설명해라, new로 변수 선언할 때 발생하는 일 등</p>
<p>아 나는 import만 해온 상태라면 메서드를 쓸 때 클래스 이름가져다가 그냥 쓸 수 있는 줄 알았는데 그냥 joptionpane같은거만 해당하는 거였나봄. 그건 그냥 JDK에 들어있는거라 사용 가능했던 것일 수도 있다. 일반적으로 멤버메서드나 멤버변수를 사용하려면 import로 클래스를 T자 메모리 구조에 메서드/스태틱 원본 영역으로 멤버 메서드와 변수를 가져온 후, 인스턴스 생성을 통해 메서드는 스택 영역에서 호출해서 실행하고, 인스턴스 변수는 heap영역에 저장해가면서 사용할 수 있다.</p>
<p>public이 안붙으면 같은 패키지 안에서만 사용할 수 있어용, 이렇게 안붙은 메서드든 변수든 다른 곳에서 쓰려고 치다 보면 not visible하면서 오류가 뜨는 걸 볼 수 있다. 오류 메시지를 잘 읽을 수 있는 능력 또한 중요하겠지?</p>
<p>return으로 해당 메서드를 쓸 때 주고 싶은 값을 돌려줄 수 있다.<br>
이 때 return하고 싶은 값의 타입을 void 대신 적어서 돌려줘야 한다.</p>
<p>public int add3(int price, int count) {<br>
		int result = price * count;<br>
		return result;<br>
	}<br>
  add3옆의 괄호엔 처리하고 싶은 숫자의 갯수만큼 변수를 선언해줘야 값을 다룰 수 있다.</p>
<p>이 괄호 안에 선언해주는 변수를 다리 역할을 하는 변수라고 해서 매개변수, parameter, 파라미터라고 부른다.</p>
<p>순서로 따지면 main보다 import가 먼저 있으니까 메서드/스태틱 원본 영역에 각종 클래스를 가져다 놓고, 스택 영역의 maind 메소드가 실행되기 시작한다. main이 먼저 실행되면서 main을 밑에 깔고 쌓는 형식으로 메소드가 순서대로 실행된다. 이 때 필요한 변수 선언 시 주소는 스택영역, 나머지 값은 heap영역에 저장하면서 진행한다.</p>
<p>대황충격사실 언어마다 다르지만 자바는 메서드 이름이 같아도 오류가 나지 않는 경우가 있다. ==> 입력 형태를 다르게 만들면 가능. 메서드가 입력값을 return할 때 여러 종류의 값을 돌려주는 경우 입력하는 값에 따라 이름은 같지만 다른 내용을 가진 메서드를 자동으로 찾아가기 때문에 이름이 겹쳐도 오류가 나지 않는 경우가 생길 수도 있는 것이다.</p>
<p>이렇게 하나의 이름 안에 여러 가지 메서드를 집어 넣는 방식을 Method overloading, 메서드 오버로딩이라고 한다.</p>
<p>이걸 객체 지향 프로그램의 다형성이라고 하는데 이 메서드 오버로딩이 안되는 경우를 알아야 한다 ==> 파라미터 입력 형태가 다르다면 메서드 이름을 동일하게 쓸 수 있다. 이 때 입력 파라미터가 없는 것도 하나의 형태로 정의하기 때문에 입력값이 없는 경우도 2개를 만들 수 없다. </p>
<p>아직은 어디다 쓰는지 모르겠지만 byte배열(배열 그냥 출력하면 나오는거)를 집어넣는 변수도 존재함.</p>
<p>유틸리티 = 자주 쓰는 것, 보통 java.utill.*; 등에 들어있음, Date, Random 등</p>
<p>핵심 유틸리티 = 더 자주 쓰는 것, 보이지 않지만 이미 import 되어 있음. System, Math, String 등</p>
<p>Math 유틸리티 ==> 괄호 안의 값 반환<br>
abs ==> 정수 값 반환<br>
ceil ==> 올림 값 반환<br>
floor ==> 내림 값 반환<br>
round ==> 반올림 값 반환<br>
pow ==> 왼쪽 값의 오른쪽 값 제곱<br>
max ==> 두 값 중 큰 값 반환<br>
min ==> 두 값 중 작은 값 방환</p>
<p>자바의 메모리 구조 T자형, 원본영역/스택영역/힙영역</p>
<p>생성자 ==> 좀 생소하지만 객체를 생성할 때 쓰는 거라고 함.</p>
<p>GC(Garbage Collector)의 대상이 되는 영역은 head 영역 밖에 없다.</p>
<p>T자형 구조가 소멸하는 순서를 따지면 스택 영역의 메서드가 사라지면서 GC가 알아서 head 영역을 청소해주고 프로그램이 끝나면서 원본 영역이 사라진다.</p>
<p>생성자 ==> 객체 생성과 동시에 내가 꼭 쓰고 싶은(미리 설정된) 멤버 변수 초기화<br>
생성자를 쓰려면 'public 클래스이름' 의 형태로 파라미터로 값을 전달 받아서 미리 선언된 변수에 할당하는 메서드를 만들면 됨.<br>
instance를 만들면서 생기는 괄호 안에 파라미터로 값을 할당하면 미리 선언된 변수에 들어가면서 내가 따로 변수를 불러오지 않아도 값을 자동 할당<br>
즉 클래스로 instance를 만드는 동시에 쓸 수 있는건데 무슨 메서드인지는 클래스마다 다르다.</p>
<p>저번에 mvn repository에서 가져온 libary로 경로지정하는 방법을 다시 하면 됨. 쓸 프로젝트에서 우클릭 - bulild path - configure build path - add external jars - jar 파일 선택으로 가져오기</p>
<p>클래스와 클래스 파일은 다르다. 우리가 libary에서 쓰는 jar로 압축된 파일도 이 클래스 파일이 압축되어 있는 것. </p>
<p>우리가 만든 자바 프로젝트 우클릭 - export - java - jar.file로 원하는 파일이나 폴더 jar 파일로 압축해서 원하는 장소에 저장 가능.</p>
<p>생성자 만들 때 무조건 클래스 이름과 동일해야 자동호출 가능, 생성자는 무조건 void라서 따로 쓰지도 않고, 변수 타입을 선언하지도 않음. 생성자를 만들어주는 메서드를 생성자메서드(생성자) 라고 부르고 constructor라고도 부른다.</p>
<p>왜 생성자가 있으나 없으나 ()가 붙는걸까? ==> 왜냐면 안에 아무 내용도 없는 기본 생성자가 자동으로 생기기 때문</p>
<p>생성자가 이미 있는 클래스로 객체를 생성하면 꼭 생성자를 만들어줘야함. 아니면 오류 생김.</p>
<p>생성자도 마찬가지로 메서드 오버로딩이 가능하다.</p>
<p>Source - Generate constuctor using fileds 로 간단하게 지금까지 생성된 멤버 변수를 포함하는 생성자 만들기 가능</p>
<p>일반적으로 생성자를 만들 때 헷갈리지 않기 위해 생성자의 매개변수 이름이 전역변수와 이름이 동일하다. 이름이 동일한데 어떻게 전역변수에 매개변수 내용을 집어넣느냐? ==> this.를 이용해서 넣을 수 있음. 'this. == 현재 클래스 지정' 을 하기 때문에 'this.전역변수 = 매개변수' 이런 식으로 집어넣으면 가능함. </p>
<p>아 기본적으로 객체 이름만 출력하면 객체의 주소만 나오는데 genrate toString이건 기본적으로 나오는 내용을 객체가 담은 내용을 보여주는걸로 바꾸는 것</p>
<p>지금 내가 변수에 값을 할당한다는 말만 하고 있는데 변수의 값이 없을 때는 값을 초기화 한다는 말도 써보자, 안쓰면 나중에 까먹을 듯</p>
<p>JFrame에 왼쪽 오른쪽 위 아래 원하는 곳에 라벨 집어넣는걸 배웠다 참 재미있었다.</p>
<p>대부분이 다 아는 내용이엇는데 조합하는게 참 어렵다.</p>
<p>chat GPT가 제일 잘하는거 = 코드 오류 잡기, 그러니까 코드 오류를 존나 물어보기</p>
</details>

## [10월 6일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>Bulletin Board System(Bbs) ==> 대한민국에서 많이 볼 수 있는 게시판 시스템을 의미함</p>
<p>기본 원칙 꼭<br>
class명은 꼭 대문자로 시작<br>
나머지 변수, 메소드등은 소문자로 시작<br>
클래스와 생성자메서드의 첫 글자는 대문자로 시작<br>
상수의 경우 예외 없이 모든 글자가 대문자
</p>
<p>	public ArrayList<\Integer> getEven(int[] num) {<br>
		ArrayList<\Integer> list = new ArrayList<\Integer>();<br>
		for (Integer x : num) {<br>
			if (x % 2 == 0) {<br>
				list.add(x);    ==>   이거 첨보는거다 기억하기<br>
			}			<br>
		}<br>
}<br>
		return list;<br>
위 형태로 컬렉션을 메서드에 집어넣어서 변동하는 배열이라도 계산할 수 있다.</p>
<p>위 코드와 내용은 같은 데 ArrayList<\Integer> ==> Hashset 으로 바뀐 코드가 있다. 배열을 돌면서 중복된 내용은 집어넣지 않는 기능이다.</p>
<p>나도 느끼고 있었지만 프로그래밍을 하다 보면 에러가 필연적으로 발생하고, 이 에러를 해결할 수록 더 실력있는 프로그래머가 될 수 있다. 내가 만드는 오류는 어떤 나만의 패턴이 있기 때문에 여러 사례를 접하고 싶으면 다른 사람들의 에러를 접할 필요가 있다.</p>
<p>Static 변수 ==> 클래스에 1개만 가지고 있고(겹치지 않는다는 얘기), 생성된 여러 객체들이 공유할 목적으로 만든 변수, 원본 영역에 생성됨.</p>
<p>아 원본 영역에 클래스 원본, 메서드, static이 다 모여 있어서 원본/메서드/스태틱 영역이라고도 부르는 거였구나.</p>
<p>static 변수를 선언할 때도 다른 전역 변수들 선언하는 것 처럼 class 밑에 선언해주면 됨. 단지 public 뒤에 static 하나 더 붙을 뿐. public이 붙어있다면 전역변수나 메서드 모두에 붙여서 사용할 수 있다.</p>
<p>static을 불러올 때 . => dot notation으로 객체 이름에서 접근해서 쓸 수 있고, 클래스 이름으로 dot notation해서 접근할 수도 있다.</p>
<p>여태까지 joptiopane처럼 클래스명으로 쓸 수 있는 메서드나 변수들은 다 이렇게 static한 변수 선언 때문에 가능 했던 것</p>
<p>public class 나의일과 {<br>
	public static void main(String[] args) }<br>
  이제 이건 해석 가능<br>
  어디서든 인식할 수 있는 publiic class '나의 일과' 라는 클래스를 실행시키고,<br>
  어디서든 public / 여러 객체가 공유 가능한 static / 실행후 바로 끝(리턴없는) void / 프로그램은 위해 가장 먼저 시작하는 메서드 main<br>
  즉 public class 나의일과가 실행되면 나의일과.main 메서드가 먼저 깔리면서 프로그램이 실행된다.</p>
<p>어찌보면 당연한 말이지만 정리해놓기, static 메서드 안에 instance 변수를 넣어서 만들면 오류가 난다. 왜? ==> 일단 static과 instance는 저장 영역이 다르다. static은 원본영역, instnace 변수는 heap 영역에 저장된다. 메서드가 static을 사용할 때는 원본 영역에서 가져다 쓰고, instance 변수를 만들 때는 원본 영역에서 가져온 클래스에서 내용을 집어넣어서 만든 다음 heap 영역에 넣게 된다. 이 때 static 메서드는 원본 영역에 저장되어서 쓰는 형태기 때문에 instance 변수가 메서드 안에 있으면 가져다 heap영역에 저장해서 쓸 수 없기 때문에 오류가 발생한다.</p>
<p>그럼 static 변수는 static 메서드 안에 집어넣을 수 있느냐? 그것도 안됨. 왜냐면 메서드 안에 변수가 갇히는 순간 지역변수가 되는데 static은 전역변수로 원본 영역에만 저장되는 녀석이기 때문에 메서드 안에 집어넣을 수 없다.</p>
<p>지금 와서 생각해보면 부품에서 망치는 메소드인거고, 부품에서 벽돌은 객체인거구만.</p>
<p>생성자를 제공하는 입력값으로만 객체를 생성할 수 있다, static은 실행 시 객체를 생성하지 않아도 언제든 접근이 가능하다.</p>
<p>this => 현재 클래스를 지칭 / super,부모 => 수퍼,부모 클래스를 지칭 / sub,자식 => 서브,자식 클래스를 지칭</p>
<p>상속 => 기존의 클래스를 재활용함, 오버라이드(덮어씀) = @Override 하고 기울임체로 나오는거, 얘를 들면 toString</p>
<p>웹에 보여지는 자바 프로그램 = servlet을 상속 받아서 웹페이지 만듬 / 안드로이드 프로그램 = Activity를 상속받으면 앱화면 하나 만들어짐</p>
<p>슈퍼맨을 자바로 만든다고 했을 때, 사람이라는 클래스가 이미 있으면 굳이 슈퍼맨을 처음부터 만들 필요 없이 사람이라는 클래스를 상속받아서 사람을 기반으로 슈퍼맨을 만들면 된다. 각종 ~~맨들 또한 이런 방식으로 만들 수 있겠다.</p>
<p>ctrl n 으로 자바 클래스를 만들 때 superclass란에 java.lang.Object가 기본으로 설정된다. 여태까지 얘를 superclass를 기본으로 삼고 클래스를 만들었던 것.</p>
<p>public class 남자 extends 사람 {// 사람 클래스를 확장해서 남자 클래스를 만들겠다.}</p>
<p>상속받은 파일을 상속받은 파일을 상속받은 파일을 상속받을 수 있다. 멤버변수와 멤버메서드는 누적되며 늘어난다.</p>
<p>상속이라는건 개 좋은 거네, 브랜치랑 비슷한 느낌을 주네</p>
<p>면접 볼 때 상속에 대해 물어보는 경우도 많았다. 정보처리기사 시험에서 extends를 extend로 써서 탈락하는 경우도 있었다.</p>
<p>super로 상속받으면 부모자식관계가 된다. 그럼 똑같은 상속 바로 아래의 별개의 클래스는 무엇인가? ==> siblings(형제자매) 관계 </p>
<p>그럼 그 siblings 밑으로 상속이 또 생기면 그 친구들의 관계는 뭔가? 사촌? ==> 거기부턴 관계를 지칭하는 말 없음 ㅋ</p>
<p>사실 상속에서 siblings 관계도 서로 영향을 주는게 없기 때문에 프로그래밍에선 별 관계 없다.</p>
<p>여태껏 쓴 jbutton, jtextfield, jlabel들 전부 component에게 상속받았는데, component는 object에게 상속받은 상태이다.</p>
<p>상속 받으면서 복잡해지는 프로그래밍에 대해 그림을 그리기 시작했는데 draw.io에서 볼 수 있다.</p>
<p>이 때 통일된 그림 형태를 Unified Modeling Language(UML)이라고 부른다. 이 UML이 모인 클래스 다이어그램을 회사에서 많이 보게 될 것.</p>
<p>draw.io에서도 uml분류가 따로 있어서 거기서 그림을 그려서 클래스 다이어그램을 만들면 된다.</p>
<p>3번째 틀 선택 후 + == public / filed == 멤바변수이름 / type == 멤버변수타입 으로 적으면 된다. 메서드도 마찬가지의 형태로 작성한다.</p>
<p>오늘같은 클래스 다이어그램 그리기 방식을 회사에서 보고서 용도라든가 그런 걸로 많이 쓴다고 함. 그리고 그거를 딱 보여주면서 나에게 할당해 줄 부분을 알려주기도 하기 때문에 잘 아는 것이 중요하다.</p>
<p>String이 char를 실처럼 엮어 놓았다 해서 String이라는 변수 타입을 가지게 되었는데, Therad도 마찬가지로 실처럼 뭔가 엮을 것 같은 너낌</p>
<p>잠깐 String 복습 String s = "홍길동" ==> s가 4byte차지, char하나당 2byte차지하니까 "홍길동"은 6byte차지 ==> 총 10byte의 공간 차지하는 변수</p>
<p>프로세스 여러개가 기본적으로 길게 늘어져 있다고 치면, 스레드는 프로세스를 잘게 나눠 동시에 처리할 수 있게 만드는 것.</p>
<p>extends 뒤에 Thread를 붙이면 그 클래스는 동시에 돌아가는 부품이 됨. ==> Thread를 상속받은 것과 같은 거임</p>
<p>@Override = 오버라이드 표시, @는 Annotation(표시)라는 의미로 오버라이드임을 표시해서 혼동 방지를 위함.</p>
<p>run이라는 오버라이드 메서드를 통해 클래스의 특성을 재정의, 그럼 기존 특성은 동시에 실행하는게 아니라는 거겠죠?</p>
<p>run오버라이드 메서드와, main에서의 .start 실행 메서드 전부 Thread에서 상속받은 메서드인거임.</p>
</details>

## [10월 11일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>이러닝 업무에 바로 쓰는 자바프로그래밍입문은 보통 개인으로 들으면 150만원, 혹은 기업에서 교육으로 보내주는 강의로 자바를 빠른 시간안에 쓸 수 있게 만들어주는 이러닝. 그렇기 때문에 내가 배우기엔 어려운 내용이 있을 수도 있다. 하지만 이런 것이 있다는 것을 아는 것과 모르는 것은 천지차이기 때문에 알아둘 것</p>
<p>그 기본형 형변환이랑 같은 형변환의 뜻인가</p>
<p>프로그래머로서 살아가게 되면 에러 없는 코드란건 존재할 수 없다는 걸 알게된다. 에러를 해결하는 능력이 중요하다. 트러블 슈팅? 디버깅?</p>
<p>파일 하나당 클래스 하나가 원칙이지만, 코딩테스트나 국가자격증에 한해 파일 하나에 클래스 여러개를 집어넣을 수 있다.</p>
<p>꼭 클래스 하나당 파일 하나, 패키지 안에 같은 클래스가 여러가지가 들어있으면 오류가 나게 되는데 프로젝트 하나를 진행하면서 파일 하나에 클래스를 넣다 보면 클래스 명이 겹칠 수도 있음. 겹치면 당연히? 오류</p>
<p>오버라이드는 run이나 toString처럼 클래스의 성질을 재정의하는것 외에도, 기존 메서드와 같은 이름을 사용하는 방법으로 현재 메소드가 가지는 값으로 덮어쓸 수 있다. 이 때 덮어씌워진 값도 사라지는 것이 아니라 super. 접근법을 통해 값을 가져올 수 있다. 다만 이렇게 super.를 사용해서 super클래스의 값을 가져오는게 프로젝트에 1~2개 정도 들어갈 정도로 잘 쓰지 않는다. 근데 있긴 있어서 다른 사람이 쓴 오버라이드나 super.를 보면 정신이 나가겠지? 그러니까 주석을 잘 달아놓자</p>
<p>상속의 키워드는 extends ==> 이런 키워드를 아는 것이 중요하다. 시험에서 괄호채우기 형식으로 많이 나옴.</p>
<p>상속은 기본적으로 단일상속만 가능</p>
<p>컬렉션은 배열과 다르게 크기가 변할 수 있고, 다른 데이터 타입을 한 배열에 넣는 것도 가능하다. 그런데도 배열을 쓰는 이유가 있겠죠?</p>
<p>컬렉션을 상속받은 클래스, ArrayList를 제외하면 대부분 자료구조나 알고리즘 때 보게 될 것.<br>
List = 순서체크, 중복 허용, Arraylist(제일 많이 씀, 85%)<br>
Set = 데이터 중복 체크, 순서 신경 안씀, Hashset(5%)<br>
Queue = 데이터 선입선출, LinkedList<br>
Map = key와 value가 쌍으로 이루어진 데이터의 집함, HashMap(10%) ==> int[] = {아버지키:175.5, 아버지나이:55} 이런 형식이 mapping되었다고 표현.<br>
이 중 Map은 컬렉션 처럼 변하는 배열이지만 Collection의 상속을 받지는 않은 이단아 같은 녀석.</p>
<p>위 컬렉션의 인터페이스(List Queue)가 아닌 ArrayList, LinkedList 등 선언단어(?)를 배열이 아닌 변수 선언처럼 선언해서 사용한다.</p>
<p>인터페이스라는건 해당 명령어가 가지는 공통점의 집합으로 만들어진 이름 이라고 할 수 있다.</p>
<p>위 컬렉션의 인터페이스를 통해 구현한 컬렉션에 대해 queue를 구현했다, mapping을 했다, list를 만들었다 등으로 표현한다.</p>
<p>이 map의 key값이라는게 배열을 그냥 출력했을 때 나오는 heap영역의 주소값과 같다. 당연히 key값이 중복되면 안되겠지? 이 key 값이 중복되지 않도록 만들어주는 방법이 Hash이다. Hash태그라는 것도 이렇게 중복되지 않는 key값을 말한다.</p>
<p>컬렉션은 처음엔 자릿값도 없고, 어떤 데이터든 들어갈 수 있는 상태이기 때문에 컬렉션.add()의 방식으로 값을 집어넣어야 한다.</p>
<p>Arraylist로 컬렉션을 만들고 syso로 프린트하면 toString이 주소값 표시가 대신 컬렉션 내용 표시로 오버라이드 되어서 나옴</p>
<p>컬렉션의 값 꺼내오기는 배열과 조금 다름 ==>  list[0] X / list.get[0] O</p>
<p>컬렉션의 길이,크기를 꺼내올 때도 배열과 다름 ==> list.length X / list.size() O</p>
<p>컬렉션은 데이터 타입이 다른 값도 들어갈 수 있다고 했지? ==> 이 때 쓰는 변수 선언 Object ==> 나중에 형변환 할 때 또 나올 예정</p>
<p>list.contains("hong") ==> list안에 특정 값이 포함되어있는지 확인하는 문제</p>
<p>arr.set(1, "소혜련") ==> 컬렉션 인덱스 1의 값을 "소혜련"으로 바꾸기</p>
<p>오버로딩 ==> 매개변수를 다르게 입력해서 같은 메서드 이름에 다른 기능 여러가지를 집어넣는 것</p>
<p>오버라이드 ==> 같은 메서드 이름을 써서 상위 클래스의 메서드를 하위 클래스가 재정의해서 사용하는 것.</p>
<p>LinkedList(Queue)는 FIFO(First In First Out) 선입선출</p>
<p>FILO도 복기 ==> main을 필두로 한 메서드 사용 방식이 선입후출</p>
<p>여태까지 add, contain, size, remove등이 Collection클래스가 가진 메서드라고 할 수 있겠다. Arraylist등의 list인터페이스로 내려오면서 Collection 클래스가 가진 메서드를 그대로 가져오면서 필요한 부분은 오버라이드 등으로 덮어씌우거나 하면서 Arraylist의 메서드를 완성하는 등의 일을 한 Arraylist 클래스를 우리가 사용하는 것.</p>
<p>Arrays.toString / ArrayList 헷갈리지 말기</p>
<p>Map은 Collection의 상속을 받지 않는 컬렉션류의 클래스로, key와 value값을 연결시켜서 저장하는 사전식(dictionary)구조라고 말한다. Mapping 시킨다고도 표현.</p>
<p>map.put(x,y) ==> map은 다른 컬렉션들과 다르게 add를 상속받지 않아서 가지고 있는 put을 이용해 값을 매핑시켜서 집어넣음</p>
<p>JSON ==> 자바의 map 구조를 의미, 자바 스크립트의 객체처럼 key와 value 값이 묶여서 들어감</p>
<p>값을 전달할 때, key를 붙여서 전달하는 것이 더 명확하게 전달할 수 있다.</p>
<p>map에 값을 저장할 때, index가 따로 생성되지 않는다. 또한 set 없이 put으로 key의 value값을 바꿀 수 있음, 근데 replace도 있음 ㅋㅋ</p>
<p>try {<br>
				Thread.sleep(1000);<br>
			} catch (InterruptedException e) { // 중단을 실행하는 명령어<br>
				// TODO Auto-generated catch block<br>
				e.printStackTrace(); // 어떤 에러인지 말해주는 명령어<br>
        // 이 e.를 통해 에러를 이메일로 보내거나 문자로 보내는 처리를 할 수 있다.<br>
			}<br>
      위처럼 Thread.sleep()에 1000이 컴퓨터 기준 1초, cpu와 연결해서 1초에 한번 처리할 수 있게 만드는 명령어<br></p>
<p>Thread.slepp()등의 명령어는 자칫 잘못하면 프로그램이 멈출 수 있는 위험한 순간이다. 이런 위험한 순간을 만드는 명령어는 오류가 발생했을 때 어떻게 처리할지 무조건 코딩해주어야한다. try-cathc문을 만들면 생기는 기본적인 구조는 cpu를 멈추고 에러메시지를 출력하는 구조이다.</p>
<p>프로그램이 멈출 수 있는 순간<br>
1. 외부자원(cpu)를 연결 <br>
2. network 연결 = dbms연결<br>
3. file에 연결할 때</p>
<p>프로그램이 멈추는 순간은 전부 외부와 연결하는 순간이 많네, thread와 연관된 부분이 상당히 많은듯?</p>
<p>새삼 생각해보면 컴퓨터 실행하면 마우스, 인터넷연결, 인터넷창 띄우기, 줌 연결중 이라는 프로세스내지 스레드를 동시에 실행하는 컴퓨터의 cpu는 대단하구만</p>
<p>static, main 많이 쓰면 메모리를 많이 쓰게 되어서 좋지 않은 코드이다. 좋은 코드는 main이 아닌 static이 붙지 않으 메서드나 변수로 빼야 한다.<br>
1. 생성자 메서드 안에 쓸 코드를 집어넣는 방식으로 main과 static을 벗어나게 하는 방법(권장)<br>
2. main 밖에 메서드를 만들고 main 메서드를 스스로 호출헤서 main 밖에 만들어둔 void 메서드를 가져오는 방법</p>
<p>class안에 class를 집어넣울 수 있다. 그렇게 집어넣어도 파일 하나가 차지하는 클래스는 하나. 전역 변수를 사용할 목적으로 class안에 class를 집어넣는다, 이런 방식을 inner class라고 한다.</p>
<p>inner class를 많이 만들면 좋은가? ==> 안좋음. static main에서 코드를 빼는 것과 달리 복잡해짐 잘 안씀</p>
<p>근데 이걸 왜 함? ==> 다른 사람들이 inner class를 이용해서 만들어놓은 코드들이 있음. 이걸 이해할 수 있어야 함.</p>
<p>try catch ==> 런타임 오류를 방지하기 위함, 애초에 컴파일 오류(문법오류)는 애초에 실행되지 않음. 런타임 오류는 사고로, try catch문이 방지해주는거고 문법오류는 eclipse와 내가 잡아야 하는 것.</p>
<p>인터페이스, 익명클래스 ==> click.addActionListener(new ActionListener() {메소드})<br>
내용 없이 괄호만 가진 반쪽짜리 메서드를 포함하는 클래스, 내가 직접 actionperfomed 내용을 입력해서 완성된 메서드로 만들어 활용할 수 있다.<br>
최근 안드로이드 프로그램을 만들 때 익명클래스를 사용하는게 대새이다. ==> 이렇게 우리가 직접 구현하는 걸 implements한다고 한다.</p>
<p>의사코드(유사코드, pseudo code) ==> 코드 한번에 다 짜는게 힘들기 때문에 프로그램 진행 과정을 단계별로 요약 정리하는 것</p>
</details>

## [10월 12일](#top)
<details>
<summary></summary>
<p>데이터베이스는 Oracle 안쓰고 MySQL만 쓸 예정이라고 함, 기업에서 둘을 똑같이 취급한다고 하는데, Oracle이 유료라고 함</p>
<p>데이터베이스는 문법은 없고 방법론 중심으로 배운다고 함.</p>
<p>자바의 끝은 상속이다.</p>
<p>객체 지향 프로그램밍의 2대 중요 원칙<br>
1. 응집도(Cohesion) 를 높게<br>
어떤 클래스는 하나의 역할에 충실하도록 한다.<br>
==> 바퀴는 바퀴 역할만, 바퀴가 엔진의 역할을 겸하면 바퀴가 터졌을 때 엔진까지 바꿔야 함<br>
2. 결합도(Coupling) 를 낮게, 느슨한 결합도<br>
특정 클래스에 종속되는 정도가 낮아야 한다.<br>
==> 자동차를 만들 때 특정 회사의 바퀴만을 사용해야 한다면 바퀴를 위해 나머지 부품을 바꿔야 할 수도 있고, 바퀴를 튜닝하고 싶어도 튜닝하기가 어렵다.</p>
<p>형변환 = 캐스팅(Casting) = 데이터 타입 변환</p>
<p>Casting은 던져졌다는 의미로, 데이터 타입을 다른 타입으로 변환하는 것을 의미함.<br>
이 때 boolean을 제외한 기본형은 서로 형변환이 가능함.</p>
<p>기본형 == 값 / 참조형 == 주소</p>
<p>형변환은 크고 작음만 판단하면 됨<br>
자동형 형변환(Up Casting) ==> 작은 곳의 데이터를 큰 곳으로 옮기는 것, 자동으로 형변환 되어서 저장<br>
강제형 형변환(Down Castin) ==> 큰 곳의 데이터를 작은 곳으로 옮기는 것, 강제로 형변환 되어서 저장<br>
기본형 참조형 둘 다 상관없이 강제형, 기본형 형변환을 따름</p>
<p>		byte x = 127; // 0110<br>
		int y = x; // 0000000000000110 => 자동형 형변환<br>
    byte z = (byte)y; // 0110 => 강제형 형변환<br>
    기존 1byte만 차지하는 x가 int로 들어가면 자동으로 byte 3칸을 더 차지하게되고, 반대로 int에 저장된 byte를 byte에 다시 넣으려고 하면<br>
    직접 Casting의 형태 - (byte)y; - 를 이용해서 빈 byte 3칸을 cpu로 직접 자르고 강제로 가져와야 한다.</p>
<p>BSIL.1248 = 127.3만.21억</p>
<p>float = 4 / double = 8</p>
<p>요즘은 대부분 1byte가 8bit의 공간을 차지하는게 대부분이긴 하지만 일부 프로그램의 경우 4bit, 7bit, 12bit등이 1byte를 차지하는 경우가 있다.</p>
<p>참조형 형변환의 크기를 판단하는 건 상속을 기준으로 한다. 부모 클래스가 자식 클래스보다 크기가 큰 것으로 간주한다.</p>
<p>JButton, JTextField등의 Swing의 부모 클래스인 Component는 add메서드를 가지는데, 이 add 메서드가<br>
public void add(Component c) ==> 이런 형태라서 어떤 j자식클래스든 집어넣을 수 있었던 것. 어태껏 자동형 형변환이 되고 있었던 것이다.</p>
<p>참조형 형변환은 상속관계에서만 가능하다. 그래서 참조형과 기본형 형변환은 이루어지지 않는다.</p>
<p>list.add(); 를 열고 파라미터 값 형태를 보면 object라고 적혀있다. Object 자손클래스에 String이 있어서 자동으로 형변환 되면서 들어감,<br>
이 때 int를 집어넣어도 들어가는데, int는 기본형이지만 Integer라는 int를 다루는 클래스로 집어넣을 수 있다.</p>
<p>int - Integer / double - Double / boolean - Boolean / char - Charater<br>
==> 이런 클래스들이 자동으로 변환시켜줘서 add에 Object가 들어가도 집어넣을 수 있다. 반대로 Object가 된 기본형을 꺼내올 때도 Casting안에 넣어주면 자돋으로 바꿔줌 ==> </p>
<p>Wrapper 클래스 - Auto Boxing이 되는 클래스<br>
==> int등 기본형을 참조형으로 바꿔주는 클래스, Auto Boxing한다고 표현하기도 함, 반대로 기본형으로 바꿔줄 수도 있는데, 이걸 Auto Unboxing한다고함.</p>
<p>위 list에서 집어넣은 String 값을 다시 String 변수에 선언하면서 꺼내오려고 할 때, 오류가 발생하는 것을 불 수 있다. 바로 String이 자동 형변환으로 Object가 되었기 때문인데, String 변수에 다시 집어넣으려면 (String)의 Casting 방식을 사용해서 집어넣어야 한다.</p>
<p>Casting 방식으로 Object를 꺼내와서 변수에 할당하는건 String이나 기본형 뿐만 아니라 JButton 같은 참조형도 해당한다.</p>
<p>기본적으로 ArrayList라는 클래스를 만들 때 길이가 가변적이고 어떤 타입이든 넣을 수 있는 컬렉션을 만들었지만, 실제 코드에서 다양한 타입을 넣는 경우가 흔치 않다. 그래서 1.8(?) 버전부터 꺽쇠를 ArrayList에 추가해서 꺽쇠 안에 '클래스'를 집어넣기만 하면 형변환 없이 그대로 컬렉션에 집어넣을 수 있게 해줄 수 있다.<br>
ArrayList꺽쇠String꺽쇠 list = new ArrayList<>();</p>
<p>이렇게 형변환 없이 집어넣을 수 있게 해주는 문법을 generic(제너럴, 일반적인) 문법이라고 한다.<br>
꼬오오옥 무조오오건 generic 문법에는 클레스만 집어넣기, 당연히 int나 char를 쓰려면 Integer나 Character를 집어넣어야겠지?</p>
<p>근데 왜 값이든 주소든 꺼낼 때 다시 형변환을 해야함? ==> Object로 꺼내면 Object의 메서드 밖에 쓸 수가 없다. 형변환을 해야 상속으로 이어나간 메서드를 쓸 수 있다.</p>
<p>면접 때 interface의 implements랑 class의 extends가 어떻게 다른지 질문하기도 한다(고급)<br>
JButton 등이 component의 상속이 아니지만 상속 받은 것처럼 여겨서 형변환이 된다고 이해함. implements랑 extends랑 다르다고 얘기하신걸 보면 아마 JButton등은 class의 extends를 받았다가 아니라 interface의 implement를 가진다 혹은 받았다 정도로 이해하고 있어야 할 듯.</p>
<p><br>여기부터복씁<br></p>
<p>HTML - Hyper Text Markup Language<br>
<>태그를 사용<br>
다른페이지와 연결하고 싶을 때 <> + a href ="" /a + <> 의 형태로 다른 페이지와 연결<br>
Css와 JS를 사용하는 세 가지 방법 - 1. 외부파일로 head에 링크 태그로연결 / 2. 파일 내부 head 태그 안에 script나 style 태그로 사용 / 3. 특정 태그에 지정해서 사용<br>
자바와 자바스크립트의 정적 타이핑과 동적 타이핑은 입력에 따라 달라지는 변수를 기준으로 만든 말인 것 같음.<br>
함수, 메서드는 반환값이 있는게 있고 없는게 있다. 반환값이 있는 경우 마지막에 꼭 return을 써줘야 한다.<br>
HTML에 css,js 여러개 넣을 수 있고, HTML은 줄 제약이 없다.<br>
각 HTML버튼, input, table 등의 태그에 스타일지정, js넣기(alert)등을 할 수 있다.<br>
HTML,CSS,JS는 10문제 이하<br>
자바스크립트를 브라우저에서 실행한다 -vs- 동적으로 처리한다 문제가 나오면 브라우저 실행 제외하기<br>
==> 왜냐면 브라우저에서 실행할수 있지만 브라우저에서만 실행하는게 아니라 서버쪽에서도 실행하기 때문
</p>
<p>JAVA<br>
객체지향형 프로그래밍 - OOP(Object Oriented Programming)<br>
기본형 - 값이 저장, 정수/실수/문자/논리<br>
참조형 - 기본형이 아닌 모두. 배열/클래스/인터페이스/컬렉션..... 의 주소<br>
클래스로 만드는 객체, instance, 클래스의 실제<br>
연산자 - 산술 / 비교 / 논리 / 대입(할당) / 연결<br>
배열 - 길이 고정, 동일 타입, legnth, 읽기전용변수<br>
컬렉션 - 길이 변동, 모든 타입(요즘은 generic사용), size<br>
      - 순서 : list / 중복x : set / FIFO : queue / 키+값 : map<br>
클래스 - 멤버변수(속성, 성질) + 멤버메서드(동작, 기능처리)<br>
      - 메서드 : 함수와 같은 개념, 입력값이 있을수도, 없을수도 있음, 있으면 return<br>
상속 - 클래스를 만들 때 기존에 있던 클래스를 재사용해서 좀 더 추가해서 만들자라는 개념, 수퍼클래스 부모클래스 - 서브클래스 자식클래스<br>
    - 단일 상속
</p>
<p>mySQL / Oracle ==> 많은 양의 데이터를 다룰 수 있는 데이터베이스 프로그램</p>
<p>DBeaver - 데이터베이스를 쉽게 다룰 수 있는 프로그램(mySQL 자체는 기능이 별로 없어서 이거 씀, 리눅스 처럼 명령어 써야 함)</p>
<p>여태까지 만든 자바 프로그램들은 RAM에만 잠깐 데이터를 가져다 놓을 뿐 프로그램이 끝나면 사라지는 데이터만 사용했고, 이제부터 사라지지 않는 데이터를 다룰 예정</p>
<p>git bash나 터미널 대신 소스트리를 쓰는 것처럼 mySQL로 명령어를 쓰는 것보다 DBeaver를 쓰는 너낌</p>
<p>지금은 DataBase를 내 컴퓨터에 깔아서 쓰지만, 나중엔 서버용 컴퓨터를 새로 놓고 거기에 데이터베이스를 두고 데이터를 다룰 예정(아프리카 같은 곳이 저렴함)</p>
<p>DB 클라이언트 프로그램 - db를 클라이언트 환경에서 명령어가 아닌 비주얼한 환경에서 마우스를 클릭하여 쉽게 조작할 수 있는 프로그램</p>
<p>db에 연결하기 때문에 db클라이언트 프로그램이라고 부르고, 보통 이런 프로그램들은 community, pro버전으로 나뉘어져 있다. community는 보통 무료지만 기능에 제한이 있고, 기업같은 곳에선 월 정액제를 내고 pro버전을 사용하는 경우가 많다.</p>
<p>Oracle에는 Oracle이라는 db프로그램이 있는데, 사람들이 mySQL을 더 많이 씀(무료라)<br>
mySQL이 나중에 Oracle에 인수합병되면서 mySQL도 기업에선 유료로 쓰는데, mySQL제작자가 똑같은 db를 mariaDB라는 이름으로 만들어서 무료로 플어버림 ㅋㅋ<br>
참고로 my와 maria 모두 개발자의 딸 이름을 따와서 만들었음.</p>
<p>보통 libaray에서 파일을 가져올 때는 사용 빈도수가 가장 많은 걸 가져와서 쓰면 된당</p>
<p>Connection conn = Jsoup.connect("http://www.naver.com"); // Connection 부품 리턴 ==> jsoup 라이브러리의 클래스를 사용해서 네이버와 연결하기<br>
이제부터 conn을 쓰면 connect한 사이트와 네트워크 연결을 하는 것</p>
<p>Document doc = conn.get(); ==> html문서니까 jsoup의 Document라는 부품 사용 ==> conn으로 연결한 사이트의 html을 크롤링해오는 클래스</p>
<p>위 클래스(?)를 import할 떄 무조건 org.jsoup에서 가져와야 함</p>
<p>Document로 html코드를 가져오는건 외부자원 연결(cpu, file, network)중 network에 해당하기 때문에 try-catch문으로 감싸줘야함</p>
<p>네트워크를 통해 코드를 긁어오는 방식 - 크롤링</p>
<p>이렇게 doc로 html코드를 전부 긁어오면 Elements list = doc.select(".service_name"); 방식을 통해 Arraylist에 집어넣음.<br>
이 때 jsoup가 Elements에서 Arraylist를 상속받았기 때문에 list라는 컬렉션에 순서대로 집어넣을 수 있다. Element 쓰면 태그 1개만 들어감</p>
<p>Elements.select(".service_name"); ==> 조건에 맞는 태그들의 리스트를 객체생성<br>
Elements.select("span.service_name"); ==> 무조건 태그를 가져오는 클래스, '.servie_name' 이라는 조건이 붙은 span 태그를 찾음<br>
여기서 . 이 앞에 붙은 이유는 css클래스이기 떄문, span 처럼 태그를 집어넣을 땐 그냥 집어넣고, 특정 조건이 붙은 태그를 찾을때 사용</p>
<p>.text() ==> 텍스트만 뽑아오기 / list.get(i).text() ==> list에 태그를 집어넣었을 떄, 태그사이 내용 중 text에 해당하는 것만 가져오기<br>
굳이 text만 꺼내올 필요가 있나? - list.get(); 만 사용해서 꺼내면 태그 전체를 꺼내옴. 데이터를 다루는 방식일 뿐</p>
<p>네이버 증권의 크롤링을 통해 싯가 등을 긁어오면 class중 blind가 붙어있는걸 볼 수 있는데, 증권 정보를 함부로 긁어가지 못하게 만들기 위함, 네이버는 반쯤 막아뒀는데, 유명한 증권사이트의 경우 아예 크롤링 할 수 없게 막아놓는 경우가 많음.</p>
<p>Elements list2 = doc.select("td.first span.blind") ==> css의 자손 클래스 접근법으로 td 에 숨은 blind를 가진 span 가져오기</p>
<p>회사가 크롤링 잘하는 인재를 좋아하는 경우가 있는데, 구인구직란부터 애초에 크롤링 경험으로 우대하는 경우도 있다. 법적인 문제를 제외하면 크롤링 하는 것이 뭐든 만들기 수월하다.</p>
<p>눈 - 자주 쉬어주기, 모니터 많이 안보기, 체중관리 - 운동, 디스크 관리 - 서서 수업듣기, 운동하기</p>
<p>기존 문법과 달리 내일 부터 배울 데이터베이스 다루기는 약간 쉬어가는 느낌으로 하기</p>
</details>

## [10월 13일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>어제 난이도가 4라면 오늘은 1이라고 하심</p>
<p>컴퓨터 하나 당 IP주소 하나를 배정받음.</p>
<p>중요하다고 나온 웹 프로그램 구조를 보면서 쿨러이언트, 웹서버, db측이 서로 연결되는 방법은 IP주소를 통해 네트워크로 연결되는 것이다.<br>
이 때 IP주소 + 별도의 번호(port(항구) 번호) 를 기준으로 프로그램을 구분하고 네트워크로 연결할 수 있다.<br>
이게 무슨 말이냐면 클라이언트가 네트워크로 연결된 브라우저와 게임을 모두 실행시킨다고 했을 때 브라우저는 IP주소 + port번호 / 게임은 IP주소 + port번호 로 port번호를 다르게 하는 방법으로 프로그램을 구분하고 네트워크로 연결한다.</p>
<p>근데 배우는 입장인 나는 클라이언트,웹서버,db가 모두 한 컴퓨터에서 돌아갈 예정이다. port번호가 더 많이 필요하겠지?</p>
<p>mySQL의 port번호는 보통 3306으로 초기 설정됨.</p>
<p>DBeaver켜서 mySQL db와 연결 후 보이는 localhost 고래그림에 초록색 체크가 아니라 빨간색 x표시가 있으면 연결이 안되있다는 뜻.</p>
<p>db를 만들면 mySQL에 한 자리 차지하게 됨. 그리고 db엔 table이라는 방식으로 구분되는 게시판 정보, 회사 정보 등이 저장되게 된다.</p>
<p>이 db를 다루는 방법 => 1. DBeaver를 통한 비주얼 클릭 / 2. mySQL을 통한 문법</p>
<p>대부분의 사이트가 프론트측은 JS, 백엔드측은 JAVA로 이루어진 곳이 상당히 많다. db는 mySQL이 많은데 국가 등이 관리하는 민감한 정보는 Oracle을 쓰기도 한다.</p>
<p>정형데이터베이스 - Oracl, mySQL => 점유율 비슷함, 추가로 PostgreSQL이라는 무료 프로그램이 급부상중인데 아직은 앞의 두 프로그램을 따라가지 못함.</p>
<p>반정형데이터베이스 - noSQL</p>
<p>나중에 포트폴리오 만들 때 정부에서 주는 실제 데이터를 가지고 따릉이 정보사이트를 만들게 됨, 이 때 데이터를 오픈소스, 클라우드에서 받아올 에정</p>
<p>DBMS - DataBase Management System<br>
실시간 접근성 : 실시간 접근 가능<br>
계속적인 변화 : 항상 최근의 정확한 데이터로 변화<br>
동시 공유 : 여러 사용자가 동시에 공유<br>
내용에 의한 참조 : 참조 시 주소필요없이 내용으로 참조 가능</p>
<p>RDMBS - Relational DBMS, 관계형 DBMS, 실무에서는 RDB로 많이 부름<br>
==> 회원정보의 id와 게시판의 게시자 정보는 같은 형태의 정보가 필요하겠지?<br>
또한 주문 페이지가 요구하는 사용자 정보와 제품 정보는 다른 DB에도 들어있겠지? 이렇게 db가 서로 관계있음을 말하는 것 같음.<br>
이런 데이터를 서로 연결할 수 있다.</p>
<p>어떤 사람이 회원가입을 한다고 치면 ==><br>
db의 회원정보 저장공간 - tabel / 회원정보 - 엔티티(entity) / 테이블 자리에 설정되는 각각의 회원정보(나이, 이름) - 속성, 특성</p>
<p>db다루기<br>
1. DBeaver로 db생성 - locahost - database 우클릭 - create new database - utf8 기본설정 가지고 데이터베이스 생성<br>
2. 특성을 넣은 테이블 생성 - 생성한 데이터베이스 - tables 우클릭 - create new tabels<br>
- 테이블명 바꾸고 column밑에 빈 공간에서 우클릭으로 column(특성) 이름 짓고 생성 - ctrl + s 이후 persist로 저장해야 mySQL도 반영됨 (commit 너낌)<br>
3. 데이터 집어넣기 - 만든 column의 data 탭 클릭 - 하단 탭의 +기호 들어간 아이콘 클릭해서 데이터 집어넣기. 마찬가지로 저장해줘야함<br>
- 지우는건 지우고 싶은 줄로 가서 -기호 들어간 아이콘 클릭후 저장하면 반영됨. - 경고창뜨면 use all columns 클릭
</p>
<p>column 생성할 때 기본적으로 var char(100) 이렇게 설정되어 있는데 다른 데이터 타입으로 바꿀 수도 있음.</p>
<p>column을 만들면 마치 엑셀 같은 외양을 보여주기에 친숙한 느낌이 들 수 있다.</p>
<p>ppt에 나온 db의 table도 uml방식으로 표현되어 있는데, 이것도 그림으로 그려보는게 좋을 것 같다.</p>
<p>DBeaver는 uml이 자동 생섣되는데, table이 들어있는 db를 더블클릭후 엔티티관계도를 클릭하면 uml관계도를 볼 수 있다. 반영안되면 새로고침</p>
<p>엔티티 관계도에서 uml그림 우클릭 후 view style에서 table에 대한 정보를 더 표시할 수 있다.</p>
<p>헉 현업에서는 명령어를 어느정도 알고 있어야 한다고 함.</p>
<p>프론트,백엔드 가 js, java처럼 주 사용 언어가 있는 것처럼, db도 사용 언어가 있음 - 그것이 바로 SQL, db에 SQL이라는 이름이 붙는 이유</p>
<p>즉 SQL문법을 사용해서 db를 다루는 것이다. JPA를 쓰면 SQL을 몰라도 쉽게 작업할 수 있는데, SQL문법을 모르면 JPA를 쓸 수 없는 상황에 대응 불가능</p>
<p>갓 DBeaber - SQL문을 쓸 수 있는 터미널도 열어줌 - 원하는 db 클릭후 상단 탭의 SQL 클릭 - 이후 155페이지 3번부터 실습</p>
<p>SQL = Structured Query Language ==> 체계적으로 정리된 명령을 위한 문법들의 모음</p>
<p>Query = 질문하다, 명령하다</p>
<p>-- ==> SQL의 주석 / ctrl + enter ==> SQL의 현재 쿼리 실행</p>
<p>각 명령어는 한 줄씩 띄워놓아주어야 함. 이건 SQL문법은 아니고 DBeaver 프로그램의 특징</p>
<p>where는 java의 if같은 조건문의 역할</p>
<p>SQL의 '='는 java의 '=='와 같은 역할 / 그런데 = 가 SQL의 할당을 하기도 함, 느슨한 언어</p>
<p>이상하게 varchar2(10)로 만들려고 하면 오류가 나서 그냥 varchar(100)으로 만들었음.</p>
<p>이게 코드가 한번 실행하고 끝이 아니라 기존 쿼리에 다시 와서 실행만 시켜주면 또 데이터 들어가고 그러기도 하네.</p>
<p>Data Definition Language(DDL) - 어떤 데이터를 저장할지 정의하는 문법</p>
<p>Data Manipulation Language(DML) - 데이터를 조작하는 문법</p>
<p>insert into me values('100', '100', 'park', '011'); -- 데이터 삽입</p>
<p>update me set tel = '999' where id = '100'; -- id 값이 200이면 name을 kim로 수정</p>
<p>SQL문만 가지고 데이터 다루는 연습 하기</p>
<p>SQL문으로 집어넣은 데이터는 mySQL에 바로 반영됨, 지우려면 delet from이나 DBeaver를 이용해 직접 지워야 함.</p>
<p>select * from product3 where id = '100'; ==> 고른다 모든것을(*) product3 table에 존재하는 조건 id = '100'을 만족하는.</p>
<p>select name, content from product3 where id = '100'; ==> 고른다 name과 content라는 특성의 내용을 product3 table에 존재하는 조건 id = '102'를 만족하는.</p>
<p>java와는 다르게 SQL은 명령어 대소문자 구분이 없음. 명령어를 실행할 때 내부적으로 알아서 대문자로 바꿔서 멸령어를 실행하게 됨.</p>
<p>SQL문으로 하고싶은 명령의 역할에 따른 용어와 SQL명령어의 구분<br>
DDL Data Definition Language ==> 데이터 항목 정의<br>
DML Data Manipulation Language ==> 데이터 조작<br>
DCL Data Control Language ==> DBMS제어 (계정관리, 백업 / 복원)<br>
TCL Transation Control Language ==> 트랙젝션 제어 </p>
<p>어느 회사든 이런 DB를 전문으로 다루는 사람이 따로 있다. 자바 개발자로서 가장 집중해야 할 개념은 DML이다.</p>
<p>DML - CRUD **중요**<br>
Create(만들기) - insert(SQL문법)<br>
Read(검색,찾기) - select<br>
Update(수정하기) - update<br>
Delete(지우기) - delete<br>
실무에선 게시판을 만들었냐 ==> 게시판 CRUD 했냐 이런 식으로 말한다.</p>
<p>
사이트 - 쿠팡 (https://www.coupang.com/np/campaigns/82)
Tablel1 로켓배송 - column 식품, 생활용품, 뷰티
Tablel2 로켓프래시 - column 과일, 정육, 밀키트
</p>
<p>자 네이버 메일이나 메모 등을 예로 들면 다 db에 들어있겠지? 웹서버 수준에서 끝나는 정보를 지나쳐 네이버가 가진 db에서 id pw일치 여부와 메일의 파일, 내용등을 SQL문법(혹은 DBeaver등)으로 가져온다. 예상하기로는 그렇게 가져온 데이터를 자바에서 처리할 수 있는 클래스를 통해 웹서버로 전달하는 건가? 웹서버로 전달하면 브라우저에 그 정보를 표시하기 위해 javascript의 방법으로 브라우저에 표시하겠지?</p>
<p>보통 사이트에서 나를 인식할 수 있는 정보는 id, 나머지는 겹칠 수 있지만 id는 겹칠 수 없게 만들어놓은 것도 그것 뿐. pk도 그것과 같은 원리</p>
<p>항상 db에서 데이터를 집어넣을 때 행 1개를 인식할 수 있는 key가 되는 column을 하나씩 꼭 넣어두기 - PK</p>
<p>PK(Primary key, 기본키) ==> 어떤 db의 행을 인식할 수 있는 key, table의 properties 왼쪽 탭에서 따로 Contraints(제약조건) 설정<br>
- 빈칸 우클릭 - create new contraints - type primary key - 보통 id체크 후 저장, not null + unique 자동 설정 - 저장<br>
</p>
<p>FK(Foreign key, 외래키) ==> 다른 db의 PK를 받아온 column, table prperties 왼쪽 탭에서 foreign keys로 설정<br>
- 처음 화면이 reference key - 여기서 받아오고 싶은 db의 key를 설정 후 column 빈칸에서 FK로 만들고 싶은 column 설정 - 저장</p>
<p>PK가 되기 위한 개체 무결성 - 값이 유일(unique), 비어 있으면 안됨(not null)<br>
FK가 되기 위한 참조 무결성 - 값의 범위를 자동 체크, 외래키에 들어있는 데이터만 넣을 수 있음</p>
<p>FK로 연결하면 엔티티 관계도에서도 uml로 자동으로 연결됨, 이제 fk에 해당하는 column엔 연결된 table의 PK에 해당하는 값만 집어넣을 수 있음.</p>
<p>회사 가면 UML로 그려진 엔티티 관계도를 보여주면서 해석을 요구하는 회사가 있을 수도 있음. 연결선 클릭해보면 뭐랑 연결되어있는지 보임</p>
<p>FK로 연결해주는 db는 꼭 데이터 타입이 일치해야함</p>
<p>DB특강 받으려면 돈 많이 깨짐 -- DB도 전문 분야라서 많이 알면 알수록 좋긴 하다. DB 튜닝만 전문적으로 하는 사람들은 연봉 4~5억 받고 이럼 ㄷㄷ</p>
<p>내 일을 하는데 있어서 다른 사람이 가지지 못한 나만의 unique함을 가지면 좋다.</p>
<p>브라우저는 js만 알아듣고 db는 SQL만 알아들음, DBeaver같은 자바로 만든 프로그램이 중간다리 역할을 해준다.</p>
<p>DBeaver를 써서 비주얼로 편하게 클릭한 후 저장할 때 SQL문으로 된 명령어를 자동으로 만들어서 db에 전달한다.</p>
<p>아 db에서 데이터 추가나 삭제하는걸 DML 한다고 표현하고 데이터베이스를 만들거나 테이블을 만들고 지우는건 DDL한다고 표현하는거구나</p>
<p>delete from 테이블 - 테이블 내용만 삭제 / drop table 테이블명 - 테이블 통째로 삭제, 복구 불가</p>
<p>자바와 마찬가지로 지금 이 파일의 위치가 궁금하면 alt + enter로 찾기</p>
<p>아직 db에서 자바로 꺼내오는거 안배움</p>
<p>
정형 데이터란  -- 데이터 타입이 정해져 있는 형태의 데이터
DBMS란? -- Data Base Management System => 데이터 베이스를 다루는 체계를 가진 프로그램(?)
당신이 알고 있는 DBMS의 종류 2가지 이상 => mySQL, Oracle, postgreSQL
SQL은 무엇의 약자? => Structured Query Language
SQL의 종류 3가지 분류 ==> DDL(Definiton) / DML(Manipulation) / DCL(Control)
CRUD = DML을 하는 방법을 의미, 데이터 조작을 하는 방법, Create, Read, Update, Delete
insert into 테이블 values
selet from / selet * from
</p>
</details>

## [10월 15일](#top)
<details>
<summary>오늘 배운 것?</summary>
<p>JAVA_HOME으로 JDK파일에 환경변수 설정을 새로 만드는건 자바를 쓰는 프로그램에서 java tool을 찾을 때, 이 이름을 찾기 때문 </p>
<p>PATH환경변수를 JDK파일의 bin폴더에 연결하는 이유는 JAVA_HOME(JDK)의 컴파일러, 압축 프로그램 등이 bin폴더에 들어있는 걸 어느 위치에서든 찾을 수 있도록 만드는 것</p>
<p>JAVA_HOME은 bin 폴더 보이는 위치에 바로 연결하면 되는거고 ,PATH지정은 %JAVA_HOME%\bin 이렇게 새로 추가해주면 됨</p>
<p>bin 폴더 속의 javac 프로그램 ==> .java 파일을 .class 파일로 바꿔주는 컴파일러</p>
<p>bin 폴더 속의 java 프로그램 ==> main메서드를 실행하는 명령어를 처리하는 프로그램</p>
<p>jar 프로그램 ==> java 파일을 압축하고 해제하는 프로그램, 압축하면 확장자도 jar가 됨</p>
<p>javadoc 프로그램 ==> 작성한 java파일의 정보문서를 만드는 도구 = 아직 모름</p>
<p>지금 보니까 자바 개발용 프로그램이 없으면 내가 손으로 코드를 다 치고 컴파일후 실행까지 명령프롬프트로 전부 입력해야함</p>
<p>1995년 java 최초 발표</p>
<p>2000년 중반 이후 세계에서 가장 많이 쓰임</p>
<p>2009년 오라클에 인수 합병</p>
</details>

## [10월 16일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>현재 백엔드로서 DB단계에서 가장 중요한 개념은 CRUD(DML)</p>
<p>CRUD = DML을 하는 방법을 의미, 데이터 조작을 하는 방법, Create, Read, Update, Delete</p>
<p>CRUD ==> DBMS(오라클,mySQL,mariaDB)에서 DML을 하는 방법</p>
<p>서버는 CRUD를 처리하고 클라이언트에게 전달하거나 하는데, CRUD가 너무 많으면 속도가 느려지거나 서버가 응답하지 않음.</p>
<p>백엔드 개발자는 CRUD를 처리할 때 서버의 성능까지 감안하는 포트폴리오가 들어가는게 좋다.</p>
<p>정형테이터를 테이블 정해서 집어넣을 때 - 어떤 데이터(엔티티)를 집어넣야 하지? - 데이터의 테이블은 어떻게 정하지? - 엔티티관계도는 어떻게 만들어져야하지? - 어떻게 만들어야 CRUD가 원활하지?</p>
<p>얘를 들어 쇼핑몰의 데이터를 집어넣을 때 고려해야 할 것
테이블 ==> 저장할 대상(entity, 엔티티) - 게시판, 회원정보, 상품정보, 상품후기
항목(column) ==> 대상의 정보
주문 테이블에선 회원정보 id랑 상품정보 id를 전부 따와야겠지? ==> 근데 어떻게 가져오고 다뤄야 CRUD가 잘 이루어질까?</p>
<p>VO/DTO?? 이거 검색해보기</p>
<p>DCL에 대한 보충 - DB를 아무나 다루면 안되겠지? ==> 그래서 DB의 계정에 대한 계정관리, 백업복구 등을 DCL이라고 하고, 잘 안씀</p>
<p>실무에선 RDB(RDBMS, 관계형DB)가 85%, PK와 FK는 당연히 RDB에서 쓰는 것, 잘 알아야겠지?</p>
<p>그럼 데이터라는건 개발자가 전부 만들어서 입력하나? - ㄴㄴ 이미 있는 상품같은 경우는 엑셀같은 시트로 존재함. 새로운 id pw등만 새로 입력하는 것</p>
<p>oracle의 DCL의 경우 express edition(무료) / enterprise edition(기간제 유료) == mySLQ의 community(무료) / professional(기간제 유료) 와 같음</p>
<p>oracle을 교재로 실습하려면 DDL 77페이지의 id pw를 이용한 unlock 과정을 거쳐야 실습 가능.</p>
<p>실무에서 전부 명령어로 DB를 다루려고 하면 하루 종일 걸림 ==> 당연히 DBeaver같은 DBMS를 다루는 프로그램을 쓰는게 좋겠지? </p>
<p>DB를 다루는 script는 당연히 SQL만 존재하는건 아니지만, 본 수업에서는 SQL을 DB를 다루는 script로 이용할 예정</p>
<p>script - 명령어로 주저리주저리 쓰다(?)를 의미함</p>
<p>port번호는 DB locahost 오른쪾 : 번호 에서 확인가능, 현재 mySQL에서는 localhost가 3306이라는 port번호를 가짐. </p>
<p>현재 mySQL에서 만든대로 관리자 계정은 root에 1234고, 관리자 계정을 로그인하고 일반 유저 계정을 만들 수 있다.</p>
<p>관리자 계정 확인법은 현재 연결된 localhost 우클릭 - edit Connection(F4) 를 클릭해보면 볼 수 있다.</p>
<p>항목 동의어 = field, item, property, attribute</p>
<p>shop을 선택 후, SQL 버튼을 클릭한 경우, use shop자동 실행되어서 shop이 선택된 상태가 됨, 다른 db를 사용하려면, use db 명령어로 선택하기</p>
<p>DCL : create, alter, drop</p>
<p>create  user 'summer'@'localhost' identified by '1234';<br>
localhost에 id : summer, pw : 1234 라는 일반 유저 계정을 만들기, 연결은 따로 해야 함<br>
일반 계정으로 로그인하면 또 edit connection의 driver properties에서 allow public key retrieval 을 true로 바꿔준다.<br>
<br>
grant all privileges<br>
on *.*<br>
to 'summer'@'localhost';<br>
localhost에서 summer id에게 '*.*' - '모든 DB.모든 table' 에서 DML 권한 부여
</p>
<p>중간 복기 - 지금 문법도 나오고 오류도 나고 그러고 있는데 내가 기억해야되는건 DCL을 하는 방법이다. 관리자 계정에서 일반 유저 계정을 만들어야 하고, 따로 권한부여까지 해줘야 DB를 다룰 수 있다를 알고 있는게 중요하다. 권한을 특정 db나 table에서 줄 수 있고, 생성이나 추가 등의 특정 권한만 줄 수 있다는 것도 아는 것이 중요하다.</p>
<p>@ 양쪽에 ''가 빠진 버전이 존재하는데 mySQL 업데이트 여부에 따라가는 듯</p>
<p>DB를 만들 때 언어 설정이 기본으로 utf-8이 되어있는데, 이 DB에서 table을 만들 때도 이 설정을 그대로 상속 받는다.</p>
<p>짐작했듯이 column을 만들 때 varchar(100)으로 항목 데이터 타입 선언을 해주는건 글자 100개까지 쓸 수 있는 정형 데이터를 선언하는 것</p>
<p>이 때 char(100)의 형태로 선언할 수도 있는데, 차이점은 char는 공간이 변하지 않는다는 특성이 있다.</p>
<p>char(100) - 100개의 글자가 들어가는 변하지 않는 공간 설정, 계산 x, cpu부담 x<br>
varchar(100) - 100개의 글자가 들어가는 가변적인 공간 설정, 글자 갯수에 따라 공간 조절, cpu 부담 O</p>
<p>당연한 얘기지만 local이 아닌 다른 db와 DBeaver로 연결할 때는 인터넷이 연결되어 있어야 하고, 꼭 저장해야 mySQL같은 DB에 반영된다.</p>
<p>DBeaver를 다룰 때 조심해야하는 점인데, SQL문으로 한번에 만들 수 있는 query정도의 작업을 수행할 때마다 저장을 눌러주어야 함. 안그러면 오류남</p>
<p>DBeaver로 만든 SQL문을 쉽게 복사해오는 법(tabel 외에도 가능)<br>
table을 만든 경우, 해당 table 우클릭 - SQL 생성 - DDL - copy<br>
위 방법으로 SQL문을 가져와서 팀원에게 공유하거나, 다른 table을 만들 때 쉽게 설정을 바꾸는 등의 일을 할 수 있다.<br>
여기서 SQL문을 이해할 수 있어야 복사해온 SQL문을 다룰 수 있다.</p>
<p>며용 두개 이상의 column이 PK가 될 수 있다. 나중에 배운다고 함.</p>
<p>constraints 메뉴에서 PK말고도 Unique key, check 설정을 할 수 있다.
PK가 Unique와 not null 자동설정이라면 Unique만 설정해주는 Unique키가 있고, 일정 조건을 만족하는 데이터만 들어가는 check 설정도 가능하다.
이때 PK 설정을 SQL문으로 가져오는 것도 가능한데, alter문으로 시작하는 걸 볼 수 있다.</p>
<p>PK 설정 할 때 key이름을 바꿀 수도 있는데, 초기 설정이 primary라 이름이 바뀌면 primary key라고 부르지 않는진 모르겠지만 바꿀 수 있다.</p>
<p>PK를 설정하면 Table의 목차(index)를 자동으로 만들어준다.
db단계에서 indexes폴더를 보면 알 수 있는데, dn에서 데이터를 찾을 때 이 index를 따라서 쉽게 찾을 수 있다.</p>
<p>entity 관계도에서 보이는 정보는 각 테이블의 항목까지고, 내용이 보이진 않음. 이런 뼈대를 schema라고 한다. schema 설계가 여기서 나온 말이겠지?</p>
<p>alter가 schema를 바꾸는 설정이다.</p>
<p>FK 설정할 때 맨 밑에 보면 On Delete / On Update가 있는데, 해당 FK가 삭제될 때, 혹은 업데이트 될 때 실행내용이 적혀있다. default 값인 no action은 FK 내용이 삭제되어도 아무 일도 일어나지 않는다. 만약 no action 대신 삭제가 들어가면 회원탈퇴등의 FK삭제가 회원의 글 삭제까지 이어지는 것이다.</p>
<p>이제 엔티티 관계도가 아니라 ERD 관계도 (entity relationship diagram) 이라고 부른다.</p>
<p>오늘의 오류 - ppt 따라서 table이랑 column 전부 대문자로 만들었는데 table이 자동을 소문자 처리되면서 잠깐 ERD오류가 남. 껐다 키니까 괜찮아짐</p>
<p>데이터베이스 우클릭 - 도구 - Dump database(백업 의미) - default 값으로 start - default 값에 설정된 경로에 저장<br>
==> 데이터베이스의 DDL, DML SQL문 원본 파일이 만들어짐</p>
<p>DDL, DML이 포함된 원본 파일이 있으면 쉽게 생성 가능 - DB는 내 손으로 직접 만들고 - DB 우클릭 - 도구 - Restore database<br>
- 경로에서 SQL파일 찾아서 한번에 바로 만들어버리기</p>
<p>손으로 치면 쥰내 오래걸리는거 SQL파일이 있으면 금방 만들어 버렸죠? 요것이 요즘 프로그래밍 하는 방법.</p>
<p>tabel 우클릭 - 데이터 내보내기 - csv파일로 내보내기(제일 많이 씀) - 경로에 값 백업 csv파일 저장<br>
보통 table 단위로 값을 백업해두는데, 이 때 확장자가 .csv(Comma Seperated Valuse)파일임. 파일을 열어보면 닉값하는 걸 알 수 있음.</p>
<p>국가에서 https://www.data.go.kr/ 라는 공공데이터 포털을 만들어서 공공의 데이터를 제공하고 있다.<br>
이 포털에서 제공하는 데이터도 csv의 형태로 들어가있다. 나중에 프로젝트 진행하려면 필요하겠지?</p>
<p>DML의 데이터 삭제 관련<br>
Drop과 truncate와 delete from의 차이<br>
Drop ==> 테이블 스키마까지 싹 날림(복구x)<br>
truncate ==> 데이터와 저장공간을 drop(복구X, 저장공간 자체를 날려버리기 때문), schema는 건들지 않음<br>
delete from ==> 데이터만 delete(복구O, 로그 남김, 저장공간 에 null 채움), schema를 건들지 않음.</p>
<p>제약조건 설정도 SQL문에선 alter table 테이블명 ~~~으로 contraints 설정</p>
<p>show tables(table 이름입력 아님)과 desc ==> SQL문에서 show tables만 하면 항목까지만 보여주지만, desc(describe) 테이블는 schema의 구조까지 보여준다.</p>
<p>alter table student2 add constraint fk_st2 primary key (depart_id) = SQL문으로 PK 설정법</p>
<p>alter table student2 add constraint fk_st2 foreign key (depart_id) references depart2 (id) = SQL문으로 FK 설정법</p>
<p>테이블을 만들 때부터 PK,FK를 설정하려면 만들 테이블 명령어(id varchar(100)) 뒤에 primary key / foreign key이후 명령어를 적어서 쿼리 실행하면 된다.</p>
<p>schema를 건드리는 설정은 DDL을 하는 것인가?</p>
<p>이제 prduct table의 schema를 변경한다는 표현을 함.</p>
<p>table이 엑셀 시트 형태랑 똑같이 생겨서 그런지 csv파일을 엑셀로 열어도 열리긴 열림</p>
<p>테이블 우클릭 - 데이터 가져오기 - csv파일 탐색 해서 가져오면 되는데, 당연히 csv항목이랑 table column은 모두 동일해야 함 - 아니면 column 새로 생김</p>
<p>DML - insert into 테이블명('항목명') values('데이터') 로 넣는데 DCL이 허용하는 설정이면 null도 집어넣을 수 있다. 아니면 무조건 값 집어넣기</p>
<p>desc로 테이블 보면 schema만 보여줌</p>
<p>SQL문에서 select로 테이블의 column을 검색해서 가져올 때, column배치만 바꿔서 데이터를 꺼내오는 순서를 바꿀 수 있다.</p>
<p>datetime 으로 데이터 타입 선언을 하면 now() 를 넣었을 때 현재 시간을 가져온다.</p>
<p>테이블을 만들 때 아무것도 넣지 않았을 경우를 가정한 디폴트값 설정이 가능하다.</p>
<p>카페 게시글 번호 같은 단순 숫자에 한해서 auto_increment 적용가능<br>
column에서 not null칸 옆에 있는 체크리스트만 체크하면 됨, 해당 column은 꼭 PK여야 하고, null 값을 집어넣어야 한다.<br>
null값을 집어넣어도 숫자가 1부터 자동으로 들어가기 때문에 개체 무결성에 위배되지 않는다.</p>
<p>column 설정란을 보면 맨 오른쪽 탭이 commnet인걸 볼 수 있는데 여기에 '번호자동생성'등 주석을 달아놓으면 좋다.</p>
<p>증감연산자랑 초기화를 같이 쓰는 경우<br>
b = ++a; => a+1 하고 1 넣기 ==> ++연산자가 앞에 붙으면 =보다 먼저 계산됨<br>
b = a++; => b에 a넣고 1 더하기 ==> ++연산자가 뒤에 붙으면 =가 먼저 계산됨<br>
즉 ++a든 a++이든 a라는 변수에 1을 더 집어넣는 변수인데, b에 들어가는 값은 달라짐 왜? 2번같은 경우는 b에 a값을 할당하고 a변수에 1을 더한다 라는 느낌인거임
</p>
<p>AND랑 OR연산자 & | 이렇게 하나만 써도 인식 되는데 아마 javascript 문법이랑 같이 쓰려고 그냥 두개 써버리는 듯</p>
<p>비트 연산자 ==> 8bit 기준 '>>'오른쪽 n칸 '<<'왼쪽으로 n칸 '>>>' 이동하면서 0채우기 => 8bit면 왼쪽으로 한칸 이동하면 *2(제곱) 오른쪽은 /2(제곱)만큼 연산한게됨 + 비트 AND OR연산자도 & | 인데, true 대신 1출력하는게 다를 뿐</p>
<p>아 데이터 타입이 다른 변수 사이의 계산은 생각 안해봤는데 결과값이 어떻든 연산에 들어간 가장 큰 데이터 타입으로 바뀐다고 함.</p>
</details>

## [10월 17일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>데이터를 테이블에 집어넣을 때 FK가 없는 테이블부터 넣어주는 것이 좋다. FK가 있는걸 먼저 쓰면 참조 무결성에 위배되버림</p>
<p>mySQL에선 명령어 대소문자 구분이 없는데 oracle에선 명령어 대문자 사용을 권장함(오류남)</p>
<p>select distinct DEPTNO  from emp ==> emp table에서 DEPTNO행 값을 중복 제거하고 뽑을 수 있다 - 직급같은거 정렬할 때 도움됨</p>
<p>당연한 얘기지만 명령어는 테이블명으로 쓰면 안됨, 근데 order가 명령어라 주문 테이블 같은거 쓸 때 조심</p>
<p>select * from emp order by sal asc/desc ==> 오름차순, 내림차순 정렬 asc는 안써도 기본으로 오름차순 정렬이 됨.</p>
<p>select ename as '이름' ==> 테이블의 column의 이름을 바꿔서 값 추출해오기</p>
<p>여기 SQL에서의 instance는 항목에 들어간 실제 값을 의미한다. 원래</p>
<p>DML 45페이지를 보면 select 사용법 대부분을 알 수 있다, not and or != = 뭐 이런거 붙여서 where와 함께 조건을 만들 수 있다.</p>
<p>!= 연산자를 쓸 수 있는데 왜 not연산자가 따로 있음 ==> '='요 등호가 들어가는 조건이랑 !를 같이써야 되는 상황이 생길수도 있음.</p>
<p>table을 select하면 자꾸 table의 맨 앞 알파벳이 혼자 따로 뜨는데 이후 명령어에서 table이름 대신 e + .(접근연산자) 로 쉽게 접근 가능</p>
<p>or문이 너무 길어지면 in 문으로 대체 가능, between문으로 두 값 사이 의 값을 조건으로 넣을 수도 있음.</p>
<p>select * from emp e where ENAME like  '_L%' ==> ENAME table에서 앞에는 한글자(_) 뒤에는 무한대(%)의 글자를 조건으로 갖는 L이 들어간 항목 추출</p>
<p>select * from emp e where ENAME like  '%AM%' ==> 동일 table에 앞뒤로 무한대 글자</p>
<p>select에 table column이 두개들이가는데 보통 앞쪽이 보여줄 column, 뒤쪽이 조건 등이 되는 column이 되는 듯 </p>
<p>DML PPT에 CRUD명령어롤 쓸 수 있게 정리문제 있는데 이거 명령어 안보고 적어보기 하면 기억 잘 날듯.</p>
<p>select 문법에서는 select column from table ~~ 인데<br>
update 문법에서는 update table set column ~~ 으로 주 명령어 뒤부터 순서가 뒤집힌 너낌?</p>
<p>아 지금까지 어느순간 서버랑 db를 동일시 했는데 서버는 사실 여러 클라이언트와 DB의 중계소 였던것임. 서버의 부담을 줄여준다고 하면서 계속 말했던거는 정적인 웹의 정보가 저장되고 정보를 클라어언트와 DB에 주고받는 웹서버으 부담을 말했던 것임</p>
<p>desc가 뜻이 두개임 ==> describe, descendent</p>
<p>select price * 5 as price5 from product3 p  ==> 아 이게 column이름 바꾸는 거 말고 무슨 의미가 있나 했더니<br>
price 값이 숫자인 경우 price * 5 한 값을 price5라는 새 column이름으로 쫘악 출려하는 거였음</p>
<p>위키독스라는 개사기 사이트가 있다, 책이 전부 무료인지는 모르겠는데 무료가 상당히 많다.</p>
<p>PPT DML심화를 보면 SQL도 함수가 있는데, 대부분 기억할 필요없고 체크 표시된 거 기억하면 됨 (LENGTH, CONCAT 같은거)</p>
<p>select concat(empno, ename) as '붙인글자' from emp e ==> 함수를 쓸 때 column자리에 같이 쓰면 됨</p>
<p>DML PPT 심화 18페이지 날짜 String 바꾸기 함수</p>
<p>select now() ==> 이렇게만 입력해도 날짜 출력해줌</p>
<p>select year(now()) ==> now에서 년도만 추출 가능, 같은 방법으로 년 월 일 시 분 초 전부 추출 가능<br>
애들은 year, month등이 기본 column명으로 들어가서 표시되기 때문에 as를 이용해서 이름을 바꿔줄 수도 있다.</p>
<p>select에서 column끼리 더할 때 null 값이 들어가 있는 경우 데이터가 사라지고 null 값이 됨. 문자, 숫자 마찬가지<br>
이걸 방지하기 위해 update를 쓰거나 NVL(comm, 0) - null값이 있는 경우 대신 0으로 바꿔주는 함수 를 이용해서 처리한 후 column끼리 더함<br>
위 방법은 더할 때 방지하는 거고, update문으로 미리 바꿔놓는 방법이 있다. update가 더 선호됨</p>
<p>이유는 아직 모르지만 조건문 넣을 때 null이면 = 를 써도 비교가 안됨(할당은 됨), is 쓰니까 됨</p>
<p>select empno, ename, job, sal,<br>
CASE JOB<br>
 WHEN ''' THEN SAL *1<br>
 WHEN ''' THEN SAL *2<br>
 WHEN ''' THEN SAL *3<br>
 WHEN ''' THEN SAL *4<br>
END AS '''<br>
FROM EMP<br>
SQL의 CASE문이 if 조건문이라고 생각하고, WHEN ~~ THEN까지가 조건, 이후가 실행을 보면 될 듯, as로 column이름 바꾸기도 가능하다는 것을 알아야 한다.</p>
<p>지금 그냥 CRUD쓰다가 함수 써서 자꾸 까먹는데 모든 함수에는 파라미터가 비어있어도 ()가 붙는다는 사실 기억하기</p>
<p>집계(그룹)함수 ==> 조건에 맞느 행을 여려개 묶는 것, sum count avg등의 함수를 쓰고, from table 뒤에 group by column 명령어로 묶을 수 있다.<br>
이렇게 gruoup by로 묶는 함수 뒤에 having 조건 이렇게 써서 조건에 맞는 행만 묶어줄 수도 있다.</p>
<p>group by / having은 세트메뉴에용</p>
<p>select는 무조건 column이름과 결과값을 함께 달고 나온다 엑셀 처럼!!!</p>
<p>UINION이라는 집함 함수가 있는데 잘 안씀, select문 사이에 들어가서 붙여주는 역할인데, select로 불러오는 schema가 동일해야 한다는 전제조건이 있다.</p>
<p>조인(join) ==> 집계 함수나 집함 함수가 같은 column만 출력하는데 반해 join 함수는 같은 기준을 만족하는 여러 테이블을 붙일 수 있다.</p>
<p>기준은 어떻게 만족하느냐? ==> 합쳐지는 테이블이 서로 관계성을 지닌(이름이 같거나 FK거나) column을 하나 이상 가지고 있어야 함</p>
<p>기준 없이 그냥 모아 놓는다? => 집합함수 / 기준을 가지고 모아 놓는다? => inner join, outer join</p>
<p>join은 문법이 3가지 정도 있는데, 최근에 간단한 문법이 나왔기 때문에 이 문법을 쓰는 것이 좋다. ==> 테이블 맨 앞 알파벳만 따오는 거</p>
<p>joing의 문법 3가지가 이 inner join, left join, right join이다. 척 봐도 알겠쥬?</p>
<p>column의 값을 비교할 때의 고찰 ==> 기본적으로 조건에 해당하는 행을 가져온다는 느김, 그 중 일부 column값만 줄 수도 있고 그런 것이다.</p>
<p>select d.DEPTNO, d.DNAME, e.ENAME, e.JOB<br>
from dept d, emp e <br>
where d.DEPTNO = e.DEPTNO<br>
기준을 만족하지 못하는 (서로 겹치지 않는 값)을 없애고 join
</p>
<p>select d.DEPTNO, d.DNAME, e.ENAME, e.JOB<br>
from dept d <br>
left outer join emp e<br>
on (d.DEPTNO = e.DEPTNO)<br>
left니까 dept 라는 테이블에서 가져온 column은 모두 표시하는 상태(a)에서 emp 테이블 중 on의 조건을 만족하는 emp의 column만 a에 추가해서 출력
</p>
<p>self join도 inner join 처럼 기준은 where문으로 쓰고, 내가 추출한 테이블에 내 테이블 값을 붙이고 싶을 때 씀, 잘 안씀</p>
<p>SQL을 3가지로 구분 - DDL, DML, DCL</p>
<p>DML로 할 수 있는 조작 4가지를 부르는 말 - CRUD</p>
<p>DML의 조작 4가지에 해당하는는 각 SQL 문<br>
Creat - insert / Read - select / Upadate - update / Delete - delete</p>
<p>DDL의 create와 DML의 CRUD의 create 헷갈리지 않기. DDL은 schema, DML은 데이터의 생성을 의미하므로 DML의 경우 insert를 써야 함.</p>
<p>정형데이터 베이스란? = column이 정해진 데이터베이스. 반정형은 column 없이 데이터만 존재하는 것</p>
<p>제약조건이란? - table의 column에 걸어놓는 규칙 같은 것으로, PK, Unique key등을 설정할 수 있다.</p>
<p>constraints도 schema에 해당함</p>
<p>PK를 왜 설정하는가? - 해당 table에서 id로 데이터를 구분해서 원하는 데이터만 가져오기 위함</p>
<p>FK를 왜 설정하는가? - 특정 column에 특정 데이터만 들어가게 하기 위함, 참조무결성을 가진다.</p>
<p>저장할 대상을 부르는 말 - 개체(entity)</p>
<p>varchar와 char의 차이 - 데이터가 들어가는 저장 공간의 변동성에 차이가 있다. varchar는 공간이 유동적이고, char는 고정적이다.</p>
<p>join을 왜 하는가? - 공통된 기준을 만족하는 column을 가져와서 합친 결과를 출력하기 위함</p>
</details>

## [10월 18일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>오늘의 뽀인트 - JDBC (JAVA DB Conncetivity), 자바와 DB를 연결하는 방법</p>
<p>C+=, C#등은 ODBC (Open DB Connectivity)라고 부름</p>
<p>update로 데이터 지우기 vs delete from으로 데이터 지우기<br>
update는 column(cell)단위 삭제 가능, dele from은 행 한개를 전부를 지워버림, update로 지울 때 set '' = null의 방식으로 지움</p>
<p>면접 말장난으로 개체와 객체 비교(object, entity 비교) 질문이 좀 나옴, 신입은 헷갈릴 수 있다고 생각하는 것 같음</p>
<p>행 = record = row</p>
<p>개채 = entity != instance</p>
<p>db에서의 instance = 실제 저장되는 데이터 ==> instance row 3개 만들었다 등으로 표현 가능</p>
<p>java에선 object랑 instance가 같은 개념이었어서 여기서도 같은 개념인지 헷갈렸다.</p>
<p>프로그램은 보통 3단계로 나뉘어진다 - 3tier(UI - java - DB) 더 검색해보기ㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣ<br>
Presentation Layer - 표시화면, UI를 표시하고 클라이언트에서 데이터를 입력받거나 요청을 받음<br>
Application Layer - 구동 단계, 중계(?)<br>
Data Layer - 데이터를 담은 단계, 보통 DB<br>
</p>
<p>당연히 java랑 SQL이 연결되어야 db를 다루겠지? 근데 jdk 4500개 중엔 그런 클래스가 없엉, 그럼 mvn에서 구해와야겠지?</p>
<p>지금 쓰는 mySQL이 8버전이라 mvn에서 받는 mySQL connector도 8버전을 받아야 함, 지금은 8.0.31 버전 jar로 받음</p>
<p>이제 3단계 프로그램을 ui부터 만들기 시작할건데 jdbc ppt 48페이지부터 시작하기</p>
<p>몰랐던 기능 ==> eclipse에서 교체하고 싶은 단어가 여러개면 해당 단어를 블럭잡고 ctrl + f로 전부 바꿀 수 있다.</p>
<p>.setopaque = j기능 투명도 설정</p>
<p>java로 회원가입 버튼 만들고 id 입력창 만들고 해서 jframe을 만드는 일련의 과정이 presentation layer단계 UI 만ㄷ드는 과정이라고 할 수 있다.</p>
<p>프로그래밍 언어 중 JAVA를 이용해 DB와 연결하는 순서를 JDBC 프로그래밍 4단계라 하고, 네트워크 연결이므로 4단계 전부 try - catch문으로 감싸준다.</p>
<p>사용할 드라이버 설정 단계 => import를 이용해서 클래스를 가져오는데, 그 클래스가 연결시켜주는 기능이 있어서 connector, driver라고 부른다.</p>
<p>모든 프로그래밍 언어는 DB와 연결하는 순서가 동일함 - jdbc ppt 28페이지<br>
1. 사용할 드라이버 설정(커넥터 설정, import) - import하는 클래스가 db와 연결시켜주는 역할이라 driver라고 부름<br>
2. DB연결 (DB 로그인) - url (ip + port + db명) - id, pw 일치<br>
3. SQL문 생성<br>
4. SQL문 전송<br>
어떤 언어든 위 과정을 거쳐서 DB와 UI를 연결한다.
</p>
<p>1단계 - jdbc p28<br>
처음보는 Class.fromName("com.mysql.jdbc.Driver"); 라는 처음 보는 형태로 연결함<br>
</p>
<p>2단계 - p31<br>
String url = "jdbc:mysql://localhost:3306/shop?useUnicode=true&serverTimezone=Asia/seoul";<br>
              방식  DBMS   local여부:port db이름   언어설정        서버<br>
String user = "root";<br>
String password = "1234";<br>
Connection con = DriverManager.getConnection(url, user, password);<br>
연결을 바꾸고 싶으면 url정보를 바꾸면 된다. Connection은 sql에 들어있는걸 사용한다.<br>
지금 1번에서 연결 한거, 2번에서 연결한거 전부 try catch문에 포함되어있어야 한다. catch뒤에 들어가는 오류에 2단계도 포함되면 된다.
</p>
<p>3단계<br>
String sql = "insert into member values ('star', '1234'. 'star', '011')";<br>
PreparedStatement ps = con.prepareStatement(sql);<br>
이런 방식으로 sql문을 수기로 작성한다. 당연히 컴퓨터는 이걸 바로 sql문으로 해석하지 못하기 때문에, 변수를 SQL문으로 바꾸는 클래스에 집어넣는다.<br>
.prepareStatement메서드를 써서 String을 SQL문으로 바꾸고, SQL문 변수 타입에 할당한다.<br>
</p>
<p>4단계<br>
ps.execute();<br>
초간단. con의 연결정보와 sql의 SQL문을 전송하기만 하면 됨.
</p>
<p>DBeaver에서 SQL문을 쓸 때도 마찬가지지만, url 단계에서 어떤 db를 쓸지 설정해줘야 함.</p>
<p>DAO (Data Access Object) ==> 자바의 DB 처리 담당 클래스, CRUD 하는 클래스</p>
<p>DTO, VO (Data Transfer Object, Value Object) ==> 데이터 전달 담당 클래스, 데이터를 DB전달하기 위해 가방에 묶는 클래스</p>
<p>위 4단계를 포함하는 클래스를 static main 빼고 다른 main 클래스와 연동시켜서 사용할 수 있다.<br>
클래스에 메서드를 집어넣고 메서드 파라미터를 통해 다른 클래스의 값과 연동시켜야한다.</p>
<p>String sql = "insert into member values (?,?,?,?)";<br>
			PreparedStatement ps = con.prepareStatement(sql);<br>
			ps.setString(1, id); // 물음표 1번에 id 값을 넣어줘!<br>
			ps.setString(2, pw); // 물음표 2번에 pw 값을 넣어줘!<br>
놀랍게도 ???? 명령어가 미리 만들어져 있음.<br>
ps가 연결정보와 sql문의 정보를 가진 상태에서 setString메서드의 파라미터를 이용하면 (n번째 물음표, 파라미터 값) 으로 물음표 자리에 값을 넣을 수 있다.
      </p>
<p>UL에서 입력한 값을 포장(DTO, VO) - DAO(jdbc 4단계포함)클래스로 DB에 데이터 전달</p>
<p>이렇게 해서 memberDAO.insert 메서드를 만들었는데, 같은 방식과 SQL문 수정을 통해 나머지 CRUD도 만들 수 있다.</p>
<p>당연히 이 긴 코드가 기억나지 않을 테니 jbbc 4단계를 외우는게 중요하겠지?</p>
<p>지금은 파라미터로 전달하는 변수를 일일이 선언하고 파라미터에 집어넣지만, 실제 프로그래밍에서 그러면 너무 오래 걸래겠지?<br>
실제 웹에서 프로그램이 동작할 때도 쫘악 입력되는게 아니라 이 값들이 들어있는 가방(DTO,VO)이 파라미터로 전달된다. 내일 배울 예정</p>
<p>회사의 작업 순서<br>
프로젝트 주제 선정 ==> 요구사항 분석 ==> DB구축 ==> 화면구현 ==> DB처리</p>
<p>오늘은 손으로 직접 모든 코딩을 하나씩 다 해봤는데 jdbc 단계별로 처리해주는 라이브러리가 매우 많음.</p>
<p>드라이버 설정 - db에 연결(DAO) - SQL문 생성 - SQL문 전송
Data Access Object
CRUD
autoincrement가 설정된 column 제외한 SQL문을 작성하거나 그 자리에 null값을 넣고 SQL문 작성
?
</p>
</details>

## [10월 19일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>VO (Value Object) 는 테이블 항목에 맞추어 만들어 놓음.</p>
<p>한 테이블당 한 개의 DAO와 DTO(VO)가 있어야 한다.</p>
<p>jdbc(4단계)<br>
DBCP(2단계)<br>
mybatis(sql 한 줄, 대세) 85% / JPA (sql안씀, 자바로 작성) 15%</p>
<p>jdbc 클래스는 프로그램이 끝나도 사라지지 않음. f.dfault..exit 뭐시기 처럼 종료 명령어를 넣어줘야함<br>
jdbc클래스로 만든 모든 객체에 .close() 메서드를 붙여주어야한다. con.close(), ps.close 처럼</p>
<p>ps.execute(); = 보내고 끝 / ps.executeQuery(); = 보내고 다시 받아옴, 필요하면 변수에 할당해야겠지?</p>
<p>ps.executeQuery(); 로 select한 결과를 받아올 땐 테이블로 받아온다. 이 때 결과값이 없어도 테이블 column은 받아온다. 그래서 resultset으로 판단해야함</p>
<p>ResultSet table = ps.executeQuery(); 이렇게 할당하는 것처럼 보이는데 Resultset은 테이블 값이 있는지 판단.</p>
<p>table.next() 라는 메서드로 현재 커서(cursor)가 가리키는 테이블 행 안에 데이터가 있는지 판단. boolean값 반환
주의할 점은 한번쓰면 커서가 다음 행으로 가기 때문에 한 줄만 출력하려면 한 줄만 써야함.</p>
<p>그럼 데이터 가져오는 건 알겠어, 어떻게 java에서 보여줌?<br>
==> resultset으로 만든 table.getString("column 이름"); 을 변수에 따로 할당해서 출력하거나 가능</p>
<p>출력할 때 왜 DAO에 출력문을 넣으면 안되나용? ==> DAO에는 DB관련 처리만 들어가야함, 출력문은 UI역할이다.<br>
브라우저나 다른 클라이언트도 마찬가지로 DAO UI역할이 나뉘어 있기 때문에 다른걸 다 수정할게 아니면 통일시켜야 한다.</p>
<p>resultset으로 만든 변수(?)도 return하면 편할텐데 왜 그걸로 전달 안하고 굳이 .getString();으로 꺼낸 데이터를 전달하지?<br>
이것도 마찬가지로 DB관련 처리를 하는 메서드 내지 명령어이기 떄문에 DB처리 단계에서 써야지 UI까지 넘어가면 안됨. return하면 넘어가버림
</p>
<p>가방(VO)은 어찌 설정하오 - main없는 클래스로 만들고 변수 값 선언 후, 뺄 메서드는 getId, 넣을 메서드는 setId 메서드 이름 작성</p>
<p>넣는 메서드는<br>
public void setId(String id) {
		this.id = id;<br>
	}</p>
<p>하나씩 꺼내는 메서드는 <br>
public String getID() {<br>
		return id;<br>
	}</p>
<p>변수가 선언된 상태에서 Source - generate getters and setter 하면 위 메서드들이 전부 만들어짐</p>
<p>위 메서드들이 들어간 상태로 저장하면 짜쟌 가방 완성 가방은 개쉬움. 문법 잘 살펴보면 가방이 어떻게 동작하는지 알 수 있음.</p>
<p>db의 가방 같은녀석은 (이미 기방임) resultset인거고 UI쪽의 가방은 getter setter를 이용한 내가 만드는 클래스</p>
<p>UI에서 집어넣을 땐 가방의 setter 메서드를 쓰고, 파라미터의 변수 선언은 가방 클래스 이름, DAO에선 getter 메서드로 가방에서 꺼낸다.</p>
<p>.close 명령어는 네트워크가 연결된 프로그램 종료 후 끊어지지 않은 상태의 연결을 인위적으로 끊어내는 명령어. DB관련 메서드에 모두 적어주기</p>
<p>이렇게 DAO VO 만들고 나서 DAO의 메서드는 void가 아니라 return까지 해서 확인창 까지 띄워주는 형태로 적용하는 게 좋다<br>
그냥 return 처리는 크게 어렵지 않은데 executeUpdate를 까먹을 듯. 이거 값이 1이면 제대로 바뀐거고, 아니면 바뀌지 않은 것.
</p>
<p>ORM (Object Relationship Mapping) => 테이블 row 한 줄 처리 하나 당 object 하나<br>
object 하나로 rdms의 row 하나를 처리하도록 mapping 시켜놓음을 의미한다.
</p>
<p>DAO(Data Access Object) DTO(Data Transger Object = Value Object)
DAO db처리, crud 담당 / 데이터 포장 등 처리 담당 
resultset / ORM(Object Realtonal Mapping)
table
항목 값
항목
resultset으로 받은 테이블에 값이 들어있는지 판단해주는 메서드
JDBC ==> 드라이버 설정 - db연결 - SQL문 작성 - SQL문 주고받기
conncetion - SQL을 담는 클래스 
preparedstatement - SQL을 나타내는 클래스
네트워크 연결 시 외부위 자원을 연결하는 불안정한 상황에서 발생할 수 있는 런타임 오류 방지
String "100"을 int 100으로 변경해주는 메서드
화면 UI, application layer(구동 단계), DB 단계
</p>
<p>자바 API랑 라이브러리는 같은 의미임</p>
</details>

## [10월 20일 ](#top)
<details>
<summary>오늘 배운 것</summary>
<p>코드 리팩토링 ==> 코드를 더 좋은 코드로 변경하는 과정</p>
<p>DAO를 얘로 들면 모든 메서드가 동일한 과정을 거치는 jdbc 1,2단계는 생성자 메서드로 넣고, 나머지 부분만 메서드들에 집어넣으면 좋다.</p>
<p>import 선언과 new로 할당하는 것. 참조형 변수 선언에 관한 것.<br>
new로 할당하는 순간 heap영역에 변수 값의 자리가 생긴다. 이 자리의 주소를 가지는게 변수 선언 시 생성된 변수이름.
</p>
<p>메서드의 구분을 전등 스위치와 밥솥 버튼 정도로 이해할 수 있겠다. return의 여부</p>
<p>메서드의 결과를 콘솔에만 찍겠다 - void / 결과 값을 가지고 무언가 하겠다 - return</p>
<p>try catch(예외처리)가 필요한 런타임 오류가 발생할 가능성이 있는 경우 ==> 네트워크, 파일, CPU, DB에 연결할 때.</p>
<p>10/0 같은걸 실행한다고 했을 때, 문법에 오류는 없다. 왜? -> 그냥 나눗셈이거덩. 근데 사실상 나누기가 불가능해서 런타임에서 오류 발생<br>
이런 오류가 위 예외처리가 필요한 상황처럼 발생함. 이런 오류가 발생해도 잠깐 접어두고 다음 코드를 실행할 수 있게 해주는게 try-catch인 것이다.</p>
<p>catch문의 파라미터가 Exception e 이렇게 되어있는건 모든 예외사항을 처리한다는 의미<br>
이 파라미터에 다른 값을 넣음으로써 오류의 형태마다 다르게 예외처리가 가능함</p>
<p>예외처리 파라미터<br>
      catch (ArithmeticException e1) { ==> 수학연산 예외처리<br>
			e1.printStackTrace();<br>
			System.out.println("수학연산 에러 발생함");<br>
		} catch (ArrayIndexOutOfBoundsException e2) { ==> 배열 인덱스 예외처리<br>
			e2.printStackTrace();<br>
			System.out.println("배열 인덱스 에러 발생함");<br>
		} catch (Exception e3) {<br>
			e3.printStackTrace();<br>
			System.out.println("기타 에러 처리");<br>
		}<br>
try 이후 catch문을 if else문처럼 이어붙이고 에러 형태에 따라 다른 예외처리를 할 수 있게하는 코드<br>
이것도 if처럼 순차적으로 실행하기 떄문에 Exception을 넣으려면 다른 조건을 넣고 마지막에 넣어야한다.
    </p>
<p>요오옥시 내가 생각한대로 catch문도 if문처럼 자동 break 기능을 가지고 있었던 것이다!!!</p>
<p>catch의 처리를 try catch문이 들어간 메서드가 아니라 그 메서드를 부른 클래스가 하게 만들고 싶다.<br>
==> public void call() throws Exception {}<br>
==> 이런 형태로 메서드 생성부터 throws 옆에 예외처리하고 싶은 메서드를 집어넣어서 부르는 클래스가 처리하도록 할 수 있다.
</p>
<p>예외처리를 throws로 떠넘기게 되면 try catch 문을 불러온 main에서 작성하는 방법으로 처리할 수도 있다.</p>
<p>충격 main 클래스조차 throws로 떠넘길 수 있다. 불러온 곳에서 처리하는거라 main을 불러온 JVM까지 떠넘기는데, 이러면 기본 오류 문자만 출력됨.</p>
<p>try catch를 처리할 방법 => 1. 던질까? / 2. 내 메서드에서 처리할까?</p>
<p>메서드를 호출할 땐 메서드랑 매개변수까지 보이쥬?</p>
<p>DAO 리팩토링 할 때 SQL문 작성 전 1, 2단께는 모든 메서드 공통, 이 1,2단꼐들을 생성자 메서드에 집어넣으면 중복을 줄일 수 있따.<br>
생성자 메서드에 집어넣을 때 Connection con등 변수가 지역변수가 되지 않게 자리 배치를 잘 해주어야 한다.
</p>
<p>지금 알게 된 점. DAO를 이용해서 DB 테이블에 값 집어넣을 때 PK에 auto increment가 설정되어 있으면 PK값을 어떻게 넣든 마지막 row 밑에 추가되는 형식으로 테이블에 값이 들어간다는 걸 알게 되었다.</p>
<p>여태까지 멤버변수랑 전역변수 등을 선언할 때 public만 붙이거나 했다. 이 명령어를 붙여야 어떤 범위에서 이 변수 접근할 수 있는지 설정할 수 있다.<br>
public은 어디서든 이 변수를 찾을 수 있다는 걸 의미하는데, 좀 더 좁은 위치를 지정하는 명령어들도 존재한다. 이 명령어들을 접근제어자 라고 부른다.</p>
<p>접근제어자<br>
public(+) = 프로젝트 내에서라면 '어느 곳에서든' 접근 가능.<br>
protected(#) = '다른 패키지'도가능한데, 대신 '상속'으로만 접근 가능.<br>
default(x, 아무것도 안쓴 것) = 이 클래스가 속한 '패키지'내에서만 접근 가능.<br>
private(-) = 이 '클래스' 내에서만 접근 가능<br>
이렇게 4종류가 있긴 한데 자주 쓰는건 public이랑 default를 자주 씀.
</p>
<p>범위 public > protected > default > private</p>
<p>범위야 안헷갈리는데 protected와 default가 헷갈릴 수 있음. 그냥 default에 '다른 패키지 상속'이 추가된게 protected라고 기억하기</p>
<p>접근제어자라... 좀 간지나는 말인 것 같군</p>
<p>private는 보통 코드를 갖다 써도 내부적으로 어떻게 구성되어있는지 오픈하고 싶지 않을 때 쓰게 되는 접근제어자이다.</p>
<p>클래스의 생성자 메서드에 private를 붙이면 다른 클래스에서 new로 객체를 만들 수 없음. ==> 그럼 왜 함?, DBCP에서 배울 예정</p>
<p>DBCP libary란? ==> DB Connection Pooling, 서버가 감당 가능한 연결이 1000개라고 예를 들면, 연결이 1000개를 넘지 않도록 관리해주는 방법</p>
<p>Connection pool<br>
dbcp ppt 5페이지를 보면 너낌이 DAO랑 DB사이에 connection pool이라는 곳에 connection이 모여있다.
이 connection이 서버에 감당 가능한 연결 1개를 의미하는 것 같다. 명령어에 Connection con이 연결 한 개 되는듯.
DAO에서 insert를 실행하면 connection을 통해 insert가 진행된다. 이 과정을 process라고 부른다. 
물론 insert말고도 여러가지 process가 있겠지? 이 여러가지 프로세스를 실 단위로 잘라서 진행하는 걸 thread라고 부른다.
보통 프로그램을 진행할 때 process하나를 다 완료하고 진행하는 것이 아니라, thread단위로 조금조금씩 여러 process를 진행한다.
아직은 안배웠지만 connection에 이 therad 단위로 진행할 수 있도록 해주는 부품이 있다.
</p>
<p>DBCP libary는 jdbc에서 1,2단계를 담당해주는 녀석이다.</p>
<p>mvn에서 DBCP를 찾으면 제일 많이 쓰는건 Common dbcp인데 코드가 비공개라 내부를 들여달 볼 수 없음.</p>
<p>대신 간단한 교육용 dbcp파일을 다운로드 폴더에 받아놓음</p>
<p>이 dbcp파일의 Vector에 connection을 여러개 만들어주고, driver, url, user, password들을 커스터마이징 한다.</p>
<p>getconnection, freeconnection으로 연결을 하고 끊고 등을 하면서 connection을 일정 수준으로 관리하고 있다<br>
이제 connection을 가져다 쓸 때 getconnection 메서드를 써서 이어주고, 끊을 때 freeconnection 메서드로 끊어준다.
</p>
<p>jdbc 1,2 단계를 대체할 때, try문으로 감싸진 상태여야한다. catch문은 그대로 두고 try문 내용만 지워주고 시작한다.</p>
<p>DBConnectionMgr dbcp = DBConnectionMgr.getInstance();<br>
con = dbcp.getConnection();<br>
여기까지만 작성해주면 1,2단계 대체 완료 ㄷㄷ<br>
주의해야 할 점은 DBConnectionMgr dbcp 얘는 전역변수로 바꿔줘야겠지?</p>
<p>dbcp.freeConnection(연결 관련 변수 전부); -- 이거를 catch 직전 try 마지막에 집어넣으면 연결 해제하고 connection 자원 다시 가져오는거임</p>
<p>db에 connection으로 연결할 때 통로를 새로 하나 여는 느낌인건데, dbcp를 안쓰면 이게 끊어지지도 않고 남아있음.<br>
심지어 새로 통로를 열 때 기존에 열려있는 통로를 쓰는게 아니라 새 통로를 열어벌임.<br>
dbcp를 써야 통로를 닫아줄 수도 있고, 기존통로 대신 새 통로를 여는개 아니라 기존 통로를 이용할 수도 있다.</p>
</details>

## [기본 양식](#top)
<details>
<summary>일단 무지성하게 기록하다가 주말에 에쁘게 정리하기</summary>
<p></p>
</details>