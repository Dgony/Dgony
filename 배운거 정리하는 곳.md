# <a name="top">목록</a>
- [목록](#목록)
  - [기본 양식](#기본-양식)
  - [키워드 기억하기](#키워드-기억하기)
    - [컴퓨터공학](#컴퓨터공학)
    - [HTML](#html)
    - [CSS](#css)
    - [JavaScript](#javascript)
    - [JAVA](#java)
    - [취직 할 때](#취직-할-때)
  - [컴퓨터 과학](#컴퓨터-과학)
  - [9월 11일](#9월-11일)
  - [9월 12일](#9월-12일)
  - [9월 13일](#9월-13일)
  - [9월 14일](#9월-14일)
  - [9월 15일](#9월-15일)
  - [9월 18일](#9월-18일)
  - [9월 19일](#9월-19일)
  - [9월 20일](#9월-20일)
  - [9월 21일](#9월-21일)
  - [9월 22일](#9월-22일)
  - [9월 25일](#9월-25일)
  - [9월 26일](#9월-26일)
  - [9월 27일](#9월-27일)
  - [10월 4일](#10월-4일)

## [기본 양식](#top)
<details>
<summary>일단 무지성하게 기록하다가 주말에 에쁘게 정리하기</summary>
<p></p>
</details>

---취소선<br>
**두껍게**<br>
*기울임*<br>
~~취소선~~<br>

## [키워드 기억하기](#top)

### [컴퓨터공학](#top)
<details>
<summary ></summary>
<p>PCCP(Programmers Certified Coding Professiona, 코딩전문역량인증)</p>
<p>엥간하면 신입은 연봉 협상이 안되니까 회사 내규에 따르기. 도저히 받아들일 수 없는 연봉인 경우 다른 회사 찾기, 썡 신입의 경우 너무 작은 회사는 비추, 시니어가 그래도 있는 회사 추천</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</details>

### [HTML](#top)
<details>
<summary ></summary>
<p></p>
</details>

### [CSS](#top)
<details>
<summary ></summary>
<p></p>
</details>

### [JavaScript](#top)
<details>
<summary ></summary>
<p>자바 vs 자바 스크립트
서버에서 실행 vs 브라우저에서 실행
제임스 고슬링 vs 제임스 고슬링 사랑개
정적 타이핑 vs 동적 타이핑</p>
<p>자바 스크립트 코드
prompt () = 브라우저에서 () 함께 입력창을 띄우기
prompt로 받은 데이터는 일단 무조건 문자형으로 저장
confirm () = ()와 함께 '예,아니오'창 띄우기, 논리값 반환
alert () = 브라우저에서 ()와 함께 알림창 띄우기
변수는 RAM에 저장됨
변수 선언 = RAM안에 변수 저장 공간 만들기
let 변수 => 변수 선언(초기화 X)
let 변수 = 0 => 변수 선언 + 숫자형 데이터 지정(초기화 O)
let 변수 = '' => 변수 선언 + 문자 데이터 지정(초기화 O)
모든 컴퓨터 기본데이터 - 정수, 실수, 문자, 논리
JavaScript 연산자 => = - || && ? 등으로 처리, 언어 따라 연산자가 달라짐
쓰레기값 = 변수 선언 x, 변수 할당x, 그냥 값만 덩그러니 놓음
\n = 자바스크립트 줄바꿈 명령어
동적 타입핑 = 데이터 타이핑 유형이 동적으로 바뀜(let q= 11, q = '11')=> 이케하면 데이터 유형은 문자열이 됨.
parseInt(내용) = 내용을 정수형 데이터로 반환
parseFloat(내용) = 내용을 실수형 데이터로 변환
.tofixed(x) = 소수점 밑 x번째까지 출력
. = 접근 연산자

자바 스크립트에 내장된 객체, 자바랑 똑같다, 객체지향 코딩
여러 객체에서 나온 메소드를 사용해서 브라우저 사용
ex)객체명 세탁기
세탁기.급수하다()
세탁기.세탁하다()
세탁기.탈수하다()

window = 얘 객체는 하도 많이 써서 window. 안붙여도 실행 가능
.alert() = ()메시지와 알림창 띄우기
.prompt() = ()메시지와 입력창 띄우기
location
.href ="" = 주소로 바로 이동, 2황
history = 페이지 이동, 잘 안씀
.back = 이전 페이지 .foward = 다음 페이지
document = 자바스크립트로도 html속을 관여하는 기능
.write('') = body태그 안에 글쓰기. 태그도 ''안에 넣어야 작동함, 1황
객체 메서드가 요구하는 형태가 다름, = '', ('')등 잘 보고 쓰기</p>
<p>document.getElementById('n1').value => html문서 body 태그 안의 태그(element)중 id 'n1'을 가진 태그의 value를 가져오는 메소드</p> 
<p>let result = document.getElementById('result') 로 result에 html id result할당, 이후 result.innerHTML로 result라는 id에 접근하는 방법이 .innerHTML을 쓰는 정석인 것 같은데, 
직접 써본 결과 document.getElementById('result').value == result.innetHTML인 것 같음. 최근 브라우저에서는 그냥 id만 갖다 쓰고 .innerHTML만 붙여도 값을 할당해서 출력할 수 있음.</p>
<p>document.getElementById('result') && id.innerHTML 작성요령 => 위 코드 후 =''로 문자열 안에 body속 태그부터 작성 시작</p>
<p>let wordValue = document.getElementById('word').value;
result.innerHTML = wordValue => html 문서 속 id word의 값을 가져와서 wordValue 변수에 저장한 뒤 id result에 wordValue 값을 할당</p>
<p>`<script src='out.js'></script>` => js파일 링크 양식</p>
</details>

### [JAVA](#top)
<details>
<summary ></summary>
<p>JAVA
단축키
psvm, main = public static voide main(string[] args) {};
sout = System.put.println();

변수선언
String = 문자열 변수 선언 (ex, String name = "이건희")
char = 문자 1개 변수 선언
int = 숫자 변수 선언(21억이하)
long = 숫자 변수 선언(21억 이상까지 포함)
double = 실수 변수 선언(소숫점 포함) float = 실수 변수 선언(소숫점 포함하려면 마지막에 F 추가해야함)
boolean = 불린값 선언
final + 선언명령어 + 대문자(권장) => 상수 선언
위 명령어는 전부 자료형 변수 선언이라 변수 값 할당은 다시 해야함.
근데 재할당 되는거 보니까 let 변수처럼 선언한다고 생각하면 될 듯.
그냥 큰거 쓰면 되는거 아님? => 오류와 최적화 문제로 알맞은 자료형 사용해야함</p>
</details>
<details>
<summary>변수의 구분</summary>
<p>1. 변수에 들어가는 데이터의 종류에 따라 2가지로 구분<br>
변수에 들어가는 데이터 - 기본형 / 참조형</p>
<p>2. 변수가 선언되는 위치에 따라 2가지로 구분<br>
클래스 바로 밑에서 선언되어서 다른 클래스에서도 사용 가능한 전역변수, public을 달아줘야 함 <br>
클래스보다도 깊숙이 메소드나 함수 밑에서 선언되어서 그 클래스 안에서만 사용되는 지역변수</p>
<p></p>
<p></p>
<p></p>
</details>

### [취직 할 때](#top)
<details>
<summary ></summary>
<p>PCCP(Programmers Certified Coding Professiona, 코딩전문역량인증)</p>
<p>엥간하면 신입은 연봉 협상이 안되니까 회사 내규에 따르기. 도저히 받아들일 수 없는 연봉인 경우 다른 회사 찾기, 썡 신입의 경우 너무 작은 회사는 비추, 시니어가 그래도 있는 회사 추천</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</details>

## [컴퓨터 과학](#top)
<details>
<summary>PCCP(Programmers Certified Coding Professiona, 코딩전문역량인증)</summary>
<p>프로그래머스에서 발급하는 민간 코딩 자격증. lv.5까지 있다. 이거 요구하는 회사가 몇개 보이니까 따 두면 좋을 듯?</p>
</details>
<details>
<summary>컴퓨터과학은 인문학과 크게 다르지 않다</summary>
<p>컴퓨터
컴퓨터의 전신은 앨런 튜링의 튜링머신<br>
인간의 생각(주로 계산)을 대신 처리해주기 위해 태어남 인간의 판단과 결정에 의해 컴퓨팅의 방향이 정해짐<br>
컴퓨터를 인간의 보조 뇌라고 불러도 되지 않을까?<br>
그래서 컴퓨터과학을 인문학이라고 말하는 게 아닐까?</p>
</details>
<details>
<summary<>서버와 클라이언트/summary>
<p>서버 : 서브해주는 컴퓨터<br>
클라이언트 : 서버로부터 받아서 표현하는 컴퓨터</p>
</details>
<details>
<summary>브라우저가 가지는 기능</summary>
<p>http로 통신하기
HTML, CSS, JS 해석하기
JS의 개발 부품 가지고 브라우저 콘솔에서 개발하기
개발자 도구로 오류를 발견하고 고치기</p>
</details>
<details>
<summary>HTML, CSS, JavaScript</summary>
<p>웹 요소 배치, 웹 꾸미기, 웹 기능</p>
</details>
<details>
<summary>Cookie, session, cache</summary>
<p>쿠키 - 내가 들고 다니는 이용기록 수첩, 가는 곳마다, 입력하는 것마다 쥰내 기록함 (단점 : 보안 빈약함)<br>
세션 - 쿠키처럼 갈 때마다 기록하는데 서버에서 짧은 기한의 인식 키를 주고 서버에 쿠키를 키와 함께 전송해서 기록 (단점 : 과부하)<br>
캐시 - 가져오는 비용이 큰 데이터를 사용자 컴퓨터 혹은 서버에 잠깐 저장해두고 다시 찾을 때 빠르게 꺼내오는 방식</p>
</details>
<details>
<summary>클라우드 컴퓨팅</summary>
<p>쉽게 말하자면 데이터를 어떤 서버에 저장하느냐<br>
주로 크기가 맞춰진 개인 서버 (저장공간 문제)<br>
호텔식 서버를 운영하는 대기업에서 나눠준 클라우드 서버 (보안 문제)<br>
클라우드 컴퓨팅 서비스를 이용하면 비용 문제가 있지만, 블록체인, 운영, 관리, 하드웨어까지 전부 클라우드에서 관리해주는 서비스를 이용할 수도 있음.<br>
IaaS : 가상 하드웨어만 빌려서 내가 전부 구축 + 사용<br>
PaaS : 가상 하드웨어 + 가상 서버 이용, 소프트웨어만 내가 구축<br>
SaaS : 소프트웨어까지 전부 구축된 서비스 이용</p>
</details>
<details>
<summary>정적 웹 vs 동적 웹</summary>
<p>HTML, CSS, JS로 이루어진 웹이 클라이언트에 대해 어떻게 반응하는가<br>
정적 웹 : 개발자가 만들어놓은 HTML, CSS, JSP 세트를 그대로 가져와서 보여줌 (학교 홈페이지, 블로그 등)<br>
동적 웹 : 사용자가 접속할 때마다 데이터베이스에서 가변적인 데이터를 받아와서 자동으로 변하는 사이트, 실시간으로 변하는 페이지 등</p>
</details>
<details>
<summary>컴파일, 런</summary>
<p>컴파일 오류는 개발자가 코딩 과정에서 방지 가능<br>
런타임 오류는 try-catch문 등으로 방지<br>
컴파일(Compile) : 작성한 코드를 컴퓨터가 알아들을 수 있는 언어(C언어(?))로 번역해주는 과정. 이 때 생기는 문법 오류 = 컴파일 오류<br>
런(Run) : 컴파일 된 코드를 컴퓨터가 실행할 때 생기는 오류 = 런타임 오류<br>
이런 예외처리는 finally문 등으로 마무리(주로 서비스 종료 시)<br>
예외처리는 오류를 대충 묻어두고 가는 방법이라는 비판이 있기 때문에 오류를 철저히 분석하고 방지해야 될 때에는 부적합한 방법이다.</p>
</details>
<details>
<summary>GITHUB 이용</summary>
<p>코드의 버전 관리 프로그램<br>
Commit + 버전이름을 통해 버전 하나하나 백업하면서 작업하기 쉬움<br>
Branch를 이용해 메인 Branch 서브 Branch를 나눠서 코드작업 후 좋은 결과물이 나왔을 때 메인 Branch에 합치기도 가능<br>
기본적으로 올리는 모든 코드가 오픈된 오픈소스의 성지인 사이트기 때문에 남의 코드를 참고하거나 도움 받기 좋음<br>
내 코드를 비밀로 올리고 싶다면 일정 금액을 지불하고 비밀로 업로드 가능.<br>
commit - 작성한 코드 임시로 묻어두기<br>
push - 작성한 코드 git에 업로드하기<br>
branch - 현재 작성중인 평행우주 branch를 만들어서 작업하기<br>
init(.git폴더생성), reset, revert, branch, branch 이름, branch -d 이름, merge 이름, rebase 이름<br>
branch는 작성중인 코드의 변경사항만 기록하는거기 때문에 merge할 때 같은 파일 변경되어있으면 충돌해서<br>
여러 branch에서 같은 파일을 수정하는 것은 되도록 피해야 함. 그렇지 않으면 고통의 디버깅 과정을 거치게 될 것.<br>
merge는 병합 시 모든 branch의 기록을 남기지만 rebase는 현재 병합하는 branch에 한줄로 기록을 남김.<br>
git status = git이 주목중인 변경 항목 표시, .gitignore 파일과 함께 사용해서 파일 은닉 가능.<br>
원격 저장소에서 fetch, pull하지 않고 psuh할 때 에러가 날 수 있기에 fetch, pull후 push하기 (conflict 해결)</p>
</details>
<details>
<summary>MVC 웹 프레임워크가 뭐여?</summary>
<p>Model, View, Controller<br>
Model : 데이터베이스의 데이터를 저장, 불러오기, 형식 지정(식료품 꺼내와서 요리하는 주방장)<br>
View : HTML, CSS(플레이팅)<br>
Controller : JSP(매니저)<br>
즉 MVC 웹 프레임워크란 MVC라는 골격이 만들어져 있는 코드를 공유하는 사이트(JAVA에겐 Spring)<br>
라이브러리 - 살까지 붙여져서 만들어져 있음(코드, 모듈, 소프트웨어 등)<br>
프레임워크 - 골격만 있고 살을 붙이는 건 내 몫</p>
</details>
<details>
<summary>프로세스와 스레드</summary>
<p>프로세스 (Process)<br>
컴퓨터가 어떤 프로그램을 동작하는 일련의 과정<br>
프로세스마다 고유의 자원 할당<br>
동시적 : 코어 1 = 프로세스 1, 프로세서 하나가 돌아가면서 수행<br>
병렬적 : 멀티코어 = 멀티 프로세스, 즉 한번에 여러가지 프로세스 진행 가능<br>
스레드 (Thread)<br>
프로세스 진행 과정 속의 프로세스<br>
프로세스 속 한정된 자원으로 효율적으로 가동 가능<br>
다만 하나의 변수에 스레드 여러개가 동시에 개입하게 되면 오류 발생 가능</p>
</details>
<details>
<summary>동기와 비동기 프로그래밍 (Syncrocous vs Asyncronous)</summary>
<p>작성 순서대로 vs !작성 순서대로<br>
쉽게 말하자면 동기는 싱글코어 프로세스, 비동기는 스레드(Thread)와 같은 동작 방식 (ex. 자장면 배달하면서 빈그릇 가져오기)</p>
</details>
<details>
<summary>자바 파일과 자바 클래스 파일의 관계</summary>
<p>깊게 들어가면 자바 파일의 실행 과정에 있음<br>
자바 프로그래밍 언어로 파일 작성<br>
프로그래밍언어를 기계언어로 바꿔주는 소프트웨어인 자바 컴파일러로 파일을 컴퓨터가 읽을 수 있게 변경<br>
=> 자바 클래스 파일 생성<br>
이 과정에서 컴파일러는 자바 파일의 오류를 검사하고 JVM이 읽을 수 있는 bytecode로 변경<br>
JVM(Java Virtual Machine, 자바 가상 머신)은 bytecode를 해석해 해당 컴퓨터가 읽을 수 있게 변경<br>
자바 파일의 결과물 실행<br>
결국 1~4는 컴파일의 세부 과정이고, 5가 런 과정인듯. 자바 클래스 파일을 설명하기 위한 컴파일 과정분류? 한가지 더 컴파일러의 정체 = jdk 혹은 vscode 플러그인이 만들어주는 class 파일</p>
</details>
<details>
<summary>CDN</summary>
<p>Content Delivery Network<br>
온라인 콘텐츠 전송 방식, CDN을 쓰는 이유<br>
지리적 이점 - 원본 서버가 멀리 있어도 근처 서버에서 받아와서 빠름<br>
부하 분산 - 서버가 여러개라 한 서버에 부하가 몰리지 않음<br>
보안 기능<br>
웹 페이지 로딩 속도가 빨라지는 장점이 있음</p>
</details>
<details>
<summary>데이터와 정보</summary>
<p>데이터 = Fact, 내일 비가 옴<br>
정보 = 누군가에게 영향을 미치는 Fact, 비오니까 우산챙겨야지</p>
</details>
<details>
<summary>알고리즘</summary>
<p>정의<br>
알고리즘이란 어떤 작업을 수행하기 위해 컴퓨터에 내리는 명령을 순차적으로 나타낸 것(ex, 라면 조리법)<br>
결국 알고리즘을 만든다는건 자동화를 효율적으로 수행하기 위한 계획표를 세우는 느낌인것인가<br>
세부적인 코드를 짜는 건 프로그램 작성 시기에 해도 늦지 않으니까 계획표를 야무지게 세우는거지.<br>
라면 조리법으로 치면 '물 끓이기 - 수프 넣기 - 면 넣기'의 일련의 과정을 짜는게 알고리즘인거지.<br>
그래서 알고리즘에 대해 잘 안다는 말은 문제 해결 방법을 잘 안다는 말과 같다고 생각 할 수 있겠다.<br>
시간복잡도<br>
cpu를 얼마나 짧게 쓰는지, 코드가 잘 짜여 있어서 시간을 잡아먹지 않고 빠른 시간 안에 부하를 주지 않으면서 코드를 잘 실행시킬 수 있는지 - 알고리즘<br>
공간복잡도<br>
알고리즘 등의 코드가 실행 될 때 RAM의 공간을 잡아먹는 정도 - 자료구조</p>
</details>

## [9월 11일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>html(Hyper Text Markup Language) => 왜 Hyper일까? - text를 누르면 다른페이지로 가벌임;; 그래서 초월이란 의미의 Hyper, 
왜 Markup일까? - <>태그 안에 집어넣는걸 markup이라고 함</p>
<p>https://www.w3schools.com/html/html_colors.asp 여기서 HTML,CSS등 참고</p>
<p>질문을 zoom으로 하면 놓칠 수 있으니까 slack으로 질문하기</p>
<p>dm에 거부감 없이 질문하기, 교수님한테는 공부질문, ft한테는 설정질문?</p>
<p>대부분의 수업이 원론을 벗어나 실무에 쓰이는 기술 사용(ex, 데이터베이스-스키마설계)</p>
<p>카페에도 과목별로 정리된 형태로 볼 수 있음</p>
<p>윈도우에 리눅수가 들어가있는데 비활성화된 상태임</p>
<p>기술스택들 한번 검색해보기</p>
<p>내가 집중해야할 거 서버와 데이터베이스 + 프론트엔드 10%</p>
<p>프론트 쪽에서도 3,4일차의 js, jquery를 잘 알아두면 좋다.</p>
<p>이제부터 백엔드로서 나에겐 책은 사전이다.</p>
<p>이번주 내가 이해해야 할 목표</p>
<p>한 3개월차부터는 정보처리기능사를 준비해도됨. 배우는 내용이 유사함</p>
<p>정적웹과 동적웹이 동시에 보여지는 네이버 사이트를 설명해주심</p>
<p>고정된 데이터는 html, 스타일은 css, 기능과 외부 데이터를 끌어오는거는 js</p>
<p>클라이언트측 / 웹서버측(웹서비스 주는 서버 컴퓨터 + WAS), DB측</p>
<p>네이버로 예를 들면, 클라이언트가 네이버 첫 페이지 보여달라고 요쳥<br>
=> 서버에 요청하거나 받을 때, http(Hyper Text Transfer Protocol)라는 방법을 쓰기로 합의함<br>
=> 단순한 요청은(html), 네이버 웹서버가 클라이언트에 보여주고, 브라우저가 html대로 보여줌<br>
=> 복잡한건(java, 동적 웹 등) WAS를 통해 DB까지 찾아가서 데이터 보내줌<br>
=> WAS(Web Application Server)라는건 java로 DB처리를 가능하게 해주는 프로그램<br>
=> WAS는 DB에 줄 때 SQL, 받을 때 Resulset라는 방법을 통해 데이터를 주고받음</p>
<p>현재 html 5 버전 사용, w3c에서 http 사용 합의와 html5, css3 버전 사용 등을 합의함</p>
<p>IT 기초 용어집 훑어보기</p>
<p>단축키를 보통 snippet이라고 부르는 듯, 한국어론 코드 조각 모음</p>
<p>html쳤을 때 html:5 snippet을 사용하면 html의 기본 뼈대를 다 만들어줌</p>
<p>백엔드 개발자는 웹에서 개발자 도구를 많이 써서 오류를 잡음</p>
<p>html이 열리면, head제목과 속성을 따와서, body의 모양대로 배치하고, html이 닫힌다.</p>
<p>live server는 저장을 일일이 안눌러도 열린 브라우저에 파일 내용이 반영되는 프로그램</p>
<p><>속 태그는 소문자 대문자 구분 안하지만, 태그 속성은 소문자로 작성해야 한다.</p>
<p>테이블 실습 한번만 더 해보기</p>
</details>
<details>
<summary>HTML</summary>
<p>HTML은 Hyper Text Markup Language라는 의미로,<br>
Hyper - 초월하는 (다른페이지로 감)<br>
Text - 문자<br>
Markup - <>안에 집어넣는 문법<br>
Language - 등의 방법을 사용하는 언어다.<br>
웹페이지를 구성하는 언어로 선택되어있는데, 태그와 문자로 화면을 구성하고 화면에 표시된 문자로 다른 웹사이트와 연결된다.</p>
</details>
<details>
<summary>CSS</summary>
<p>CSS는 Cascading Style Sheet를 의미한다.<br>
계단식으로 적용되는 스타일 시트로, HTML, 즉 마크업 언어가 웹페이지에 어떤 특성을 가지고 어떤 모양으로 표시될 지 결정한다.</p>
</details>
<details>
<summary>JavaScript</summary>
<p>프로그래밍 언어로, JAVA와 흡사한 부분이 많은 언어이다.<br>
HTML은 웹페이지의 뼈대를 갖추고, CSS가 웹페이지의 모양을 만든다면, JS는 웹페이지가 동작하는 법을 담당한다.<br>
HTML의 각종 움직임이나 서버를 통한 데이터 전달 등의 역할을 JS가 맡는다.<br>
내가 알기론 프로그래밍 언어 중 JS만 브라우저가 인식할 수 있는 언어라 쓰일 수 있는 것으로 알고 있다.<br>
상당히 예외가 많고 허술한 불안정한 부분이 있는 언어지만, jquery등과 es6등의 문법으로 많이 발전하는 중이다.<br>
게다가 이상하게 크롬 브라우저에서 가장 빠른 언어에다가 브라우저에서 가장 오래 쓰인 언어라 점유율도 높다.<br>
물론 JS가 쓰이는 한계는 웹브라우저와 웹서버까지의 단계기 때문에 백엔드 개발자가 되어야하는 내 입장에선 조금은 알아둘 필요가 있다.</p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>
<details>
<summary></summary>
<p></p>
</details>

## [9월 12일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>HTML,CSS,JS 전부 필수지만 JS만 심화, 나머지 둘은 기본만 하기</p>
<p>JQUERY = JS랑 똑같은데 훨씬 짧게 만들 수 있음, 근데 그렇다고 JS를 안쓰는 건 아님.</p>
<p>오늘은 기필코 TDD방법론 알아보기</p>
<p>클라이언트측 브라우저는 프론트엔드 3총사만 해석할 수 있음. 그래서 그거 씀</p>
<p>HTTP의 특칭 - 무연결성 / 무상태성
무연결성 - 한번 요청, 한번 응답, 노 유지
무상태성 - 이전 연결이 다시 왔을 때 클라이언트마다 ID 부여해서 작업 수행</p>
<p>form, input, select, option, button</p>
<p>사이트 1개 = 프로젝트 1개 (ex: web01)</p>
<p><!DOCTYPE html> = 이 문서는 html임 하고 알려주는 거임</p>
<p>input 시리즈 다 한번 넣어보기</p>
<p>코드에 항상 주석을 쓰는 버릇을 들이기, 내가 써도 모를 수도 있고, 협업에 도움 됨</p>
<p>CSS 3 부터는 애니메이션도 적용가능, 우린 안쓰지만 ㅋ</p>
<p>ling + css로 head 안쪽 마지막에 집어넣어서 스타일 적용하기</p>
<p>언어마다 주석 모양이 다르다.</p>
<p>CSS기본 선택자, 가상 선택자, 속성 선택자, CSS사용법, DOM Tree란 무엇인가</p>
<p>기본 선택자 - 태그, 클래스, id</p>
<p>마지막 CSS정리문제 풀기</p>
<p>DOM Tree라는건?</p>
</details>

## [9월 13일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>객체지향 언어 = 부품 조립식 언어</p>
<p>띠요오오옹??? JS는 프론트엔드 개발자가 쓰는게 아니었따?? 백엔드였따???</p>
<p>JS 새삼 중요한 이유는 서버의 부담을 줄여줄 수 있는 방법이기 때문이다.
서버가 과부하 되면 결국 느려지기 마련인데 브라우저의 JS를 효과적으로 이용하면 서버의 부담을 줄여줄 수 있다.
그럼 백엔드 개발자는 어떻게 해야한다? JS를 효과적으로 이용해서 서버의 부담을 줄여줄 수 있는 능력을 갖춰야 좋은 개발자라고 말할 수 있겠지?</p>
<p>padding, border, margin => content를 안쪽에서부터 감싸는 테두리 설정</p>
<p>div의 위치 조정은 static, absoulute, fixed등으로 조정</p>
<p>padding 안쪽 여백, maring 바깥쪽 여백</p>
<p>float left, right 스타일 왼쪽 붙이기, 오른쪽 붙이기</p>
<p>이미지 대신 CSS를 쓰는 이유 => 마찬가지로 서버의 부담을 줄이기 위해</p>
<p>부트스트랩? 사이트를 만들어줄 수 있게 도와주는 프로그램.</p>
<p>w3y에서 부트스트랩 이용해서 css만 갖다 쓰거나 할 수 있음, 부트스트랩 링크를 긁어와서 head안에 붙이면 됨.</p>
<p>button 태그를 예로 들면 태그 안에 class="btn ~~"으로 클래스 지정만 해주면 버튼 css를 적용할 수 있음
어떤 클래스가 어떤css를 가지는지는 w3y 속 bootstrap5 tutorial tap을 보면 다 나와있음</p>
<p>부트스트랩이라는 이름의 가장 유명한 HTML,CSS,JS 라이브러리인 것</p>
<p>부트스트랩은 CDN(Content Delivery Network)라는 웹 컨텐츠를 온라인 상에서 전달하는 방식을 사용하는 라이브러리</p>
<p>부트스트랩 여러개 보면서 예쁜 사이트 만들어보기</p>
<p>코드를 전송할 때 엔터가 많이 있으면 서버에 부담이 커짐. 그래서 전송용 코드에서 엔터를 없애주는 프로그램이 있음</p>
<p>span, div</p>
<p>최종 포폴에 부트스트랩을 써보라는 말 난 말이야 말말말말말말말말말말말</p>
<p>자바스크립트 => jQuery(자바스크립트 쉽게 쓰기), Ajax(jQuery에서 외부사이트 통신)</p>
<p>Ajax를 이용해서 화면을 바꾸지 않고도(=비동기 통신) ID가 서버에 존재하는지 검사가능, 사용자의 위치에 따라 날씨 정보 출력 가능</p>
<p>입력값 유효성 검증 - 비밀번호나 id등이 규격에 맞는지 등 검사 => 서버의 최적화를 위한 브라우저 단계에서의 JS가동</p>
<p>JS는 CSS처럼 외부 파일의 id나 class를 이용해서 html에 접근한다.</p>
<p>JS의 실행은 브라우저에서 실시된다, 그래서 오류는 브라우저에서 확인해야한다 (개발자도구 - 콘솔)</p>
<p>JS를 html에서 연결하는 방법은 태그만 다를 뿐 CSS의 적용방법과 같다.(external, internal, inline)</p>
<p>internal 방식 = head에 <scirpt>작성</script></p>
<p>external 방식 = head에 '</script></p>
<p>inline 방식 = 태그 안에 on뭐시기="자바스크립트 명령어"</p>
<p>나중에 서버등 담고 실행하고 하려면 c드라이브가 최소 60기가 정도는 남아있어야 원활하게 학습을 이어나갈 수 있다.</p>
<p>새삼 변수는 어떤 저장공간에 저장하는지 생각을 안했네;; RAM에 저장됨</p>
<p>보통 함수고 왔다갔다고 계산이고 전부 cpu가 처리함, RAM, C,D드라이브 등은 cpu가 이용하는 도구일 뿐</p>
<p>내가 cpu와 RAM을 얼마나 짧게, 조금 쓰는지 보는게 코딩테스트, 작게 쓰면 부하를 적게 주는 코드니까 좋은 코드겠쬬?</p>
<p>좋은 알고리즘 - cpu를 적게씀 = 시간복잡도가 낮음 / 좋은 자료구조 - Ram을 적게씀 = 공간복잡도가 낮음</p>
<p>컴퓨터의 기본 데이터 - 숫자(정수+실수), 문자, 논리 => 그럼 기본 데이터 가지고는 인터넷 접속도 안되고 동영상도 못보겠네? - YES</p>
<p>가르쳐주시기로는 변수 생략가능하다고 함(?)</p>
<p>클래스만 대문자, 변수는 보통 소문자</p>
<p>var 냥 = "" => 문자열 변수 선언</p>
<p>냥 = "고양이" => 냥 변수에 문자열 "고양이" 할당</p>
<p>냥 => 쓰레기 값(선언 X, 초기화 X)</p>
<p>와우 코드 끝에;가 들어가는 이유가 엔터를 빼고 전송하기 위한 밑밥이었음;;; //ㄴㄴ 자바는 그런거 상관없어 그냥 달아야해 ㅠㅠ</p>
<p>shift + del = 한 줄 지우기</p>
</details>

## [9월 14일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>자바 스크립트 프론트엔드 아님? 왜 우리 백엔드가 함? - 웹 브라우저에서만 있으면 상관없지만 결국 웹서버에서 브라우저로 HTML,CSS,JS를 전달하는 입장에서 백엔드 개발자는 JS를 알고있어야 한다.</p>
<p>jQuery, Ajax까지 끝나면 UI등을 설정하는 프로그램으로 미니 프로젝트</p>
<p>HTML, CSS는 설정 중싱 언어 / 자바 스크립트, 자바 등은 처리 중심 언어</p>
<p>자바가 굉장히 체계적이라 일단 자바를 잘 배워놓으면 다른 언어도 잘 쓸 수 있을 가능성이 높음</p>
<p>데이터(기본 데이터) --> 연산자(기호) --> 순차적인처리, 조건처리, 반복처리(코테 같은 것의 데이터)
많은 양의 데이터(배열)<br>
기본 데이터 이외의 데이터(객체-window,location,history, 틀-클래스)<br>
=> 자바를 포함한 대부분 언어의 매커니즘</p>
<p>자바 스크립트 - 브라우저에서 실행, 자바 - 서버에서 실행</p>
<p>자바 vs 자바 스크립트 다른 점 면접에서 꽤 물어보나봐 외워야징</p>
<p>system.in = 컴퓨터에.키보드로 입력</p>
<p>systme.out = 컴퓨터에서.모니터등으로 출력</p>
<p>웹 개발에선 연산자 중엔 비교 연산자가 가장 많이 쓰임 (조건문이 존나게 많음)</p>
<p>자바, 자바 스크립트는 cameCase(권장), 파이썬에선 snake_case</p>
<p>정적 타이핑 - c++, java / 동적 타이핑 - javascript, python</p>
<p>플러스 연산자 사용 시 하나라도 문자면 결합 연산자가 된다</p>
<p>입력으로 받은 데이터는 무조건 문자형, 왜? => 문자인지 숫자인지 결정할 능력x, 이건 프로그래머가 결정해야함</p>
<p>parseInt() 등 상당히 많은 자바 스크립트 명령어가 자바 명령어랑 비슷한 면이 있다. 외우기 쉽겠다 키킥</p>
<p>변수에다가 prompt()를 할당하는게 가능함</p>
<p>객체지향 코딩이 뭔지 알아바렸다.. 일단은 자바 스크립트가 가진 객체인 window, locaion, document, history를 잘 써보자</p>
<p>작성 쓰끼리 => 코드작성 - 실행 - 주석처리 - 작성 - 실행 - 오류발생 => 주석처리를 섞으면 오류 쉽게 발견 가능</p>
<p>하나하나 말해주면서 하면 다 이해되는데 나중에 '이런 사이트를 만들어라' 하고 띡 주면 꼭, '\n' 이런거 하나씩 놓침 ㅠㅠ</p>
<p>html문서로 js작업을 하다 보니까 console.log가 아니라 document.write를 더 자주 쓰게 되는 구만</p>
<p>현대로 오면서 confirm, prompt, alert등의 명령어가 안쓰임, 이유? => 클릭 자꾸 시킴, 귀찮음.</p>
<p>이런 설명 들으면서 새삼 깨닫는 비동기식 처리를 쓰는 이유?</p>
<p>js11-버튼처리 파일 이론상으로는 알고 있는데 한번도 안써봤으니까 다시 써보기</p>
<p>버튼 기능 하나 - 함수 하나 등 => 딱 그것만 실행시켜서 부하를 줄이기 위함</p>
</details>

## [9월 15일](#top)
<details>
<summary>오늘 배운 거</summary>
</p>javascript도 CSS에서 태그를 하나 지정하고 싶을 때처럼 id를 지정해서 가져올 수 있다. 그리고 당연히 id는 중복되면 안됨</p>
</p>html에서 tag의 정식 명칭은 사실 element임</p>
<p>쥰내 웃긴점 - html input 태그 type number로 입력받았을 때 이거 숫자형 데이터로 입력받는 줄 알았는데 그런거 상관 없고 입력값은 무조건 문자형 데이터로 받는다는걸 알게됨 ㅋㅋ</p>
<p>변수 선언시 타입 안쓰면 무조건 var로 선언됨</p>
<p>html문서 만들 떄 html말고 ! + enter쓰기 이게 더 빠름</p>
<p>코드를 짤 때는 세 단계로 나눠서 짜는게 좋다. 입력 - 처리 - 출력 으로 코드를 나눠놓으면 코드 유지보수에도 좋다. 같은 맥락으로 무조건 짧은 코드가 좋은게 아닐 수도 있다. 내가 코드를 쓰는 상황에 따라 알맞은 형태의 코드를 짜는 능력을 가져야한다.</p>
<p>1 버튼 = 1 함수 = 1기능</p>
<p>브라우저가 주소를 요청하는 방법 4가지 = a태그, 주소넣고 엔터, location.href = '주소' 입력</p>
<p>나는 병신이다 제에에에발 자동완성 좀 잘 쓰자</p>
<p>오늘은 카카오 개발자 사이트를 견학해따. 가서 맵 API 들어가서 무료로 샘플도 보고 갖다 써 보았따. 참 재미있었따.</p>
<p>구글 맵에서 위도 경도 알아내기 = 원하는 위치 검색 - 주소창 !3d경도!4d위도!에서 경도 위도만 추출, 카카오 api 맵 샘플에서 위치 찍어보기</p>
<p>결국에 구글맵 보고 로드뷰 보고 그런 것도 브라우저에 표시되는거라 자바 스크립트로 동작되는 거였다.</p>
<p>구글 차트 - 구글에서 자바스크립트로 예쁜 표를 제공해줌, CDN으로 자바 스크립트를 제공하고 스크립트를 하나 더 열어서 표 같은걸 작성해놨기 때문에 긁어올 때 두번째 스크립트부터 긁어왔음</p>
<p>함수 = 기능 처리를 하는 단위</p>
<p>javascript는 구글차트나 카카오api가보면 여전히 오래된 문법을 쓰고 있지만, 실무에선 자바 스크립트와 jQuery 둘 다 쓰게 될 것이다.</p>
<p>국립공원 관련 사이트 같은걸 쓰려면 당연히 공공DB에서 데이터를 받아와야하는데 이때 공공DB는 oracle로 서버를 관리하고 있고 나는 jQuery를 이용해서 **이** 데이터를 받아오게 된다.</p>
<p>jQuery란 자주 쓰이는 자바 스크립트 코드를 완전 짧은 단축키로 바꿔놓은 것</p>
<p>ex, document.getElementBYid('result") === $('result')</p>
<p>$(function(){}) = jQuery할 땐 넣어줘야한다네요 왠지는 모름 ㅋ</p>
<p>jQuery 쓰기 전에는 입력값에 id부여하고 버튼에 함수 부여하고 왔다갔다 난리쳐야했는데 이젠 안그래도 됨.</p>
<p>jQuery, $('body') => 모든 body 태그에 접근 / $('.body') 클래스 body에 접근 / $('#body') id body에 접근</p>
<p>나는 spring framework로 해야징, boot로 하면 시간 오래 들여야한다고 해용</p>
<p>와 진짜 이런거까지 고민해서 포폴을 만들었구나 라는 인상을 주는게 중요하다</p>
<p>전부 내 기준으로 질문하고 설명해달라고 하기</p>
<p>강사님 잘 만난 듯</p>
<p>jQuery.com 에 들어가면 jQuery 다운도 받을 수 있고 링크도 받을 수 있따</p>
<p>내가 다룰 수도 있긴 하지만 엄밀히 말하면 jQuery도 web front측 기술이라고 말할 수 있겠다.</p>
<p>jQuery는 자바스크립트를 편하게 쓸 수 있도록 도와주는 오픈소스 기반 자바스크립트 라이브러리</p>
<p>쉣 자바는 ''아니라 ""써야되나 봄 조땜</p>
<p>수업내용 슬랙에서 찾기 힘드니까 카페에서 찾기</p>
<p>카카오 Oven - HTML5 기반의 무료 웹/앱 프로토타이핑 툴 => 사이트 만들기 전에 미리 한번 만들어보는 툴</p>
<p></p>
</details>
<details>
<summary>.innerHTML을 쓰는 방법</summary>
<p></p>
</details>

## [9월 18일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>JRE = Java Run Environment, 얘가 있어야 자바로 만든 프로그램을 다른 환경에서 실행할 수 있음</p>
<p>기존의 C++ 언어는 환경이 달라지면 코드를 새로 짜야 했는데 JAVA는 JRE라는 인공환경만 세팅해주면 다른 환경에서도 코드를 새로 수정하지 않고도 자바 프로그램 실행 가능</p>
<p>왜 jdk만 환경변수를 따로 설정해주었을까? - eclipse등 프로그램은 JRE를 자동을 알아서 깜</p>
<p>IDE =Integrated Development Environment, 통합 개발환경</p>
<p>VSCODE(범용), eclipse(자바), inteliJ(자바) = IDE</p>
<p>pycharm = pyton</p>
<p>visual studio = c, c++, c#</p>
<p>PHP는 최근 들어서 안 씀, 객체 지향식인데 존나 느림</p>
<p>JDK에는 JAVA개발에 필요한 함수나 객체나 메소드 4500여개가 있다. 부족한 부분은 이클립스에서 플러그인 방식을 통해 실행할예정</p>
<p>static = 망치, class = 틀, interface = 필요한 기능 정의 => static이라는 망치를 하나 만들어서 필요할 때마다 꺼내 쓰고, class라는 주조 틀을 사용해서 부품 양산</p>
<p>수식을 계산하고, IDE를 통해 결과를 도출하는 것 모두 CPU가 해야할 일이고, static, class등의 도구는 전부 RAM에 있어야 CPU가 가져다 쓸 수 있다.</p>
<p>SUN Microsystems inc에서 만든 JDK, 이후 oracle에 인수됨</p>
<p>JDK SE, SE = standard edition (4500개)</p>
<p>JDK EE, SE + enterprise(기업용 버전) = EE, eclipse도 EE버전이 있다. 내가 깐 것도 EE버전</p>
<p>JDK는 여러 객체를 가진 라이브러리, 여러 분류를 가짐, SE, EE 등</p>
<p>JDK 11이후 oracle JDK가 유료로 버뀌면서 소송전쟁, openJDK라는 오픈소스 제공됨, 근데 oracle openJDK가 존재함 ㅋㅋ 물론 기능 제한되어있음</p>
<p>자바 파일 - 컴파일 - bytecode(컴퓨터가 이해할 수 있는 코드)를 담은 자바 class파일 생성 - JVM(Java Virtual Machine)을 포함하는 JRE가 깔려 있는 환경에서 자바 파일 실행</p>
<p>JDK는 </p>
<p>자바는 C++에서 파생, 현재는 pyton이 굉장히 거대해졌지만 복잡한 프로그램이나 웹 서버 등을 다루려면 JAVA로 다루는 것이 더 합리적이다. 그래서 현재 서버를 다루지 않는 pyton이외의 프로그래밍 언어 사용자는 파이썬으로 넘어갈지, JAVA를 배울지 고민 중이라고 함</p>
<p>자바 툴로는 eclipse, netbeans, inteliJ 등이 있는데 netbeans는 오류가 많이 발생</p>
<p>자바 툴 환경 설정 등 ppt따라서 진행해보기</p>
<p>workspace - refeusing 뭐시기,u utf-8 인코딩 방식 설정 등</p>
<p>java - compfiler 수준 1.8로 맞추기</p>
<p>appearance - dark로 하면 어둠의 다크 테마로 바꾸기 가능</p>
<p>general appearance = colors and fonts 에서 클자 폰트 바꾸기 가능</p>
<p>help - eclipse marketplace에서 vscode와 같이 플러그인 찾기 가능</p>
<p>플러그인 중에 Darkest이거는 시력 보호에 좋다 꼭 받자</p>
<p>ctrl + n = (프로젝트(패키지(클래스))) 요거 세개 다 만들기</p>
<p>갓 만든 자바 프로젝트 JRE system libary의 jar 파일 = java archive</p>
<p>src에서 ctrl + n 으로 패키지 폴더 만들기, 패키지 폴더에서 ctrl + n으로 cls 만들기, 이쯤이면 ctrl + n은 기억해야겠지?</p>
<p>이클립스 자바 프로젝트에서 폴더 지울 때 체크박스 체크 안하면 지울 폴더를 프로젝트에서만 지우기 가능. 왠지 폴더는 남겨놔야 할 것 같을 때 사용 가능</p>
<p>클래스는 무조건 대문자로 작성, 그래야 실무 등에서 구분 가능함</p>
<p>public static void main => 독립적으로 실행 가능</p>
<p>
`package test;  // 이건 package test에 있는거야

public class Hi {

	public static void main(String[] args) {
		// class는 main이라는 함수가 있어야
		// 독립적으로 실행되는 부품이 된다.
        // JOptionPane.showInputDialog;("당신의 이름을 입력해 주세요.");
        // 망치.망치질

	} // 이건 class Hi에 해당하는 부분이야 

}`
</p>
<p>main + ctrl + space bar, syso + ctrl + space bar = 자동완성 기능</p>
<p>ctrl + d = 한 줄 삭제</p>
<p>ctrl + f11 = 실행</p>
<p>자바는 변수 선언을 할 때도 숫자형을 저장할지, 문자형을 저장할지 지정하고 선언해야 함. int 변수 = 0 으로 선언된 변수는 무조건 정수만 들어갈 수 있다.</p>
<p>논리형은 boolean, 문자형은 string 등 타입이 안변하니까 정적 타이핑</p>
<p>char = 문자 한 개, double = 소수점, boolean = true,false</p>
<p>char는 문자 1개만 ''로 선언, S(대문자)tring 은 문자 여러개를 ""로 선언</p>
<p>원래 기본형은 int(정수) dobuble(실수) char(문자) boolean(논리) 인데, String(문자열)은 하도 많이 써서 기본형처럼 쓸 수 있게 만들어놓음</p>
<p>String이 기본형이 아닌 이유 = 다른 기본형 데이터는 한번에 하나의 저장소만 사용하는데 Stringdms 홍길동 => char ='홍' + cahr '길' + char '동' 으로 저장소 3개를 사용하는 모습을 보여주기 때문</p>
<p>반드시 ; 붙여주고 무조건 데이터 형태를 지정하고 변수를 선언해야 하는 등 쥰내게 까다로운 친구지만 그만큼 복잡한 프로그램이나 웹 등에서 강한 면모를 보이는 친구이다</p>
<p>그렇기 때문에 코딩을 쉽게하고 싶으면 pyton을 사용하고, 복잡한 프로그램을 만들거나 디버깅을 용이하게 하고 싶으면 JAVA를 사용하는 것이 좋다.</p>
<p>C++이 오래 쌓이고 객체지향언어라 좋기는 한데 존나 어려움. C++의 장점을 가져오면서 조금 더 쉽게 만든 것이 JAVA. 아직까지는 JAVA만큼 좋은 언어가 나오지는 않은 것 같다는 평기</p>
<p>JAVA가 이렇게나 좋은 언어고 안정성도 높은데 왜 브라우저에서는 JavaScript를 사용하는가? => 지금 쓰는 브라우저가 자바 스크립트밖에 해석 못함.</p>
<p>그럼 왜 하필 크롬에서 주로 개발하는가? => 브라우저 엔진 중 유독 크롬 엔진이 자바 스크립트를 구동시키는 속도가 빠름. 왜 빠른지는 모름</p>
<p>대충 치다가 ctrl + shift + f = 자동으로 들여쓰기 해줌</p>
<p>jop.showin = 이름 입력하는 프롬프트 띄우기</p>
<p>jop + .showme = (null, 입력값) 입력값 띄우기, null은 아직 뭔지 모름</p>
<p>입력값이 문자열인건 JAVA에서도 변하지 않음</p>
<p>아 null이 쓰레기값이 아니었구나, 변수 = null은 쓰레기값 조차 정리해주는 인위적인 아무것도 없음 값을 지정해주는 거였어 ㄷㄷ</p>
<p>Integer.parseInt(냥) = 냥을 정수값으로 바꾸기</p>
<p>Double.parseDouble(냥) = 냥을 실수값으로 바꾸기</p>
<p>System.out.printf("%.2f", 냥); = 냥값 2번째 소수점까지만 자르기</p>
<p>모든 클래스도 대문자로 시작</p>
</details>
<details>
<summary>오늘의 문뎨</summary>
<details>
<summary>기본 데이터형 4가지의 각각 사용하는 키워드</summary>
<p>정수(int)</p>
<p>실수(double) - 어 실수형은 double도 있는데? - 사실 둘다 맞는데, float은 작은 실수형, double은 float의 두배에 달하는 실수를 포함 가능</p>
<p>문자(char)</p>
<p>논리(boolean)</p>
</details>
<details>
<summary>기본 데이터형의 키워드는 아니지만 일부 기능을 기본형처럼 사용할 수 있는 문자열을 나타내는 타임</summary>
<p>String</p>
</details>
<details>
<summary>자동완성하는 단축키는?</summary>
<p>ctrl + space bar</p>
</details>
<details>
<summary>프로젝트, 패키지, 클래스의 대소관계를 나타내시오</summary>
<p>프로젝트 > 패키지 > 클래스(파일명.JAVA)</p>
</details>
<details>
<summary>System.out.println("나야 나")에서 System은? out은?</summary>
<p>System = 컴퓨터, out = 모니터</p>
</details>
<details>
<summary>모든 입력하는 데이터의 타입은 무엇인가?</summary>
<p>문자열</p>
</details>
<details>
<summary>문자열을 정수로 변경하고자 한다. 어떤 클래스의 어떤 명령어를 사용해야 하는가?</summary>
<p>Integer.parseInt()</p>
</details>
<details>
<summary>문자열을 실수로 변경하고자 한다. 어떤 클래스의 어떤 명령여를 사용해야 하는가?</summary>
<p>Double.parseDouble()</p>
</details>
<details>
<summary>서버가 실행될 때 필요한 프로그램인 JVM와 필요한 부품들의 모음인 라이브러리를 합해 부르는 말은?</summary>
<p>Java Run Envrionment</p>
</details>
</details>

## [9월 19일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>`import javax.swing.JOptionPane;` 이게 뭐징</p>
<p>혼자 실행하려면 main안에 들어있어야 한다. 아직은 main 안에만 작성하기. 클래스 지정 없이 실행한다는 얘기인가?</p>
<p>x++ = 단항 연산자, a = 1 + 1 등 = 이항 연산자, 응애 ? 냥 : 멍 = 삼항연산자</p>
<p>논리 연산자 쓸 때 논리 값이 나오도록 써야함. 보통 >< 쓸 때 이상 이하 제대로 구분 안하면 조땜</p>
<p>int a = 10 동작순서 int a => a = 10 순서로 발동, 뭔가 당연한 것 같지만, 코딩이 복잡해지면 헷갈릴 수 있음.</p>
<p>그럼 문자열이 연산에 포함되면, 왼쪽부터 연산 시작하기 떄문에 문자가 중간에 끼어있는지 잘 판단하고 연산시켜야 함</p>
<p>결합의 경우 알아서 연산이 되지만 빼기 연산자인 경우 문자 - 숫자가 되버리기 때문에 오류가 남</p>
<p>위 이유들 때문에 연산할 때 먼저 해야할 연산이 있으면 괄호를 쳐서 먼저 연산할 수 있도록 하는 것이 권장된다.</p>
<p>자바 프로젝트 파일을 이클립스에서 쓰려면 이클립스 워크 스페이스에서 연 다음, package explore 우클릭 - import - general - exsisting projects into workspace에서 내 eclipse workspace 지정 후 java basic 폴더 가져오기</p>
<p>프로젝트를 만들면 바로 그 안에 압축된 4500개의 객체가 들어가 있는 JRE system library가 나타남</p>
<p>운영체제는 폴더, 언어에서는 패키지 그래서 언어에서 `패키지.패키지속` 이렇게 작성하면 운영체제로 봤을 때 패키지 안에 패키지속 폴더가 생겨있다.</p>
<p>이클립스 파일에 alt + enter 열면 폴더 위치 열기 가능</p>
<p>연산자로 무언가 연산할 때, ram에서 복사해 온 후 cpu에서 계산, 그다음 값 할당</p>
<p>자바도 항상 입력 - 처리 - 출력을 생각하기 나눠서도 생각하고 그래보기</p>
<p>자바 연산 시 정수와 정수의 연산은 무조건 정수로 출력한다.</p>
<p>자바 연산 시 하나라도 실수이면 무조건 실수 - 실수를 살리고 싶으면 이 특성을 사용하여 살려야 한다.</p>
<p>`double avg2 = sum / 2.0;` - 요런 식으로</p>
<p>만약 2.0 이 아니라 2로 표기하면 정수 / 정수로 계산해서 소수점 다 떼버리고 난 후인 4를 소수점인 4.0으로 표기해버림</p>
<p>(double)sum 이렇게 소괄호로 변수를 감싸는 문법 = 강제 타입변환 = 강제 형변환 = casting 캐스팅, 이런 캐스팅은 기본 데이터 타입만 해당됨.</p>
<p>ctrl + d = 한 줄 삭제</p>
<p>ctrl + 방향키 : 커서를 토큰(단어) 단위로 이동<br>
shift + 방향키 : 커서를 이동하면서 선택<br>
ctrl + shift + 방향키 : 커서를 토큰(단어) 단위로 이동하면서 선택<br>
(복붙, 잘라내기, 삭제할 때 등등 편합니다)<br>
F2 : 파일 이름 변경<br>
Ctrl + N : 새 파일/프로젝트 생성<br>
Ctrl + D : 한 줄 삭제<br>
Ctrl + Shift + F : 소스 정렬<br>
해당 프로젝트에서 Alt + Enter : Project 속성<br>
Ctrl + Space : 자동완성<br>
Ctrl + Alt + up/down : 한줄 복사<br>
Ctrl + F11 : 실행<br>
Alt + Shift + R : 변수 이름 변경<br>
Ctrl + / : 한줄 또는 선택영역 주석처리 / 제거<br>
Ctrl + Shift + / : 선택 영역 Block Comment 설정<br>
Ctrl + Shift + \ : 선택 영역 Block Comment 제거</p>
<p>기본형 데이터가 변수로 RAM에 공간을 만들면 기본형의 데이터가 저장되지만, 기본형이 아닌 데이터가 변수로 RAM에 공간을 만들면 주소를 저장한다.</p>
<p>그렇기 때문에 char을 여러개 써서 합쳐 놓는 String 데이터형은 기본형이 아닌 데이터이기 때문에 값이 아닌 주소를 저장한다.</p>
<p>기존값.equals("비교값") => 기본형이 아닌 데이터를 비교할 때</p>
<p>변수.charAt(0) => 변수 0번 자리의 문자값을 가져옴</p>
<p>char는 2byte 만 쓰는 반면, String은 최소 6byte르 씀</p>
<p>RAM에 저장된 변수는 class가 끝나면 사라짐</p>
<p>intelij가 이쁘고 더 쉬운데 왜 아직까지는 eclipse를 쓰나요?</p>
<p>intelij가 유료고 나중에 나왔기 때문에 아직 범용적으로 쓰려면 eclipse 쓰는게 좋음, 대학계정이 있으면 intelij 유료 버전을 사용ㅎㄹ 수 있다.</p>
<p>eclipse는 코드가 오픈되어있다. 심지어 우리나라 정부 버전 eclipse인 eGovFrame이라고 있다.</p>
<p>자바 새 파일 생성 창에서 각종 버튼에 알파벳에 하나씩 들어가 있는 밑줄 쳐진 알파벳 alt + 알파벳 하면 그 버튼 눌림</p>
<p>import javax.swing.JOptionPane; 이게 자동으로 생기는 이유 - 원래 JRE library에서 JOptionPane라는 부품은 javax 폴더 안의 swing안에 있었던 것임. JOptionPane라는 부품을 쓰려면 정석으로는 javax.swing.JOptionPane 이거를 다 입력해야 쓸 수 있는 거였는데 파일에서 class를 열기 전 import + javax.swing.JOptionPane를 입력해두면 이후 더 이상 JOptionPane를 쓸 때마다 경로를 지정하지 않아도 사용할 수 있게 해둠.</p>
<p>javax.swing.* 경로를 이렇게 지정하면 swing 폴더 밑의 모든 클래스를 지정하는 것</p>
<p>javax 까지만 지정하면 JOptionPane를 쓸 때마다 swing.JOptionPane를 써줘야 함</p>
<p>클래스나 프로젝트나 패키지는 java, javax로 이름지으면 안됨. JRE libarary에 이미 그 이름이 있음.</p>
<p>변수 선언 할 때 앞에 final만 붙여주면 상수로 선언할 수 있음, 상수는 무조건 대문자로 선언해야겠죠?</p>
<p>Stirng.format("%2.f", 변수)도 System.out.printf("%2.f", 변수)로 똑같이 이용할 수 있다.</p>
<p>클래스를 사용하는 방법<br>
1. 망치 - 자주 써서 RAM에서 언제든지 꺼내 쓸 수 있도록 하는 부품, RAM에 준비되어 있어야 함.<br>
2. 망치.기능이름() ===> 클래스.이름.함수()<br>
3. 벽돌 - 일반적인 부품 사용법, 필요할 때마다 만들어서 사용하는 부품. 벽돌 틀에 망치로 재료 집어넣음</p>
<p>new + ctrl + space bar 화살표 누르고 엔터 + JF + ctrl + space bar 화살표 누르고 엔터 해서  JFrame이라는 부품 만들기. 꼭 자동완성으로 만들어줘야 import가 생김.</p>
<p>	//JFrame f - 이거하고 f.쓰면 어떤거 쓸 수 있는지 단축키 보임, f.setSize - 요거는 띄우는 창 가로세로 크기 설정, f.setVisivle - 요거는 띄우는 창 보이게 하기(기존에 안보임), 이 명령어가 마지막이어야함. 중간에 넣으면 중간까지만 보임<br>
		//JButton b - b.setText => 버튼에 글자 넣어주는 기능<br>
		//JTextField t1<br>
		//JTextField t2<br>
		//JTextField t3<br>
    순서를 물 흐르듯이 배치하려면 new - flowlayout 해주고 f.setLayout에 변수 설정하면 설정 됨. 이렇게 얹는 것 조차도 부품이다.</p>
<p>ctrl + shift + o => import가 안되어 있을 때 모조리 import 해주는 단축키</p>
<p>JLabel = 글자 집어넣는 부품, 이 부품에 따로 setText로 글자도 써줘야 글자 집어넣을 수 있음</p>
<p>트러블 슈팅 = 오류 잡기? 이게 디버깅이랑 같은 말인가?</8p>
<p>저장공간을 어떻게 쓰느냐 - int double등으로는 쪼그만 프로젝트만 쓰는 걸 권장 싸이즈가 커지면 싸이즈가 큰 벽돌 틀을 써야함</p>
<p></p>
</details>

## [9월 20일](#top)
<details>
<summary >오늘배운 것</summary>
<p>우재남... 신입 직원 연수를 맡는다고 한다.</p>
<p>원래 깃허브 교재로 진행해야되는데 없어서 우리만 보여주는 자료로 진행한다고 함, 그 자료를 우리만 보는건 상관없는데 당연히 인터넷에 올리면 안되게쬬?</p>
<p>한 19년 이후~ '아 저 개발잔데 깃허브 안써요 ㅎㅎ' - 병신</p>
<p>깃허브에 뭐 할 줄 아는지 올려놓고 포폴하는 너낌</p>
<p>깃은 요리사에게 있어서 냉장고 사용법을 익히는 것과 같다.</p>
<p>우재남 강사가 생각하는 IT전문가의 역량 - 도메인 지식, 프로그래밍 실력, 4차산업기술(데이터,AI,클라우드)</p>
<p>빵 파는 가게가 웹 프로그래머를 뽑을 때, 1번 지원자 - 빵 모름, 프로그래밍 기가 막히게 잘함 / 2번 지원자 빵 전문가, 프로그래밍 조금 약함 - 이럴 때 빵 가게는 2번 지원자를 뽑음. 존나 관련 없는 전공을 가지고 있었지만 그걸 이용해서 취업을 하게 되는 경우</p>
<p>코딩 진입장벽이 높음 - 압정구조 - 초급은 많은데 중급 고급은 없음 - 제대로 존버만 한다면 2~5년 이내에 좋은 대우를 받을 수 있다.</p>
<p>깃 - 소스 코드를 컴퓨터에 보관하기 / 깃허브 - 소스 코드를 인터넷에 보관하기</p>
<p>https://cafe.naver.com/githubstudy</p>
<p>깃 - 버전 관리 도구, 텍스트 기반 원격 저장소 호스팅 서비스, 개발자들의 SNS, 자랑 통로</p>
<p>소스 트리 - 텍스트 기반인 깃은 GUI 기반으로 사용할 수 있도록 하는 프로그램</p>
<p>리누스 토르발즈 - 1991년 리눅스 커널(엔진) 제작, 2005년 깃 오픈 소스 제공=> 프로그래머의 성인, github가 아직까지도 무료인 이유는 경쟁자가 있기 때문</p>
<p>깃을 쓰는 이유 - 변경 내역 확인, 작업 되돌리기, 협력</p>
<p>코딩을 하다 보면 나도 모르게 변경 사항이 많음 그래서 깃이 필요함.</p>
<p>유의미한 코드 변화 - 버전 변화 / 응애코드변화 - 버전변화라고 안부름</p>
<p>프로그램 개발 - 버전을 쌓아나가는 것</p>
<p>깃에 무료로 올린 오픈 소스를 돈 받고 팔아도 됨 ㅋㅋㅋ, 이래도 안잡혀간다고 하네용, 물론 도의적으로 욕은 먹겠죠</p>
<p>오픈소스의 최대 적 = Microsoft, 근데 2018년에 MS가 github를 인수함</p>
<p>MS는 현재 azure라는 클라우드 회사로 먹고 살음. 운영체제같은건 부가 사업, 착해져가지고 아직까지는 github를 무료로 운영중이긴 함. 심지어 기존 프로젝트 비공개하기는 유료였는데 그것도 무료로 바꿈.</p>
<p>코드 공개를 꺼리는 기업을 위해 Github Enterprise 패키지 제공</p>
<p>인텔의 32bit cpu가 기존에  86xxx 86xxxx 86xxxx 등으로 불려서 그거에 해당하는 폴더를 x86이라고 만들었는데 나중에 64bit가 나오게 된 이후 해당하는 폴더를 만들려고 보니까 32bit를 왜 86이라고 지었는지 일관성이 없게 됨. 그래서 32bit cpu를  x86라는 폴더를 쓰게 하고 64bit는 그냥 x64라는 폴더를 쓰게 됨. 그래서 일관성 없게 x86, x64 폴더를 쓰는 거임</p>
<p>깃 폴더 보고 쥰내 설치하기</p>
<p>폴더 안의 .git 폴더가 있다 - 깃이 관리하는 폴더라는 의미, .git건드리지 않기</p>
<p>깃 저장공간 3가지 - 작업 디렉토리, 스테이지, 저장소</p>
<p>작업 디렉토리 - 코딩한 파일이 들어가는 폴더, 자바의 경우는 프로젝트를 집어넣어놓아야겠지?</p>
<p>스테이지 = 임시 무대</p>
<p>저장소 - 버전이 확정되고 관리되는 공간</p>
<p>add - 작업 디렉토리의 내용을 스테이지에 올리는 것</p>
<p>commit - 스테이지의 내용을 저장소에 올리는 것</p>
<p>하나의 버전이 만들어지는 과정<br>
1. 자바 프로젝트 제작<br>
2. add<br>
3. commit<br>
4. 버전 완성 !!</p>
<p>퇴근 할 때 이거까지 하고 퇴근을 해야겠지?</p>
<p>소스 코드 마지막에는 빈 줄이 하나 있는 걸 권장함</p>
<p>커밋 해시 = 커밋한 버전의 고유한 ID, 절대 중복 안됨 존나 긴 16진수, 앞 7글자만 끊어 읽었을 때 적어도 내 컴퓨터 안에서는 중복 안됨</p>
<p>마우스는 표시된 버전을 클릭하면 되는데 리눅스 같은 명령어 모드에서는 이 id가 있어야 해당 버전을 찾아갈 수 있다.</p>
<p>커밋 태그 = 특정 커밋에 꼬리표를 달음, 보통 중요한 커밋에 달고 버전 이름을 붙임(ex, v0.0.1 등)</p>
<p>파이썬이 데이터와 인공지능으로 가장 적합한 언어다.</p>
<p>오픈소스(OpenSource) = 앱 무료 + 소스코드까지 공개 - 그냥 완전 무료</p>
<p>프리웨어(Freeware) = 앱 무료, 소스코드는 안 줌</p>
<p>쉐어웨어(Shareware) = 일정 기간동안 무료(보통 7~30일)</p>
<p>pyton에서 idle에서 new fiel 로 .py파일 만들고 그걸로 run moduel하면 idle에 결과 표출됨</p>
<p>깃은 우리가 어떤 짓을 하든 관심 없고 단지 파일 내의 변경사항만 관심이 있다.</p>
<p>취업할 때 깃허브를 제출하는 만큼 깃허브에 1일 1커밋 이상 하면 좋다. 당연히 강의 들으면서도 커밋 하면 좋겠지? 물론 취업 이후에 하는 커밋은 보통 기능하나를 완성할 때 커밋해야한다.</p>
<p>깃 커밋 이후 깃 저장소에서 ctrl 클릭으로 다중 지정을 하면 그 영역 내의 변경 사항을 다 알려줌</p>
<p>만들어진 방법을 되돌리는 두가지 방법 - revert, reset</p>
<p>revert = 1000 버전을 999버전으로 되돌리면 1001버전이 됨, 즉 1000버전을 살리고 과거의 999버전을 복사해서 1001버전으로 만드는 것</p>
<p>reset = 1000버전을 완전히 999버전으로 되돌리고 1000버전을 날려버리는 것</p>
<p>reset이 좀 불안하지? reset - soft, mixed, hard</p>
<p>soft reset - 해당 버전 커밋까지만 날리기</p>
<p>mixed reset - 스테이지까지만 날리기</p>
<p>hard reset - 코드까지 다 날리기</p>
<p>버전 여러개를 건너뛰면서 리셋 시키면 표적 버전 이후 버전은 싹 날아감. revert reset 때에 맞게 쓰기</p>
<p>듣기만 했을 때 나는 soft reset을 하고 싶었는데 soft reset을 하면 스테이지에 파일이 올라간 상태가 됨, 그래서 만약 버전 되돌리기를 한다면 기존 파일을 복사해 놓은 다음, 버전을 아예 하드 리셋을 해버리는 편이 리셋해놓고 작업하기는 편함</p>
<p>revert는 해당 커밋에 우클릭 + 커밋 되돌리기 => 초간단!</p>
<p>reset은 해당 커밋에 우클릭 + 이 커밋까지 초기화 = soft, mixed, hard 선택</p>
<p>이거 이렇게 바꾸면 내 파일 상태도 그에 맞춰서 바뀌니까 백업해둬야 할 파일을 백업해야겟다.</p>
<p>미니 특강에 리눅스 기초 명령어가 있음. 리눅수 만든 사람이 깃도 만듬. 많은 연관성이 있음.</p>
<p>취업에 도움될 자격증 - 권장 : 정보처리기사(운전면허증 너낌 법적으로 필요함, 나 컴맹 아니거든요 느낌 + 컴공과 4년의 요약), 전자계산기조직운용(전공자)</p>
<p>ADSP, SQLD, 빅데이터, OJCP, 리눅스 마스터, 인공지능 => 전부 다 좋은 자격증은 맞음, 근데 나한테 필요한 자격증인가? 자격증은 취업에 도움되기 위해 따는 것이기 때문에 취업 사이트 공고를 보고 들어가고 싶은 회사에 필요한 자격증을 고르는 것이 좋다.</p>
<p>리눅수 명령 기초 wsl</p>
<p>자격증 같은거 필기, 실기로 나뉘어진 경우 필기만 합격했더라도 필기 합격을 적어놓는 것이 좋다.</p>
<p>합격률 높은 자격증은 따지 않기, 프로그램의 배포 과정을 알아보기</p>
<p>Alpha, Canary(카나리아 - 경보기 역할 새) 알파 버전 = 프로그램 개발을 완료하고, 처음으로 release한 버전, 치명적인 버그 발생 가능</p>
<p>Beta베타 버전 = 본격 배포 전 알파 버전에서 개발자가 큰 버그를 잡아두고, 자잘한 버그가 발생 가능. 보통 게임이든 뭐든 베타 테스터를 이용해서 버그를 제보받고 수정하는 일을 함. 원래 베타 테스트같은거 돈 받고 해야되는데 게임같은거는 너무 하고 싶은 나머지 알아서 참여함 ㅋㅋ</p>
<p>Release Candidate(RC) 버전 = 버그를 거의 다 잡은 버전, 출시 직전</p>
<p>Preview 버전 = 그냥 출시 직전 거의 동일한 버전</p>
<p>정식 (RTM, GA, 1.0) = 정식 버전, 보통 이 버전으로 판매가 이루어짐</p>
<p>Community 버전 = 정식인데 무료인 버전</p>
<p>Patch 버전 = 정식 버전 이후 미처 발견하지 못한 버그 등을 수정하는 버전</p>
<p>Update 버전 = Patch의 묶음</p>
<p>Service Pack = Update의 묶음</p>
<p>위 단계는 유료 프로그램 배포 과정을 전부 나눠놓은거기는 한데, rc버전 없거나 하는 등 배포하는 회사의 성격마다 단계가 다름</p>
<p>오픈소스 버전 = 보통 0.0.2 => 0.8 => 1.0 순으로 개발, 욕은 1.0부터 먹음</p>
<p>stash = 현재 코딩 중인 버전을 싹 정리해서 이름 붙이고 임시 보관소에 보관, 상사가 변덕을 부릴 때 용이</p>
<p>stash를 다시 가져와서 적용하려면 stash되었던 그 상태 그대로 돌아가야함. 아니면 충돌 일어남.</p>
<p>그래서 stash를 쓰고 아무 작업도 안 하고 있을 수는 없으니까 필요한 파일을 stash로 따로 빼놓고 필요한 것만 빼서 쓰는 걸 권장함</p>
</details>

## [9월 21일](#top)
<details>
<summary >오늘 배운 것</summary>
<p>브랜치를 쓰는 이유 - 협업 때문에</p>
<p>쇼핑몰 코드<br>
1. 장바구니 브랜치<br>
2. 주문 목록 브랜치<br>
3. 두개 각각 따로 쓰고 합치기</p>
<p>소스 트리 보면 main브랜치라는 최초의 브랜치가 설정되어있음</p>
<p>브랜치 기능도 커밋 처럼 뭐 하는 건지 표시하면서 브랜치를 나누어야함</p>
<p>Head = 현재 작업 중인 커밋</p>
<p>Checkout = Head를 옮기는 것</p>
<p>보통은 Head 브랜치 중 마지막 커밋을 가리침</p>
<p>체크아웃 하면 해당 커밋의 파일만 보임</p>
<p>a에다 b 브랜치를 병합해도 b 브랜치는 따로 삭제하지 않는 한 계속 남아있음</p>
<p>그냥 병합은 일반병합<br>
a에서 b 브랜치를 생성하고 a브랜치에 아무 작업도 하지 않았다면, b브랜치를 다시 병합 시킬 때 fast-fowrad merge라는 것을 한다.</p>
<p>만약 같은 파일을 수정했다면, 브랜치 합치기 할 때 충돌이 발생한다. 충돌이 발생했을 때 해결법 - 충들을 해결한다(존나 어려움) - 다시 커밋한다</p>
<p>브랜치 병합 후 충돌 발생 시, 스테이지에 올라간 파일관 안올라간 파일이 있는데, 이 때 안올라간 파일에 우클릭 후 '내것으로 해결', '저장소 것으로 해결' 이 있는데 '내것으로 해결'을 고르면 head의 파일로 병합할 브랜치의 파일을 덮어씀, 이후 커밋란에 '마스터의 파일로 충돌 해결함' 등으로 표기해 주는게 좋음</p>
<p>그러니까 브랜치를 나눠도 같은 파일을 여럿이 코딩하지 말아야겠지?, 그런데 한 파일에 있는 코드에 여러 명이 붙어야 할 일이 있을 때는, JAVA에서는 물리적으로 파일을 분리한 다음, import명령어를 추가해서 파일 내용을 불러와야 한다.</p>
<p>위 이유들 때문에 회사에서 각자 일은 분배해주는 프로젝트 매니저의 역할이 굉장히 중요하다.</p>
<p>리눅스 연습하려면 git bash 열고 연습하면 됨</p>
<p>리눅스 설치법 = 1. pc에 직접 설치(윈도우 날려야함), 2. 가상머신 이용(시간 오래 걸림), 3. WSL(Window Subsystem Linux, 윈도우에 리눅스 터미널 추가)</p>
<p>git bash로 리눅스에서 쓰는 명령어 실시 가능, 윈도우 업데이트를 최신으로 유지해야 WSL을 이용할 수 있음. </p>
<p>깃허브 커밋은 조작이 불가능하니까 매일매일 해보기</p>
<p>깃허브 계정을 알려줄 때 /레포지토리 로 레포지토리까지 알려줄 수도 있음. 프로젝트 제출할 때 쓰면 좋겠지.</p>
<p>깃허브 - 레포지토리 - 이슈 - 에서 코드의 문제점 같은걸 제보하거나 제보받을수도 있음.</p>
<p>깃허브랑 소스트리를 연결할거라 깃허브에서 커밋을하는 과정이 소스트리와 상당히 비슷하다. 다만 스테이지가 없다는 차이점이 있다.</p>
<p>깃 허브 연동 방법 - HTTPS(계정과 암호), SSH(접속할 PC에서 인증키, 즉 PC인증방식)</p>
<p>OAuth 새로고침 후 비밀번호 입력 인증 후 연동</p>
<p>아 깃에서 클론하면 레포지토리를 그대로 가져오는 거라 새로 생성이 안된다는 그런거구만 그래서 소스트리에서 빈 폴더에 리포지토릐를 생성하는 것처럼 깃도 이미 만든 레포지토리라면 빈 폴더에 클론해야 오류 없이 레포지토리 연동이 완료되는 것이었던 것이었던 것임</p>
<p>원격 저장소와의 4가지 상호작용 - 클론, 푸시, 패치(fetch), 풀</p>
<p>클론 = 레포지토리 복사해오기</p>
<p>푸시 = 로컬 저장소에서 커밋 이후 원격 저장소로 커밋 내용을 보내서 연동하기(권장 - 커밋하면 바로 푸쉬하기)</p>
<p>풀 = 공동 작업 중 원격 저장소에서 커밋 내용을 가져와서 연동하기</p>
<p>패치(잘 안씀) = 검증되지 않은 코드를 풀 직전까지 가져오는 것. 보통 프로젝트 매니저가 코드 검증하려고 씀, 당연히 못 믿는 코드니까 패치는 잘 안씀</p>
<p>브랜치명 main, oring/main은 완전히 같은 브랜치, 여기서 origin이 github를 뜻하는 것임</p>
<p>컴퓨터 로컬 저장소에서 커밋을 하면 main브랜치 혼자 한개 올라가면서 커밋을 나타냄. 이 때 push까지 해줘야 main/origin 브랜치가 따라 올라가면서 깃허브도 연동 됨</p>
<p>남의 저장소는 레포지토리 code를 clone해와서 소스트리에서 받기</p>
<p>남의 레포지토리를 수정해서 푸시를 누르면 남의 레포지토리로 가게 됨. 물론 남의 코드를 마구 수정할 수 없어서 권한 없음으로 오류가 뜨게 됨. 그렇기 때문에 남의 코드를 가져올 때는 레포지토리도 좋지만 일부 좋은 코드만 떼와서 내 레포지토리에 넣고 수정하든지 그렇게 해서 관리해야 할 듯</p>
<p>남의 코드를 가져와서 공부하는 것도 방법이 좋겠다.</p>
<p>만약 취업 후 첫 pc를 배정받고 새 프로젝트를 시작한다. 깃/깃허브를 모두 세팅하고 시작하자.<br>
새 PC 배정 후 1회<br>
1. 개발 환경 세팅 : Java, Eclipse<br>
2. 깃 설치, 소스트리 설치, 깃 허브 가입(회사계정의 경우)<br>
3. 깃과 소소트리의 연결<br>
프로젝트 마다 1회<br>
1. 깃허브에 저장소 생성 + 더미 파일 생성<br>
2. 깃허브 레포지토리와 소트트리를 클론<br>
3. 연동 확인하기<br>
매일 작업학(반복)<br>
1. 코딩하기 (변경 사항 생성)<br>
2. 퇴근 전에 커밋하기<br>
3. PC의 커밋을 깃허브에 푸시하기<br></p>
<p>개발자로서의 스스로를 제한하지 말자. 현재 자바와 네트워크를 통해 웹 개발자로서 시작할 수 있겠지만, 언젠가 자바가 아닌 다른 언어를 이용할 수도 있고, 웹 개발자가 아닌 다른 개발자로서 커리어를 쌓아나갈 수도 있다.</p>
<p>중요 2, 기존에 깃으로 진행하던 프로젝트가 이미 있다. 지금부터 깃허브에 백업하기<br>
깃허브 백업 결정하고 1회<br>
1. 깃허브 가입<br>
2. 깃허브와 소스트리의 연동<br>
프로젝트마드 1회<br>
1. 깃허브에 빈 저장소 생성 + 더미파일 안만들기 ==> 이 저장소 https 경로를 복사 ==> 이거를 해야 깃허브에 생긴 빈 저장소를 프로젝트 레포지토리와 연동시킬 수 있음.<br>
2. 소스트리에서 기존 자바 프로젝트에 깃허브 경로를 추가(깃 클론하면 안된당 큰일난당 덮어씌워진당)<br>
3. 클론은 빈 폴더에 깃 레포지토리를 복사할 때만 쓰는거야<br>
4. 소스트리에서 연동시키고픈 프로젝트를 열고 복사한 http경로를 설정 속 원격에 경로지정, 원격 이름은 origin, 깃허브가 원격 저장소일때는 무조건 origin.</p>
<p>지금 깃을 인터넷이랑 소스트리로 다루고 있는데  깃 특강 강사가 기업체에 가면 깃 명령어 모드 조작을 가르친다고 함 즉 이 명령어를 알아야 리눅스 환경에서 개발할 때 깃허브를 다룰 수 있다고 말하는 것 같다. pdf 파일에 있으니까 반복 숙달하자.</p>
<p>깃허브 레포지토리랑 깃로컬 레포지토리는 그냥 분리되어있는거임. 단지 연결시켜 놓았을 뿐. push나 pull을 하지 않는 한 로컬 레포지토리르 삭제한다고 깃허브 레포지토리에 영향이 가는것은 아니고 그 반대의 경우도 마찬가지이다.</p>
<p>리눅스 명령어</p>
<p>cd - change directory</p>
<p>vi 파일명 = 명령 모드 => i입력(insert) 후 작성 가능 => esq => 쉬프트 + 콜론 + w + q = :wq 입력후 엔터로 명령 모드로 작성한 내용 저장</p>
<p>소스트리가 이런 명령어를 던지고 다시 긁어와서 편하게 보여주는거</p>
<p>명령어로 다룰 수 있기는 한데 이거 권장하지는 않는다고 함 소스트리를 추천하시네용</p>
<p>Dgony 레포지토리는 스페셜 레포지토리로 나를 소개하는 readme.md 파일이 맨 앞에 나타난다. 그거 수정해서 나만의 SNS 꾸미기, 확장자 이용해서 이쁘게 꾸밀 수 있음, 일단 처음은 강의 받은 카페에서 태그 가져와서 꾸미기</p>
<p>결국 내 깃허브를 보게 되는 사람이 개발 쪽에 지식이 있는 일반인인 인사담당자이기 때문에 각각의 레포지토리에 README.md 파일을 배치해서 어떤 레포지토리인지 설명하는게 중요함, 주요 프로젝트를 소개하는 권장 (개인 + 팀) 둘다 소개하는 걸 권장함</p>
<p>README.md 파일에 이미지 추가하라면 해당 레포지토리에 이미지 폴더를 만들어두고(이 때 빈폴더가 안만들어져서 그냥 dummy파일 하나 집어넣기) html의 img src 문법을 이용해서 집어넣어야함</p>
<p>5288893@hanafos.com git 특강 강사 이메일</p>
</details>

## [9월 22일](#top)
<details>
<summary >오늘 배운 것또</summary>
<p>반드시 외웓두어야 하는 것 - 기본형 데이터 형태 기억하기</p>
<p>9:20
==> String name = “홍길동“; 이거이 String 형태의 간이 표기형<br>
==> String s = new String(“홍길동“); 이거이 String 데이터형의 정석 표기</p>
<p>램에 변수로 자리를 할당할 때 boolean의 true false값을 제외하면 기본형데이터라도 단 한자리만 차지하지는 않는다.</p>
<p>이렇게 boolean 값이 차지하는 한자리를 bit라고 부르고, 보통 기본형 데이에 할당하는 공간을 8bit = 1byte 로 할당한다. 이때 숫자형이 1byte의 공간을 할당받으면 -127 ~ 127 까지 사용할 수 있게 된다.</p>
<p>이 때 boolean은 한자리밖에 차지하지 않지만 다른 데이터형와 같이 1byte에 해당하는 공간을 할당받는다.</p>
<p>즉 기본형 데이터는 기본 1byte의 공간을 할당받는데, 숫자형 데이터의 경우 21억까지의 수를 표현하기위해 8byte까지 할당받을 수도 있다.</p>
<p>이런 기본형 데이터 타입도 크기에 따라 다르게 변수 선언을 해야 된다. 그 이유로는<br>
1. 큰 대이터에 작은 변수공간을 선언하면 당연히 들어가지 않는다.<br>
2. 작은 데이터에 큰 변수공간을 선언하면 줄일 수 있는 메모리를 굳이 크게 할당하게 된다. 그래서 적절한 변수형을 선언하는 것이 중요하다.</p>
<p>뭐 하나 만들겠다 - 프로젝트</p>
<p>폴더를 구분하겠다 - . 단위로 폴더구분, 패키지</p>
<p>기능을 실현하겠다 - class</p>
<p>정수<br>
byte = +-127, 1byte<br>
short = +-3만, 2byte<br>
int = +-21억, 4byte<br>
long = 21억 이상 + L(안쓰면 오류남), 8byte, 숫자형은 기본적으로 int 이하까지 이해하고 있어서 long의 경우 숫자 마지막에 L을 붙여줘야 long으로 해석할 수 있다.</p>
<p>실수<br>
double = 8byte, 0.00000000... 까지 계속 감<br>
float = 4byte, 0.0000 + F 만 붙여주면 그 자리에서 끊음, 작은걸 쓰려면 float</p>
<p>코딩테스트 같은 걸 볼 때 잘 작동하는 쉽고 좋은 코드라고 해도 램을 많이 차지한다면 오히려 탈락할 수도 있다.</p>
<p>만약 작은 타입에 들어갈 수 있는 값이 큰 타입에 들어가 있다면, 강제 형변환(casting)을 통해 작은 변수선언을 붙여서 작은 타입에 들어갈 수 있다.</p>
<p>형번환 할 때 위의 경우는 실수나 정수끼리 같은 기본형의 형변환이라 가능했던거고, String은 결국 참조형이라 기본형과 참조형은 형변환을 할 수 없다.</p>
<p>String이 한글자라 형변환으로 char로 만드려 했는데 안됐음 ㅋㅋ, 대신 charAt(0)으로 가져와서 char변수에 집어넣는 것은 가능하다.</p>
<p>캐스팅을 쓰는 건 아마 계산하면서 값이 줄어드는 경우에 사용할 수 있겠지? 이런 캐스팅 같은 것을 하나씩 가져다가 나만의 프로그래밍 원칙을 하나씩 세워봐야겠다.</p>
<p>JOprionPane 은 alert창을 하나씩 띄우는데 여러번 띄우는게 불편하나면? 일단 지금은 콘솔창으로 입력하는 입력값을 가져오는 코드 작성 가능. 근데 실무는 콘솔이 아니라 고객이 쓰는걸 가정하기 때문에 지금 우리가 콘솔로 입력하는거는 연습할때만 ^오^</p>
<p>new로 scanner 객체를 가져와서 sc변수에 할당, Scanner(System.in)으로 콘솔에서 값 가져오기, 코딩테스트 용에서만 쓰고 실무에서 안쓰는거 꼭 기억하기</p>
<p>sc.next(); => String으로 입력한 값을 가쟈온다.</p>
<p>sc.nextInt(); => String을 int로 변경해주는 것</p>
<p>sc.nextDouble(); => String을 실수로 변경해주는 것</p>
<p>항상 빨간 밑줄이 생기면 거기에 마우스로 클릭 후 해결 방법이 나오니까 그거 꼭 해보기</p>
<p>까먹은 사실 System.out.println 에서 ln은 그냥 줄바꿈이라 빼도 결과 출력되는 거였음. 당연한건데 내가 생각을 못하고 있었음.</p>
<p>sc.nextline = 엔터를 인식함, 그래서 입력하려면 sc.nextline();을 하나 더 미리 만들어놔서 입력값을 공중분해 시켜놓아야함 대신 그냥 sc.next 쓰는데 교재에서 난리치길래 강사님이 가르쳐준다고 하심</p>
<p>if (name == "자바") => 이게 틀린 이유, 기본형 데이터가 아니라 String임. name.equals("자바")로 비교해야 비교할 수 있음.</p>
<p>if문은 break가 있고, switch문은 break가 없다. 상황에 맞게 나눠 쓰기</p>
<p>switch문의 경우, case비교 => 조건이 맞음 => 결과출력 => 이후 case 비교 없이 결과만 출력 => 그래서 case가 일치한 후 break가 없으면 이후 결과가 전부 출력됨.</p>
<p>switch<br>
long안됨, 정수만 가능(실수 불가능)<br>
char, String 사용 가능<br>
case "": case"": case"": 로 여러 조건을 붙일 수 있다. => 이렇게 써야하는 경우는 if문보다 switch문에 더 효과적이다.</p>
<p>date도 가져와야 하는 객체, date.geHours();, date.getSeconds();. 의 매소드 형식으로 시간 정보를 가져올 수 있다.</p>
<p>date.getYear(); 의 경우 밀레니엄 버그 문제 때문에 항상 + 1900을 해줘야 정상 년도를 나타내준다.</p>
<p>date.getDate(); => 요일 불러오기, 결과 0~6, 0이 일요일. 개발자의 날짜는 일월화수목금토일</p>
<p>메소드 여러가지를 사용하던 중 가로줄 그어진 메소드를 보면 deprecated라고 써 있는데 더 좋은 버전이 나와서 안쓴다는 이야기. 곧 사라질 가능성이 높음</p>
<p>자바 기능을 만들어보고 싶으면 그냥 구글에 '자바 타이머', '자바 사운드' 등 검색해보면 만드는 방법 알 수 있으니까 해보기</p>
<p>와 if나 switch문에 true 집어넣고 무한반복문 만든 다음 date.getMinutes() 등의 메소드로 일정 시간이 될 때까지 계속 반복시키는 방법을 할 수도 있음.</p>
<p>이런 무한루프는 서버를 유지하거나 게임 등을 할 때 사용함</p>
<p>if문은 break를 이미 가지고 있기 때문에 break를 if문 안에 써도 밖의 while문을 찾아가게 됨. 근데 반복을 끝낸다는 의미인지 괄호를 찾아서 밖으로 나간다는 의미인지 모르겠음. => 아 이거 그냥 break가 자체 break를 보유한 if문은 건너뛰고 break 문을 포함하고 있는 괄호를 찾아간다고 생각하면 이해할 수 있다.</p>
<p>break; => 괄호 탈출 후 프로그램 진행</p>
<p>System.exit(0); => 조건문 or 반목문 안에서 프로그램 완전 종료</p>
<p>블럭 지정 + alt shift z = 특정 조건문으로 둘러싸기</p>
<p>
숫자 맞추기 미니게임 한번 읽어보고 무한루프와 System.exit(0);을 어떻게 사용하는지 기억하기<br>
			while (true) {<br>
			String data = JOptionPane.showInputDialog("숫자를 입력해주세요.");<br>
			// 데이터 타입이 동일해야 비교 가능하다.<br>
			int data2 = Integer.parseInt(data);<br>
			if (target == data2) {<br>
				System.out.println("정답입니다!");<br>
				System.out.println("게임을 종료합니다.");<br>
				System.exit(0);<br>
			} else {<br>
				System.out.println("정답이 아닙니다!");<br>
			} <br>
		}
</p>
<p>r.nextInt(); => new로 random 가져오고, +- 21억 무작위 숫자를 가져오는 메소드</p>
<p>Random r = new Random(10); => 가져온 random에서 10이 들어간 위치를 시드값이라고 하는데, 서로 다른 클라이언트가 구동하는 프로그램의 시드값이 같으면 같은 형태의 랜덤값이 나오게 된다.</p>
<p>이 때 ()에서 0부터 지정한 숫자보다 하나 적게 설정 가능. 100을 입력하면 0~99까지 랜덤출력</p>
<p>r.nextInt() + x; 의 형태로 최소값을 지정할 수 있다. 물론 100 + 1하면 1부터 100까지 출력되므로 99까지 출력되게 바꾸려면 99 + 1 로 입력해야 한다.</p>
<p>아직 응애 프로그래머니까 괗호가 닫힐 때마다 //if //else 등으로 어떤 녀석의 닫음 괄호인지 표시해두면 좋다.</p>
<p>// 입력값는 데이터 값을 동일하게 만들어주기 위한 작업<br>
			int data2 = Integer.parseInt(data); => 이새기 이거 존나 헷갈리게 생김. 캐스팅이랑 어떻게 다른지 다시 기억해야겠다.</p>
<p>	public static void main(String[] args) {<br>
		Scanner sc = new Scanner(System.in);<br><br>
		int pre = 0;<br>
		int post = 0;<br>
		<br>
		while (true) {<br>
			System.out.print("1번 숫자를 입력해주세요. >> ");<br>
			int n1 = sc.nextInt();<br>
			System.out.print("2번 숫자를 입력해주세요. >> ");<br>
			int n2 = sc.nextInt();<br>
			if (n1 > n2) {<br>
				System.out.println("앞 숫자가 더 큽니다.");<br>
				pre++;<br>
			} else if (n2 > n1) {<br>
				System.out.println("뒷 숫자가 더 큽니다.");<br>
				post++;<br>
			} else {<br>
				System.out.println("두 숫자가 동일합니다.");<br>
			}<br>
			System.out.print("더 하시겠습니까? 종료(x), 계속(o) >>> ");<br>
			String exit = sc.next().toLowerCase();<br>
			if (exit.equals("x")) {<br>
				System.out.println("게임을 종료합니다. \n앞이 큰 경우는 " + pre + "회, \n뒤가 큰 경우는 " + post + "회입니다. ");<br>
				System.out.println("게임을 종료합니다.");<br>
				System.out.println("앞이 큰 경우는 " + pre + "회, ");<br>
				System.out.println("뒤가 큰 경우는 " + post + "회입니다. ");<br>
				System.exit(0);<br>
			}<br>
		}<br>
		<br>
	}
</p>
</details>

## [9월 25일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>and 연산자와 or연산자의 결과 출력 방식을 생각해서 만약 if 문을 쓴다면 or연산자에서는 true일 확률이 높은 조건을 왼쪽에 배치하는 것이 CPU의 부담을 덜어주는 일이다. 이런 것까지 항상 생각해서 프로그래밍을 하고 서버의 부담을 덜어줄 수 있는 방법을 생각하기.</p>
<p>CPU가 계산할 때 한번에 한 연산자만 쓸 수 있다. 그러니까 연산자가 범벅이 된 코드는 쓰지 않는게 좋겠지?</p>
<p>참조형 = 값이 들어 있는 주소를 변수에 저장, 값을 가져오는 방식을 주소를 가져옴으로써 값을 가져옴</p>
<p>기본형 = 램의 변수에 값을 그대로 저장,값을 그대로 가져오는 방식</p>
<p>결국 둘 다 값을 가져오는 것은 맞는데 값을 가져오는 방식의 차이</p>
<p>배열, 컬렉션 = 많은 양의 데이터를 한꺼번에 저장하는 방법</p>
<p>배열의 값을 알 때, 배열을 선언할 때는 `변수타입[]대괄호 변수이름 = {1,2,3,4}중괄호` 의 형태로 배열을 만들 수 있다. </p>
<p>배열의 값을 모르는 경우, int[] addr2 = new int[1000]; 이 형태로 만들면 int[]값에 해당하는 길이와 int형 변수를 가진 배열을 만들어낸다.</p>
<p>이 때 int로 선언했기 때문에 각 배열의 값은 0으로 자동 초기화가 된다.</p>
<p>배열은 선언할 때 자동으로 초기화가 되기 때문에 따로 초기화를 해줄 필요가 없다.</p>
<p>배열을 syso로 그냥 출력하면 배열의 주소값이 출력됨.</p>
<p>배열에 .length로 길이 출력하는건 자바나 자바스크립트나 똑같다.</p>
<p>배열의 끝에는 항상 그 배열에 대한 length의 값이 저장되어 있다.</p>
<p>참조형의 데이터가 4byte라고 가정할 때, 배열의 길이가 5이면 `참조형(4) x 배열길이(5) + length값(4) = 24byte의 공간을 차지한다.</p>
<p>배열 한번 길이가 정해지면 그 계산이 끝날 때까지 배열의 길이는 변하지 않는다.</p>
<p>이때 컬렉션은 그 길이가 달라질 수 있기 때문에 경우에 따라서는 컬렉션을 사용하는 것이 좋다.</p>
<p>인덱스 = 자릿값, s[0] 일 때 배열은 s, 인덱스 값은 0</p>
<p>보통 배열의 길이를 표현할 때 갯수라는 말 보단 배열의 길이나 사이즈라고 표현함</p>
<p>C타입 for문 = C언어에서 사용하던 for문 형태, 내가 익히 알고 있는 for문</p>
<p>for each문 = (임의의 새 변수 선언 : 배열) 으로 설정하면 배열의 0부터 배열.length까지의 값을 하나씩 임의의 새 변수에 계속 새로 할당. for each문 안에 syso로 출력하는 문장을 넣으면 임의의 새 변수에 할당되는 배열[0]출력, 그 다음 배열 [1]출력하면서 계속 새로운 값을 할당하면서 지나감</p>
<p>특정 값 까지 반복하는게 아니라 전체 반복이면 for each문을 쓰는게 더 쉽겠지?</p>
<p>배열을 사용하는 경우 = 많은 데이터 양, 같은 데이터 타입, 고정된 크기</p>
<p>int, char, String, JButton, double, boolean같은 데이터 타입의 배열 전부 생성 가능</p>
<p>JOptionpane => 무조건 String이라 숫자를 쓰고 싶으면 다른 변수에 넣어서 숫자로 바꿔줘야함</p>
<p>Scanner => 이것도 무조건 String인데, 대신 얘는 scanner 객체 자체에 숫자로 변환시켜주는 int메소드가 들어있음. 그거 써서 숫자로 바꾸면 됨</p>
<p>Integer.parseInt(n); => 아 이거 또 까먹음 기억하기</p>
<p>한번 선언된 변수의 데이터형은 바뀌지 않음 => 유일한 예외 강제 형변환</p>
<p>System.out.println(Arrays.toString(num));; => 코딩 테스트 등에서 배열 내용을 확인하기 위해 쓰는 출력용 문장, 중요중요</p>
<p>System.out.println((double)sum / num.length); => 압력받아 평균, 캐스팅을 잊지 말기 기본형 데이터만 가능하다는 것도 잊지 말기.</p>
<p>잊지말자 보수공사 할 때도 손이 덜 가는 코드가 좋은 코드다.</p>
<p>Font font = new Font("굴림", 1, 15); => (글자체, 진함, 글자크기) 정하는 font 객체 import 해 오기</p>
<p>아 개빡세당 java 첫번째 ppt 208페이지 따라서 계산기 만드는 중인데 전부 한번 썼던 거라 써보니까 기억나는데 그냥 생 문제를 던져주면서 풀어! 하니까 못풀겠엉 아직 연습 많이 필요한듯.</p>
<p>지금 이렇게 화면 띄우고 갖다 붙이고 하는게 자바의 JRE 라이브러리를 이용한 Swing이라는 방식인데, 지금은 안씀. 그런데 왜 이걸로 연습하느냐, 이걸 통해 자연스럽게 자바 프레임 워크로 넘어가면서 자바의 고급 문법을 배울 수 있음.</p>
<p>아 결국 내가 꼭 import해야 된다고 생각했던거는 꼭 new문을 통해서 해야되는게 아니라 어떤 객체든 자동완성으로 가져오기만 하면 자동으로 import가 되는 거였음. new문은 결국 참조형인 객체들은 변수 선언해서 같은 객체를 여러개 쓸 수 있게 하기 위한 방법에 지나지 않음. 객체 명을 그대로 끌어다 써도 import는 자동으로 되기 때문에 알림창을 한번만 띄워도 된다면 joptionpane 같은건 new로 참조형 변수 선언 없이 그냥 가져다 쓸 수도 있는거임. 이 과정도 최적화를 위해서 생각해보기.</p>
<p>참조형 배열 1개가 차지하는 크기는 기본 4byte, 필요에 따라 8byte까지 늘어날 수도 있음.</p>
<p>기본형 데이터 선언으로 만든 배열(?)은 int는 기본 4byte, short는 2byte, long은 8byte를 차지한다.</p>
</details>

## [9월 26일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>RAM의 무더기 영역(heap 영역) = 많은 데이터를 왕창 무더기로 집어넣는 RAM의 공간, 자세한건 class 배우면서 배울 예정</p>
<p>베열, 객체등을 주로 new로 변수선언하면서 불러오는데, 이때 배열, 객체 등이 import되면서 저장되는 공간이 RAM의 heap영역이다.</p>
<p>double[] d === double d[] ==> 이 두가지 배열 선언 방법은 똑같은 결과를 만들어낸다.</p>
<p>null에 대해 == 일부러 만든 없는 값도 맞는데, 변수 선언 시 혹시 존재할지도 모르는 쓰레기값에 의한 오류를 방지하기 위해 쓰레기값을 제거한 없는 값 상태</p>
<p>r.setSeed(100); => 괄호 안의 시드 값만 같으면 동일한 형태의 무작위 숫자 출력, 내가 해보니까 첫 2개 마지막 2개 값이 같았음. 근데 마인크래프트 같은 게임도 월드 생성 시드 있는거 보면 시드로 동일한 데이터를 표현할 수 있다고 생각하는게 맞는 것 같다.</p>
<p>Arrays.sort(); ==> 배열을 오름차순 정렬해주는 객체 자주 쓸 예정</p>
<p>여태껏 parseInt처럼 변수의 값을 복사만해와서 새 변수에 할당하는 경우를 배웠고, Arrays.sort 같은 경우는 배열의 주소에 접근해서 오름차순을 정렬해주기 때문에 변수 할당이 필요없다. 이렇게 값만 복사해와서 쓰는 경우를 비파괴형 함수 / 주소에 접근해서 RAM에 들어있는 값 그 자체를 바꾸는 경우를 파괴형 함수라고 부른다.</p>
<p>Arrays.toString = 애는 비파괴형 함수, 주소를 가져오지만 파괴형인 경우, 비파괴형인 경우가 있어용</p>
<p>애초에 파괴형 함수는 25%정도 차지하지만 일부 파괴형 함수를 자주 쓸거기 때문에 파괴. 비파괴 여부는 알아두는 것이 좋다.</p>
<p>int q = 0, w = 0, e = 0, r = 0, t = 0 ===> 이런 식으로 선언하면 int를 한번 쓰면서 여러 변수를 선언 할 수 있다.</p>
<p>지금 내 컴이 빨라서 for문을 아무리 집어넣어도 빨리 돌기는 하는데, for문도 많이 반복시키면 CPU에 부담이 많이 가기 때문에 줄일 수 있으면 줄이는게 좋다.</p>
<p>"\n" = 줄 바꿈</p>
<p>"\t" = 줄 정렬</p>
<p>equals로 같은지 같지 않은지 판단할 수 있고, !변수.equals로 틀린지도 비교할 수 있다.</p>
<p>.addActionListener() 특정 액션을 기다리는 객체</p>
<p>버튼.addac 자동완성 => null 값에 new ac 자동완성 ==> 밑에 있는거 자동으로 만들어짐, 버튼을 누르는 액션을 했을 때 나타나는 결과<br>
plus.addActionListener(new ActionListener() {<br>
			<br>
			@Override<br>
			public void actionPerformed(ActionEvent e) {<br>
				// 여기에 버튼을 클릭했을 때 처리할 내용을 써주면 됨.<br>
				<br>
			}<br>
		});</p>
<p>JOptionPane.showMessageDialog(null, "더한 값은" + sum); ==> null값은 이 메세지 다이얼로그가 표시되는 위치를 지정함. jframe을 f로 변수 지정 했을 때 null 자리에 f를 넣으면 jframe 위에 다이얼로그 창을 표시함</p>
<p>plus 라는 JButton에 대해 addActionlistener 내용을 입력하면 이련 형태<br>
		plus.addActionListener(new ActionListener() {<br>
<br>
			@Override<br>
			public void actionPerformed(ActionEvent e) {<br>
				// 여기에다가 버튼을 클릭했을 때 처리할 내용을 써주면 됨.<br>
				System.out.println("플러스 버튼을 눌렀군.");<br>
				String s1 = t1.getText();<br>
				String s2 = t2.getText();<br>
				<br>
				// 숫자로 변경해서 그 결과값을 모니터에 출력해보세요.!<br>
				// 마찬가지로 결과값을 다얼로그로도 출력해보세요.<br>
				<br>
				int<br>
				n1 = Integer.parseInt(s1),<br>
				n2 = Integer.parseInt(s2),<br>
				sum = n1 + n2;<br>
				<br>
				System.out.println("더한 값은 " + sum);<br>
				JOptionPane.showMessageDialog(f, "더한 값은" + sum);<br>
			}<br>
		});</p>
<p>코드 리팩토링</p>
<p>각종 기능을 추가할 때, 모두가 기능을 제대로 사용하면 좋겠지만 입력값을 넣지 않는 등의 기능 사용법을 보여줄 수가 있다. 이런 걸 방지하기 위해 if문 등을 활용하여 error메시지를 줄일 수 있다. 줄이면 결과적으로 서버에 도움이 된다.</p>
<p>데이터를 입력했는지 확인하는 방법 2가지<br>
1. s1.equals("")<br>
2. s1.length()</p>
<p>static int total = 0; 이런 변수선언은 main 밖에서 하면 main 클레스 어느 곳에서나 접근 가능</p>
<p>객체지향 코드(좋아보이는거 갖다 쓰기) vs 절차지향 코드(처음부터 다 내손으로 만들기)<p>
<p>스키마설계</p>
</details>

## [9월 27일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>내가 배우는 코드를 책에서 찾으려 하면 조금 다른 형태일 수 있다. 현재 배우는건 실무에서 쓰이는 형태이기 때문</p>
<p>지금 자바 기초를 배우고, 데이터베이스에 대해 배울 예정인데 그 때 자바를 잠깐 내려놓고 커다란 데이터를 어떻게 다룰지 배우게 될 예정이다.</p>
<p>데이터베이스라는 프로그램에 거대한 데이터를 어떻게 설계해서 집어넣을 것인가, 내가 데이터를 제대로 설계한 것인가 배울 예정.</p>
<p>지빙 배열 ppt 130쪽 String의 여러 가지 처리 방법, concat(), charAt(), sunString(), toUpperCase, repalce, contains, endswitch 등, 이런게 대표적인 String의 처리방법이긴 하지만 더 많이 방법이 있기 때문에 시간 날 때 알아두면 좋다.</p>
<p>금융서비스나 다른 사이트 등의 로그인의 경우 로그인 버튼을 클릭할 시 입력 글자와 상관없이 모두 대문자가 되거나 소문자가 되는 경우가 있다. 이럴 때 toLowerCase 등의 함수를 쓰는데, 데이터베이스에는 아아디를 대문자 혹은 소문자의 정보로 저장하는 경우가 많기 때문이다.</p>
<p>[] = s.split(",") ==> s문자열이 "냥,냥,냥,냥" 처럼 ,쉼표로 나뉜 문자열인 경우 쉽표를 기준으로 왼쪽 배열에 집어넣는 함수. 쉼표가 아닌 다른 문자를 기준으로 나눠서 집어넣을 수도 있다.</p>
<p>.trim = String 공백을 제거해주는 함수, 코드 만들기 전에 공백 제거하기</p>
<p>char[] = s.toCharArray() ==> 문자열을 모조리 분해해서 char형태로 집어넣기</p>
<p>기본형이 변수값을 가져와서 다른 변수에 할당할 때 기본적으로 값이 복사되는 형태.</p>
<p>참조형이 복잡한데, 주소를 복사하는 경우와 주소에 들어있는 갑을 복사하는 경우가 있다.</p>
<p>변수에 들어가는 데이터의 유형<br>
1. 기본형 복사 - 데이터, 정수/실수/문자1개/논리<br>
2. 참조형 복사 - 주소가 들어가는 경우로 나머지 모두, 배열, 클래스, 컬렉션 등</p>
<p>참조형 복사를 기본형 복사처럼 하면 자바 스크립트와 마찬가지로 복사까지는 기본형이나 참조형이나 같지만, 복사 이후 사본의 값에 관여할 때 기본형 복사의 경우 사본의 수정이 원본의 데이터에 영향을 주지 않는 반면, 원본과 사본의 주소가 같은 참조형 복사의 경우 사본을 수정하면 원본도 같이 수정되는 모습을 볼 수 있다.</p>
<p>그래서 참조형 복사를 주소가 아닌 값만 가져오려면 n1.clone();처럼 .clone으로 무더기영역(heap)만 복사해와야 한다.</p>
<p>이처럼 무더기영역으로 가는 길(주소)를 복사해 오는것을 ==> 얕은 복사<br>
clone으로 무더기영역의 값만 복사해오는 것을 ==> 깊은 복사</p>
<p>변수의 구분 - 변수를 사용할 수 있는 영역<br>
1. 클래스를 만들고 바로 아래에서 static int 변수 = 0; 처럼 선언한 변수 ==> 전역변수(global 변수)<br>
2. 클래스 바로 아래가 아닌 공간에서 선언된 변수는 해당 지역에서만 사용 가능 ==> 지역변수(local 변수)</p>
<p>이렇게 나뉜건 결국 또 최적화를 위함, for문 안의 변수는 for문 안에서만 이용하고 for문이 끝나면 바로 RAM에서 사라짐. 즉 class 바로 밑에 선언한 변수는 class가 끝나야(해당 기능이 종료되어야) RAM에서 사라짐. 그럼 당연히 전역변수가 많으면 많을수록 메모리에 부담이 가겠죠?</p>
<p>면접에서 변수에 대해 질문할 때가 많은데 기준을 잡아주지 않고 변수가 뭐냐고 질문하면 변수 선언 지역에 따른 질문인지, 선언한 변수의 데이터형에 대한 질문인지 물어보거나 변수의 종류를 정의하면서 대답하는 것이 좋다.</p>
<p>며용 기본형이 아니어도 `==` 을 쓸 수 있는 경우 ==> 주소를 비교하는 경우는 `==`을 쓸 수 있다. </p>
<p>여태껏 쓴 배열이 1차원 배열, 2차원 배열은 0번에 배열이 1차원 배열이 와다다 달린거, 아마 {0{0}}의 형태로 쓰겠지?</p>
<p>OOP(Object Oriented Programming) = 객체 지향 프로그래밍</p>
<p>객체지향 프로그래밍은 조립식 컴퓨터처럼 조립하는 방식에서 유래되었다. 1차 세계대전부터 시작된 하드웨어와 소프트웨어의 발전을 살펴봤을 때 하드웨어가 소프트웨어에 비해 비약적으로 많이 발전했다. 하드웨어의 빠른 발전 속도의 원인을 조립식에서 찾았다. 마우스가 망가지면 교체하고, 그래픽이 떨어지면 더 좋은 그래픽카드로 바꿨다. 그 당시 C언어로 이루어지는 소프트웨어의 경우 절차 지향 프로그래밍을 했었기 때문에 고치거나 뺴고 싶은 코드가 너무 앞쪽에 있으면 고치기 어려웠다. 결국 발전과 유지보수등의 이유로 기능마다 하나씩 class를 만들어두는 객체 지향 프로그래밍이 발전했다.</p>
<p>mysql 다운 받아서 자바 프로젝트에서 alt + enter로 라이브러리 - add external jars 에서 mysql.jar 파일열어서 지정하면 JRE처럼 자바 라이브러리 하나가 더 생김</p>
<p>mysql 이것도 mvnrepository(maven repository)에서 받음, 마찬가지로 jsuop라는 것도 받을 수 있는데, 이거는 오래된 핸드폰 같은 곳에서 쓰인 라이브러리로 그에 맞는 프로그램을 개발할 필요가 있을 때 사용하게 될 예정.</p>
<p>JDK에 있는 4500개로 부족할 때, mvnrepository에서 필요에 맞는 자바 라이브러리 가져오는거양</p>
<p>하나의 클래스는 변수와 메소드로 구성되어있다.</p>
<p>멤버변수, 멤버메소드?</p>
<p>지금까지는 main을 만들어왔는데, 이제 대부분의 부품에는 main이 없다.</p>
<p>처음 만들 때 옆에 꺼 이름 바꾸기 = tab</p>
<p>추상화?</p>
<p>멤버변수, 멤버메서드 ==> 전화기로 얘를 들었을 때 이제 클래스에서 import해오면 전화기에 되고 자동초기화된  멤버 변수인 price와 company등을 불러온 내 방에서  지정해줄 수 있고, public void 뭐시기로 만든 메서드는 main에서 import하면 그 메소드에 담긴 기능을 사용할 수 있다.</p>
<p>f.setTitle("나의 버튼들"); ==> jframe으로 띄우는 창 이름 정하기</p>
<p>b1.setBounds(400, 250, 100, 100); ==> 버튼 가로위치, 세로위치, 가로크기, 세로크기</p>
<p>와 jbutton이란 메서드라는 참조형조차 변수로  만들 수 있었던 거임. jbutton[]로 만드는거</p>
<p>기본형의 배열의 경우 0, 0.0, ""등 기본 상태지만 참조형의 배열인 경우 모든 배열칸이 null인 상태로 들어가있다.</p>
<p>수많은 랜덤버튼 만들기 다시 해보기</p>
<p>f.getContentPane().setBackground(Color.green); ==> 이렇게 점점점식으로 이어가는걸 체인식 코드라고 부름.</p>
<p>앗 전역변수는 자동초기화라서 선언만 했던 것처럼 보였던 것이다.</p>
<p>누적시키고 싶을 떄 배열은 적절하지 못하지, 미리 배열의 크기를 정할 수 없기 떄문이다. String에 넣거나 해서 다시 집어넣거나 하는 등의 방법을 사용해야 한다.</p>
</details>

## [10월 4일](#top)
<details>
<summary>오늘 배운 것</summary>
<p>JAVA의 정석은 사전 + 자바 연습 문제집 정도로 이용하면 좋다.</p>
<p>static ==> RAM의 무더기 영역에 고정된 상태로 놓아둘 부품을 설정할 때 씀?</p>
<p>벽돌을 찍어내는 틀 ==> class</p>
<p>class로 만들어낸 물건, 대상 ==> object, 이 때 램에 주소를 가지고 저장되어있음.</p>
<p>실제로 조립해야 할 대상 ==> instance(=='실제'라는 의미)</p>
<p>---class의 instance는 object이다.---</p>
<p>class를 만들 때 특정 종류의 특징만 따온 틀일 뿐이므로 실제로 instance를 만들 때는 내가 값을 집어넣어서 슈붕이든 팥붕이든 만들어서 집어넣는다.</p>
<p>프로그래밍을 object 중심으로 프로그래밍한다. ==> Object Oriented Programming(OOP), 객체지향 프로그래밍</p>
<p>보통 객체지향 프로그래밍에서 말하는 instance라는건 'class로 만들어낸 instance'를 줄여서 말하는 것이기 때문에 곧 object를 뜻하는 말이다.</p>
<p>instance는 실제라는 의미이기 때문에 DB나 클라우드 쪽으로 넘어가면 여러 데이터 중 암호화되지않은(?) 실제 데이터를 instance라고 부른다.</p>
<p>Class = 부류/그룹/종류/틀 ==> 객체지향에서는 특정한 종류가 공통적인 특징으로 만들어진 틀</p>
<p>특정 종류(탈 것 ==> 자동차, 버스, 택시)의 공통적인 특징 ==> 바퀴, 출발한다, 엔진, 브레이크 라는 클래스를 보유</p>
<p>객체 지향 프로그래밍의 중요 개념<br>
1. Abstraction(추상화) ==> 구체적인 부품들을 클래스라는 것으로 추상적으로 표현, ex.두번돌아 높이뛰어 공중제비돌기 = q2 등의 이름으로 표현 가능<br>
2. Encapsulation(캡슐화) ==> 부품의 세부 동작 방식인 은닉되어 있음.<br>
3. Inheritance(상속) ==> 부품을 재사용하여 새로운 부품을 만드는 것.<br>
4. Polymorphism(다형성) ==> 하나의 이름으로 다양한 형태를 사용할 수 있는 것. 다른 함수를 똑같은 이름으로 만들어 쓸 수 있음.</p>
<p>부품 얻는 방법 ==> JDK 4500개 중에 찾는다 - mvnreposiory에서 찾아온다 - 그래도 없으면 프로그래머가 직접 만든다.(20%이하)</p>
<p>instance를 하나 만들 때 class를 불러올 때 new라는 키워드를 통해 변수 선언을 하면서 class에 접근한다, 이 때 class가 가진 변수의 공간 새로 선언하는 변수 선언의 주소에 할당한다. 즉 불러올 class의 변수가 3개의 공간을 가지고 있으면 새 변수(1개) 주소에 class의 변수 공간(3개)를 할당하게 되면서 class를 이용해서 새로 선언하는 변수는 4개의 공간을 차지하게 된다.</p>
<p>즉 new는 객체 생성 키워드, 이 때 무더기 영역에는 class의 변수공간만 저장하고, 주소는 다른 위치에 따로 저장한다.</p>
<p>class로 만든 instance가 성질, 특성 등을 나타내면 멤버 변수</p>
<p>class로 만든 instance가 동작, 기능을 수행하는 메서드(함수)이면 멤버메서드</p>
<p>당연한 얘기지만 물건을 고를 때는 특정 물건을 제외하고는 기본적인 외형을 갖췄다면 기능을 먼저 신경쓴다. 메서드도 마찬가지.</p>
<p>부품을 만들 때는 main을 넣지 않는다. main을 넣으면 혼자 동작할 수 있게 됨. JDK의 4500개의 부품도 main이 없음.</p>
<p>멤버가 자꾸 붙는 이유 ==> 선택되었다는 의미</p>
<p>import를 안해오면 class는 기본적으로 같은 package에서 찾는다.</p>
<p>public = package가 달라도 쓸 수 있게 해줌. 얘가 변수든 메서드는 안붙어있으면 같은 package에서만 쓸 수 있음.</p>
<p>public을 붙임 = ctrl + space했을 때 보임, 안붙임 = 안보임 ==> '가시성이 있다' 라고 표현함</p>
<p>instance 변수 = class로 변수를 생성할 때 원본 값은 그대로 두고 heap영역에 동적으로 생기는 실제 값이 들어가는 변수</p>
<p>변수의 주소값만 출력해봤을 때 다른 사람들과 주소가 똑같은데, 사실 JVM이 다루는 주소 저장 방식(테이블) 때문에 같은 결과가 나오는거고, 실제로 저장되는 위치는 저장하는 컴퓨터마다 다르다. 다른사람과 똑같이 출력되는 이 주소는 쓸일이 사실 없다.</p>
<p>주소를 출력할 때 나오는 문구 마저도 메서드, 이렇게 기본적으로 상속받는 메서드가 8가지가 있음. 주소값 같은 경우 내가 고쳐쓰고 싶다면 이클립스 탭에 Source - generate toString에서 내 맘대로 고쳐 쓸 수 있음.</p>
<p>이 toString은 도대체 언제 호출되나? ==> class에서 참조형 변수가 프린트될 때 자동으로 호출된다.</p>
<p>원본 class, 주소, heap영역 전부 다른 공간에 존재한다.</p>
<p>멤버변수, 멤버메서드는 원본 class위치에 저장, class에서 멤버변수를 가져올 때 멤버 변수의 공간을 heap영역에 복사해서 새로운 instance 변수를 만들어내는 것</p>
<p>클래스와 객체와의 관계 - 클래스는 객체를 만들 수 있는 틀, 어떤 모양인지는 정해져있지만 어떤 내용인지는 프로그래머가 정해줌</p>
<p>클래스의 인스턴스를 무엇이라고 부르는가?<br>
==> object</p>
<p>클래스의 구성요소 2가지<br>
멤버변수와 멤버메서드</p>
<p>필요한 부품을 얻는 방법 3가지<br>
1. JDK에 있는 4500개 중 하나를 가져다 쓴다.<br>
2. mvn repository에서 가져다 쓴다.<br>
3. 직접 만들어쓴다.</p>
<p>전역변수와 지역변수 중 자동초기화가 되는 것은 무엇인가?<br>
==> 전역변수</p>
<p>int와 String이 자동초기화가 되는 경우 무엇으로 자동 초기화가 되는가?<br>
==> int눈 0으로 자동초기화, String은 null로 자동초기화가 된다.</p>
<p>멤버변수와 멤버메서드의 구분<br>
멤버변수는 클래스에서 선언된 변수로, 특정 종류의 모양이나 성질을 담당하고, 멤버메서드는 기능이나 동작 등을 담당한다.</p>
<p>Car c1 = new Car(); c1.size = 10; c1.price = 1000 인 경우, 멤버변수의 갯수, 전체 생성된 변수의 갯수와 크기<br>
==> 멤버변수 - 2개 / 전체 생성된 변수 - 3개, 12byte </p>
<p>참조형 변수를 프린트 시 자동호출(사용) 되는 메서드 이름은?<br>
toString() ==> 패키지명.클래스명@메모리관리테이블키</p>
<p>참조형 변수를 프린트 시 내가 원하는 대로 출력하고 싶은 경우 사용하는 메서드 이름은?<br>
toString()</p>
<p>객체생성시 사용되는 키워드는? ==> new</p>
<p>main이 메소드를 부르면, 메소드가 실행될 수 있도록 main이 공간을 내어줌(쌓임), 1번 메소드 속에 메소드가 있으면, 추가로 공간을 내어줌(쌓임), 메소드가 한번 끝나면 그대로 사라지고, 사라지고 반복하다 전부 반복되면 main도 완료하고 사라짐. 이렇게 쌓으면서 실행하는 영역이라고 해서 스택영역이라고 부름. 스택 영역의 생성되는 순서는 절차형 프로그래밍과 같다. 영역에서 소멸하는 순서도 생성된 순서의 역순이다. 이것을 First Input Last Output, FILO, 선입후출 구조라고 부름</p>
<p>메서드 원본 영역(위) / 스택 영역(왼쪽) / heap 영역(오른쪽) ==> T자형 메모리 구조라고 부름.</p>
<p>void = 반응이 없음(일방통행인) 메소드나 함수를 입력할 때 쓰는 것, 돌려주는게 없으면 void다 라고 표현하기도 함.</p>
<p>드디어 gettext와 settext를 깨달았다. settext는 text를 입력해두는거라 그걸로 변수할당 없이 그냥 void이고, gettext는 void가 아니라서 입력값을 받아서 변수에 할당할 수 있다.</p>
<p>void가 아니면 return값이 있다. <<<=== 중요</p>
<p>File file = new File("test.txt"); // 폴더와 파일을 다루는 메서드, 그냥 존재만 확인 ===> 이상하게 프로젝트 밑에 두면 괜찮은데 패키지 안까지 가져오면 인식을 못함, 패키지가 더 가까우니까 더 잘 인식해야되는거 아닌가 싶기도 함.</p>
<p>FileWriter file = new FileWriter("test2.txt");<br>
어떤 파일을 생성하고, 그 파일에 텍스트를 보낼 수 있는 통로까지 만드는 메서드<br>
이때 이 통로를 Stream, 스트림 이라고 부르는데, 이 스트림을 만들 때 프로그램이 꺼지는 등 오류가 발생할 확률이 높다.<br>
이 스트림이 만들어지는 대표적인 상황은<br>
1. 파일에 읽고 쓸 때<br>
2. 네트워크를 연결 할 때<br>
3. cpu를 연결할 때<br>
</p>
<p>스트림 한번 쓰면 꼭 명령어로 닫아줘야함</p>
<p>try - catch문 ==> try에 명령어, 실패하면 catch문 실행</p>
<p>public void open / public void main, main만 혼자 실행 가능, open은 명령어 opne을 통해 따로 열어줘야 가능.</p>
</details>